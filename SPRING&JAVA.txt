Frameworks
	HazelCast
	EhCache
	Redis
	Lombok
	slf4j

Use of annotations
Design patterns
AOP
JPA
Functional Programming


Optional
ForkJoinPool
Design Patterns
Stream  reduce
        collects
		parallel Stream  <------
Lambda Expressions
Method Reference
Generics
Functional Programming
Type annotations         <-----
Type inference           <-----
Chained Exceptions       <-----
varargs                  <-----
try with resources       <-----
multiple exception handling <-----
instrumentation
hot swaping

Spring Containers
	Bean Factories
	ApplicationContext(Builds on top of Bean Factories , it is a super class)
		Implementations
			ClassPathXmlApplicationContext ....
			
Spring Bean Life Cycle
	Constructor
	Setter Methods
	BeanNameAware
	BeanClassLoaderAware
	BeanFactoryAware
	BeanPostProcessor.postProcessorBeforeInitialization--------|
	@PostConstruct											   |
	InitializinBean(interface).afterSetProperties              |---> Every Bean that implements this interface will be called each time a bean is requested
	init-method                                                |     Better implement Order interface in the case more than one bean implements this interface
	BeanPostProcessor.postProcessorAfterInitialization---------|
	
	
Three ways to configure application context
		@Configuration
		@ComponentScan(basePackages={"sdasda","asdasda"})
		@ComponentScan(basePackages={CDPlayer.class,DVDPlayer.class})
			@Component
		
		@Configuration
		@Import(CDConfig.class)
		@ImportResource("classpath:cd-config.xml")
			@Bean
			@Autowired
			
		XML
			Contructor injection
			Property injection
			C-namespace
			P-namespece
			
			inport java config in XML , use the bean tag <bean>
			
			Environment
				1 Configure each artifact in a separate configuration class and then use MAVEN PROFILES!!!
				2 Actually we use the ant task to choose which file goes into the artifact war file
				  services-was.xml file is deployed on different foldess (dev/rec/prd)
				  We use the jndi to acess the datasource for instance
				In local enviornment we use the 
					context.xml (Tomcat specific file)
					server.xml
					In both we define the resources 
					
				3 Spring
				  Bean profiles
					@Profile("dev") -> COULD BE USED AT CLASS AND METHOD LEVEL
					
					spring.profiles.active
					spring.profiles.default
					
					Active the profile -> Parameters on DispatchServlet
					                      Context Parameters of a web application
										  JNDI entries
										  Environment variables
										  JVM system properties
										  @ActiveProfiles on integration test class
					
			Annotation are METADATA.Metadata is data about data.So annotations are metadata for code.
			For instance the @Override annotation 
			
			@Override
			public String toString(){
				...
			}
			
			Defines annotation
			@Target(ElementType.METHOD)
			@Retention(RetentionPolicy.SOURCE)
			public @interface Override{
			
			}
			
			
			Declares to the compiler that the method is an overridden method and if any such method exist in the parent class,then throw a compiler error!!!
			
			The consumer of the annotation could be the JVM the compiler 
					
			Conditional Beans
				@Bean
				@Conditional(implements Conditional interface)
					
					public interface Condition{
						boolean matches(ConditionContext ctxt,AnnotatedTypeMetadata metadata);
					}
					
				Ambiguity
					@Primary
					@Qualifier
					
					Because @Qualifier is not annotated with @Repeatable there is no way to apply more tha one @Qualifier in the same item
					So create custom Qualifier annotattion
					@Target
					@Retention
					@Qualifier
					public @interface Cold
					
				Bean Scopes
					Singleton (Default)
					Prototype
					Session (Web Application)
					Request (Web Appplication)
					
					@Scope
						When injecting a session or request scoped bean into a singleton bean (this bean is immediatelly instantiated)
							There is two challenges :
								1) How to insert a bean which does not yet exist ?
								2) Because there may be several sessions in parallel, which one to choose ?
								
								Use a proxy that redirects to the correct session bean!!!
								
								@Scope(value = WebApplicationContext.SCOPE_SESSION,proxyMode = ScopedProxyMode.INTERFACES)
								
								If the Session bean is an inteface then use the INTERFACES values.Otherwise if the Session Bean is a concrete class we must use CGLib to generate a class-based proxy!!!
					
					Inject RUNTIME values in a BEAN
						1) Defines the properties in a property source and retrieve the properties via the Spring Environment.
						
						@Configuration
						@PropertySource("classpath:/com/soundsystem/app.properties")
						public class ExpressConfig{
							@Autowired
							Environment env;
							
							@Bean
							public BlankDisc disc(){
								return new BlankDisc(env.getProperty("disc.title"),env.getProperty("disc.artist"))
							}
							
						2)@Bean public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {
							PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer = new PropertySourcesPlaceholderConfigurer();
							propertySourcesPlaceholderConfigurer.setLocations(new ClassPathResource("application-db.properties"));
							return new PropertySourcesPlaceholderConfigurer();
						 }*We may not use the two below lines 
										PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer = new PropertySourcesPlaceholderConfigurer();
										propertySourcesPlaceholderConfigurer.setLocations(new ClassPathResource("application-db.properties"));
										
										BUT INSTEAD USE THE @PropertySource , the main objective of PropertySourcesPlaceholderConfigurer bean is allow to use the placeholders!!!!
										
								@Value("${disc.title}")
								
						3)Use SPEL
							@Value("#{systemProperties['disc.title']}")
							
							Evaluating Collections
							.? operator Filter a Collection into a subset of the collection
							#{jukebox.songs.?[artist eq 'Aerosmith']}
							.^[] First matching entry
							.$[] Last matchinf entry
							.![] project properties from the elements in the collection onto a new collection.
							#{jukebox.songs.![title]} -> Collection of all song titles.
							
				AOP
					Spring aspects are implemented as PROXIES that wrap the target object.Because of that Spring only supports method join points!!!!
					SPRING AOP IS PROXY BASED(Run Time).There is no need of Compiler(special compiler) or ClassLoader(special classloader) special features provided by other provideder.
					
					PointCut
						execution(* concert.Performance.perform(..))
						
						@Configuration
						@EnableAspectJAutoProxy  <---- Enable Aspects
						@ComponentScan
						public class ConcertConfig{
							@Bean
							public Audience audience(){
								return new Audience();
							}
						}
						
						@Aspect
						public class Audience{
							@Pointcut("execution(** concert.Performance.perform(..))")
							public void performance(){}
							
							@Before("performance()")
							...
						}
						
						Passing and access parameters
							@Pointcut("execution(* soundsystem.CompactDisc.playTrack(int)) && args(trackNumber)")
							public void trackPlayed(int trackNumber){}
							
							@Before("trackPlayed(int trackNumber)")
							
							The args qualifier indicates that any int argument that is passed into the execution of playTrack() should also be passed into the advice.
							The parameter name,trackNumber,also matches the parameter in the pointcut method signature.
							
							INTRODUCTIONS(Like Mixins in Javascript)
								Aspects can attach new methods to Spring beans!!!
								Aspects are proxies that implement the same interfaces as the beans they wrap.If the proxy also expose some new interface than is like adding new methods to the beans they wrap to.
								
								@Aspect
								public class EncorableIntroducer{
									@DeclareParents(value="concert.Performance+",defaultImpl=DefaultEncorable.class)
									public static Encorable encorable;
								}
								
								The value identifies the kinds of beans that should be introduced with the interface.(The plus sign specifies any subtype of Performance)
								The defaultImpl attribute identifies the class that will provide the implementation for the introduction.
								The static property specifies the interface that is to be introduced.
								
								
				SPRING MVC
					Request -> DispatchServlet(Front Controller Pattern) -> Handler Mapping(Which controller should treat this request?) -> Controller (Shoul delegate responsibility for the business logic to one 
					or more service objects,it PACKAGE THE MODEL DATA AND IDENTIFY THE NAME OF A VIEW THAT SHOULD RENDER THE OUTPUT)->  VIEW RESOVER -> VIEW -> RESPONSE
					
					Configure Dispatch Servlet
						1) web.xml
						2) Servlet 3.0
							Container looks for any classes in the classpath that implement the javax.servlet.ServletContainerInitializer interface that is used to configure the servlet container!!!
							
							Service Provider Interface(SPI) CONCEPT:
								Allows the applications to be extensible without modifying its original code base.It is like using plug ins or modules.
								
								HOW TO MAKE THE HOOK IN THE SERVICE PROVIDER FRAMEWORK ?
									WE NEED TO CREATE A FILE IN THE FOLDER META-INF/services !!!!!
										The file will be named the interface of the service and the content will be the service provider!!!
										https://itnext.io/java-service-provider-interface-understanding-it-via-code-30e1dd45a091
										
										The framework provides the ServiceLoader.load(name of the interface)
										loader.iterator -> Iterate through all the services that implement that interface !!!!
										
										So in this case , Servlet 3.0 through the SPI look for implementations of the ServletContainerInitializer!!
										Spring implements ServletContainerInitializer through SpringServletContainerInitializer, this implementation is in the 
										spring-web*.jar and the hook in the META-INF/services/javax.servlet.ServletContainerInitializer
										
										https://www.logicbig.com/tutorials/java-ee-tutorial/java-servlet/servlet-container-initializer-example.html
										
										The ServletContainerInitializer has just one method
											public void onStartup(Set<Class<?>> c,ServletContext ctx)
										
										SpringServletContainerInitializer class has a @HandlerTypes annotation with a value of WebApplicationInitializer
										This annotation is used to declare the class types that a ServletContainerInitializer can handle !!!
										In the Spring case the @HandlesType will have the WebApplicationInitializer value !!!
										
								public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
									
									@Override
									protected String[] getServletMappings() {
									return new String[] { "/" };
									}
									@Override
									protected Class<?>[] getRootConfigClasses() {
									return new Class<?>[] { RootConfig.class };
									}
									@Override
									protected Class<?>[] getServletConfigClasses() {
									return new Class<?>[] { WebConfig.class };
									}
								}
								
								We extend the AbstractAnnotationConfigDispatcherServletInitializer that implements the WebApplicationInitializer and our class will be called on start up!!!
								
							public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
								
								@Override
								protected String[] getServletMappings() {
									return new String[] { "/" };
								}
								
								@Override
								protected Class<?>[] getRootConfigClasses() {
									return new Class<?>[] { RootConfig.class };
								}
								
								@Override
									protected Class<?>[] getServletConfigClasses() {
								return new Class<?>[] { WebConfig.class };
								}
							}
							
							In SPRING MVC there are two contexts
								DispatchServlet creates web application context through getServletConfigClasses
								The ContextLoaderListener loads the root application context.
								
								Without extend any class we must register the ContextLoaderListener manually!!
								public class ApplicationInitializer implements WebApplicationInitializer{
									@Override
									public void onStartup(ServletContext servletContext){
										XmlWebApplicationContext rootContext = new XmlWebApplicationContext();
										rootContext.setConfigLocations("/WEB-INF/rootApplicationContext.xml");
										servletContext.addListener(new ContextLoaderListener(rootContext));
									}
								}
								
								If we use the AbstractContextLoaderInitializer class we must just to initialize the context , the Listener is initalized automatically!!!
								public class AnnotationsBasedApplicationInitializer extends AbstractContextLoaderInitializer {
  
									@Override
									protected WebApplicationContext createRootApplicationContext() {
										AnnotationConfigWebApplicationContext rootContext = new AnnotationConfigWebApplicationContext();
										rootContext.register(RootApplicationConfig.class);
										return rootContext;
									}
								}
								
								To configure the dispatch servlet we can use the same patterns we have used to configure the root !!!
								
								onStartup(ServletContext context){
									XmlWebApplicationContext normalWebAppContext = new XmlWebApplicationContext();
									normalWebAppContext.setConfigLocation("/WEB-INF/normal-webapp-servlet.xml");
									ServletRegistration.Dynamic normal = servletContext.addServlet("normal-webapp", new DispatcherServlet(normalWebAppContext));
									normal.setLoadOnStartup(1);
									normal.addMapping("/api/*");
								}
								
								using the AbstractDispatcherServletInitializer we can override the method 
								
								@Override
								protected WebApplicationContext createServletApplicationContext() {
								  
									AnnotationConfigWebApplicationContext secureWebAppContext = new AnnotationConfigWebApplicationContext();
									secureWebAppContext.register(SecureWebAppConfig.class);
									return secureWebAppContext;
								}
								 
								@Override
								protected String[] getServletMappings() {
									return new String[] { "/s/api/*" };
								}
								
								The root context is the parent of every dispatcher servlet context. Thus, beans defined in the root web application context are visible to each dispatcher servlet context, but not vice versa!!!
								
								https://www.baeldung.com/spring-web-contexts
								
								Enable Spring MVC
								@Configuration
								@EnableWebMvc
								@ComponentScan("spitter.web")
								public class WebConfig extends WebMvcConfigurerAdapter{
									
									@Bean
									public ViewResolver viewResolver() {
										InternalResourceViewResolver resolver = new InternalResourceViewResolver();
										resolver.setPrefix("/WEB-INF/views/");
										resolver.setSuffix(".jsp");
										resolver.setExposeContextBeansAsAttributes(true);
										return resolver;
									}
									
									@Override
									public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
										configurer.enable();
									}
									//This method is from WebMvcConfigurerAdapter
									//By calling enable() we ask the DispatcherServlet to forward request for static resources to the servlet container default servlet and not try to handle them it itself.
								
								}
								
								@Controller <- Stereotype annotation based on @Component annotation
								public class HomeController {
									@RequestMapping(value="/", method=GET)
									public String home() {
										return "home";
									}
								}
								
								Test MVC Controller 
								@Test
								public void testHomePage() throws Exception {
									HomeController controller = new HomeController();
									MockMvc mockMvc = standaloneSetup(controller).build();
									mockMvc.perform(get("/")).andExpect(view().name("home"));
								}
								
								@Controller
								@RequestMapping
								
								GET -> "/spittles?max=238900&count=50"
								@RequestMapping(value="/show",method=RequestMethod.GET)
								public String showSpittle(@RequestParam("max",defaultValue=...) ....
								
								Retrieve a page of a used ID , we could use query parameter stratagey , like this
								GET -> /spittles/show?spittle_id=12345 but this is not ideal for resource-orientation (REST services).
								Ideally,the resource being identified would be identified by the URL path and not by query parameters
								GET -> /spittles/12345 is better , it identifies a resource to be retrieved.
								
								@RequestMapping(value="/{spittleId}",method=RequestMethod.GET)
								public String spittle(@PathVariable("spittleId") long spittleId,Model model)
								
								SERVLET SPECIFICATION
									RequestDispatcher.forward -> Completely on Server side
									vs
									HttpServletResponse.sendRedirect()  -> Sent Back to client with HTTP Response 302 and a new URL in the Location header
									
								VALIDATION
									Use the Java Validation API , an implementation must be present in the classpath (like Hibernate Validator)
									@RequestMapping(value="/register", method=POST)
									public String processRegistration(@Valid Spitter spitter,Errors errors)
									
								Views
									Two interfaces
										public interface ViewResolver {
											View resolveViewName(String viewName, Locale locale) throws Exception;
										}

										public interface View {
											String getContentType();
											void render(Map<String, ?> model,HttpServletRequest request,HttpServletResponse response) throws Exception;
										}
										
								Exception handlers

									@ResponseStatus(value=HttpStatus.NOT_FOUND,reason="Spittle Not Found")
									public class SpittleNotFoundException extends RuntimeException
								
									@ExceptionHandler(*Exception.class)
									public String handle...()
									
									Advising Controllers
									@ControllerAdvice
									public class AppWideExceptionHandler{
									
										@ExceptionHandler(DuplicateSpittleException.class)
										public String duplicateSpittleHandler() {
										
									Sending data in REDIRECTS
										MODEL ATTRIBUTES ARE COPIED INTO THE REQUEST AS REQUEST ATTRIBUTES !!!
										
									Same Origin Policy
										Two URL have the same origin if PROTOCOL/PORT(If specified) AND HOST are the same
										
										<img> and <video> and <script> tags are NOT LIMITED by the Same Origin Policy !!!!
										
										Image Pings are used to pass some data to the server(Google Analytics use this technique)
										
									
									CORS(Cross Origin Resource Sharing)
									
									CSRF(Cross Site Request Forgery)
									
									
									SECURITY
										Spring employs several servlet filters to provide various aspects of security!!!!
										We only need to configure one filter that is the DelegatingFilterProxy and this filter will delegate to an implementation of javax.servlet.Filter that is
										registered as a <bean> in the Spring application context.
										We can register this filter through XML or Java
										With Java we use the following class
											public class SecurityWebInitializer extends AbstractSecurityWebApplicationInitializer {}
											THIS IMPLEMENTS THE WEBAPPLICATIONINITIALIZER, SO IT WILL BE DISCOVERY BY SPRING AND REGISTER THE DELEGATINGFILTERPROXY with the web container.
											Whether you configure DelegatingFilterProxy in web.xml or by subclassing AbstractSecurityWebApplicationInitializer, it will intercept requests coming
											into the application and delegate them to a bean whose ID is springSecurityFilterChain.
											The bean springSecurityFilterChain will be created when we enable the web security.
											
											@Configuration
											@EnableWebMvcSecurity
											public class SecurityConfig extends WebSecurityConfigurerAdapter {
											
												
												@Override
												protected void configure(AuthenticationManagerBuilder auth) throws Exception {
													//IN MEMORY DATABASE
													auth.inMemoryAuthentication().withUser("user").password("password").roles("USER").and().withUser("admin").password("password").roles("USER", "ADMIN");
													//RELATIONAL DATABASE
													//WE MUST ADHERE TO THE BASIC CONTRACT OF THE QUERIES
													//THE USERNAME MUST BE THE ONLY PARAMETER
													//THE AUTHENTICATION QUERY SELECTS THE USERNAME PASSWORD AND ENABLED STATUS FOR INSTANCE
													auth.jdbcAuthentication().dataSource(dataSource).usersByUsernameQuery(
														"select username, password, true from Spitter where username=?").authoritiesByUsernameQuery("select username, 'ROLE_USER' from Spitter where username=?");
													//CUSTOM USER SERVICE WE MUST IMPLEMENT USERDETAILSSERVICE
													public interface UserDetailsService {
														UserDetails loadUserByUsername(String username)throws UsernameNotFoundException;
													}
													//THEN USE IT LIKE THIS
													auth.userDetailsService(new SpitterUserService(spitterRepository));
													//INSTEAD OF USING ONE OF THE METHODS (inMemoryAuthentication or jdbcAuthentication or ldapAuthentication) use the userDetailsService
												}
												
												@Override
												protected void configure(HttpSecurity http) throws Exception {
													http.authorizeRequests().antMatchers("/spitters/me").authenticated().antMatchers(HttpMethod.POST, "/spittles").authenticated().anyRequest().permitAll();
													//USE SPEL WITH ACCESS
													//IT ALLOWS MORE THAN ONE DIMENSIONAL SECURITY METHOD
													//HTTPS
													.requiresChannel().antMatchers("/spitter/form").requiresSecure();
												}
												
											
											}
											
											SESSION TRACKING IN JAVA
												JSESSIONID is used to keep track of the request
													URL rewriting -> APPENDED TO THE URL
													Cookies       
													Hidden form fields
													HTTPS AND SSL
													
											ACCESS TO DATABASE
												JDBC -> DataAccessException is an unchecked exception !!!!
												Spring uses the Template Method Pattern
												
												Template Classes manage the fixed part of the process
												Callbacks are the custom data-access code
												
												Configuring DataSource
													JDBC Driver
														@Bean
														public DataSource dataSource() {
															DriverManagerDataSource ds = new DriverManagerDataSource();
															ds.setDriverClassName("org.h2.Driver");
															ds.setUrl("jdbc:h2:tcp://localhost/~/spitter");
															ds.setUsername("sa");
															ds.setPassword("");
															return ds;
														}
													JNDI
														@Bean
														public JndiObjectFactoryBean dataSource() {
															JndiObjectFactoryBean jndiObjectFB = new JndiObjectFactoryBean();
															jndiObjectFB.setJndiName("jdbc/SpittrDS");
															jndiObjectFB.setResourceRef(true);
															jndiObjectFB.setProxyInterface(javax.sql.DataSource.class);
															return jndiObjectFB;
														}
													Pool Connections
														https://www.baeldung.com/java-connection-pooling
														@Bean
														public BasicDataSource dataSource() {
															BasicDataSource ds = new BasicDataSource();
															ds.setDriverClassName("org.h2.Driver");
															ds.setUrl("jdbc:h2:tcp://localhost/~/spitter");
															ds.setUsername("sa");
															ds.setPassword("");
															ds.setInitialSize(5);
															ds.setMaxActive(10);
															return ds;
														}
														
												ORM JPA
													main interface is Session (save,update,delete and load objects)
													To get one Session we need SessionFactory interface.
													
													EXCEPTION TRANSLATION
													@Bean
													public BeanPostProcessor persistenceTranslation() {
														return new PersistenceExceptionTranslationPostProcessor();
													}
													
													Bean POSTPROCESSOR that adds an adviser to any bean that is annotated with @Repository
													
													Two kinds of entity managers
														Application Managed
														Container managed : The application does not interact with the entity manager factory at all.
														
														Spring abstracts the EntityManager creation on our behalf.
															LocalEntityManagerFactoryBean
																Application Managed entity manager factories derive most of their configuration information from persistence.xml
																(must appear in the META-INF directory in  the classpath)
																It configures  persistence units that is a grouping of one or more classes that correspond to a single data source.
																DO NOT FORGET THAT SPRING IS A CONTAINER !!!
															LocalContainerEntityManagerFactoryBean
																@Bean
																public LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource, JpaVendorAdapter jpaVendorAdapter) {
																	LocalContainerEntityManagerFactoryBean emfb = new LocalContainerEntityManagerFactoryBean();
																	emfb.setDataSource(dataSource);
																	emfb.setJpaVendorAdapter(jpaVendorAdapter);
																	emfb.setPackagesToScan("com.habuma.spittr.domain");
																	return emfb;
																}
																
																ENTITY MANAGER IS NOT THREAD SAFE !!!!
																
																
																@PersistenceContext
																private EntityManager em;
																The truth is that @PersistenceContext doesn’t inject an EntityManager—at least,not exactly. 
																Instead of giving the repository a real EntityManager, it gives a proxy to a real EntityManager. 
																That real EntityManager either is one associated with the current transaction or, if one doesn’t exist, creates a new one. 
																Thus, you know that you’re always working with an entity manager in a thread-safe way.
																It’s important to understand that @PersistenceUnit and @PersistenceContext aren’t Spring annotations!
																In order for Spring to understand them and inject we need a Spring PersistenceAnnotationBeanPostProcessor must be configured.
																@Transactional indicates that the persistence methods in this repository are involved in a transactional context.
																Without a template to handle exception translation, you need to annotate your repository with @Repository so PersistenceExceptionTranslationPostProcessor 
																knows that this is a bean for which exceptions should be translated into one of Spring’s unified data-access exceptions.
																
																CERTAIN DYNAMIC PERSISTENCE FEATURES REQUIRE THAT  THE CLASS OF PERSITENT OBJECTS BE MODIFIED WITH INTRUMENTATION TO SUPPORT THE FEATURE.
																OBJECTS WHOSE PROPERTIES ARE LAZY LOADED MUST HAVE THEIR CLASS INSTRUMENTED WITH CODE THAT KNOWS TO RETRIEVE UNLOADED DATA ON ACCESS.SOME 
																FRAMEWORKS USE DYNAMIC PROXIES TO IMPLEMENT LAZY LOADING.OTHERS PERFORM CLASS INSTRUMENTATION AT COMPILE TIME.
																
																TO AVOID THIS BOILERPLATE CODE 
																public void addSpitter(Spitter spitter) {
																	entityManager.persist(spitter);
																}
																
																WE CAN USE SPRING DATA JPA WE JUST HAVE TO WRITE THE INTERFACE LIKE THIS ONE
																public interface SpitterRepository extends JpaRepository<Spitter, Long> {
																}
																
																JpaRepository is parameterized such that it knows this is a repository for persisting Spitter objects and that Spitters have an ID of type Long.
																It also inherits 18 methods for performing common persistence operations.
																To ask Spring Data to create an implementation of SpitterRepository we need to add the annotation 
																
																@Configuration
																@EnableJpaRepositories(basePackages="com.habuma.spittr.db")
																public class JpaConfiguration {
																
																SpitterRepository interface, it extends JpaRepository.
																JpaRepository extends the marker Repository interface (albeit indirectly).
																Therefore, SpitterRepository transitively extends the Repository interface that repository-scanning is looking for.
																When Spring Data finds it, it creates an implementation of SpitterRepository, including an implementation of all 18 methods inherited
																from JpaRepository, PagingAndSortingRepository, and CrudRepository.
																
																We can add methods to the interface through a domain specific language where persistence details are expressed in interface methods signatures.
																For instance findByUsername
																Four verbs are allowed in this dsp (get,read,find and count)
																
																@Query
																
																Custom methods
																Spring also looks for a class whose name is the same as the interface's name postfixed with Impl.
																If the class exists,Spring Data Jpa merges its methods with those generated by Spring Data Jpa.
																
																public class SpitterRepositoryImpl implements SpitterSweeper {
																	@PersistenceContext
																	private EntityManager em;
																	
																	public int eliteSweep() {
																	 String update ="UPDATE Spitter spitter SET spitter.status = 'Elite' WHERE spitter.status = 'Newbie' " +
																	"AND spitter.id IN (SELECT s FROM Spitter s WHERE (" +
																	" SELECT COUNT(spittles) FROM s.spittles spittles) > 10000)";
																	return em.createQuery(update).executeUpdate();
																	}
																}
																
														CACHING
															@Configuration
															@EnableCaching
															
															Under the hood
																It creates an aspect with pointcuts that trigger off of Spring's caching annotations.
															
																
																@Bean
																public EhCacheCacheManager cacheManager(CacheManager cm) {
																	return new EhCacheCacheManager(cm);
																}
																
																@Bean
																public EhCacheManagerFactoryBean ehcache() {
																	EhCacheManagerFactoryBean ehCacheFactoryBean = new EhCacheManagerFactoryBean();
																	ehCacheFactoryBean.setConfigLocation(new ClassPathResource("com/habuma/spittr/cache/ehcache.xml"));
																	return ehCacheFactoryBean;
																}
																
																@Cacheable -> Method is only invoked if the value is not on the cache
																When you annotate the interface method, the @Cacheable annotation will be inherited by all implementations of SpittleRepository, 
																and the same caching rules will be applied.
																
																@CachePut -> Method is always invoked!!!
																Used on save methods for instance !!!!
																@CachePut(value="spittleCache", key="#result.id")
																Spittle save(Spittle spittle);
																
														METHODS SECURITY
														@Configuration
														@EnableGlobalMethodSecurity(securedEnabled=true)	
														public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
														}

														@Secured(Spring) and @RolesAllowed(JSR)
														Just takes into account the user's granted authorities
														
														@PreAuthorize -> evaluated before the method invocation
														@PostAuthorize -> evaluated after the method invocation
														@PostFilter
														@PreFilter
														
														ALL USE THE SPEL !!!!!
														
														@PreAuthorize("hasRole('ROLE_SPITTER')") equivalent to @Secure and @RolesAllowed
														
														PERMISSION EVALUATOR
															By default Spring is configured with a DefaultMethodSecurityExpressionHandler that is given an instance of DenyAllPermissionEvaluator,
															always return false from its hasPermission() methods.
															
															Customizing the GlobalMethodSecurityConfiguration !!!!
															
															@Override
															protected MethodSecurityExpressionHandler createExpressionHandler() {
																DefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler();
																expressionHandler.setPermissionEvaluator(new SpittlePermissionEvaluator());
																return expressionHandler;
															}
														
															Now anytime you secure a method with an expression that uses hasPermission(), the SpittlePermissionEvaluator will be invoked!!!
															
													RPC Models
														RMI -> Java Based Services (firewalls are not a factor)
														Hessian/Burlap -> Java Servives when firewall are a factor
														Http Invoker -> Spring based services when network constraints are a factor and we desire Java serialization over XML
														JAX-RPC /JAX-WS plataform neutral services ,SOAP-based
														
														
														VERY IMPORTANT:
															ANY FACTORY BEAN IN SPRING , THAT IS , ANY BEAN THAT IMPLEMENTS THE SPRING'S FACTORYBEAN INTERFACE) 
															THE BEAN THAT IS REGISTERED IN THE SPRING APPLICATION CONTEXT IS NOT AN INSTANCE OF *FACTORYBEAN BUT RATHER IS AN INSTANCE OF 
															THE CLASS RETURNED FROM THE FACTORY !!!!
															
															Client -> Proxy(Handle netweok communication) 
															
															Service Interface -> Remote Exporter(Handle Marshaling/Unmarshaling) -> Has a Service implementation bean
															
															In RMI usually the following steps are made :
																1 Create Service Implementation with methods that throw java.rmi.RemoteException
																2 Service Interface that extends java.rmi.Remote
																3 Run the RMI compiler (rmic) produce stub and server skeleton
																4 Start RMI registry
																5 Register the service
																
															Exposing	
															@Bean
															public RmiServiceExporter rmiExporter(SpitterService spitterService) {
																RmiServiceExporter rmiExporter = new RmiServiceExporter();
																rmiExporter.setService(spitterService);
																rmiExporter.setServiceName("SpitterService");
																rmiExporter.setServiceInterface(SpitterService.class);
																rmiExporter.setRegistryHost("rmi.spitter.com");
																rmiExporter.setRegistryPort(1199);
																return rmiExporter;
															}
															Consuming
															Using RMI to get a remote service
															String serviceUrl = "rmi:/spitter/SpitterService";
															SpitterService spitterService = (SpitterService) Naming.lookup(serviceUrl);
															
															this code is in direct opposition to the principles of dependency injection (DI). Because the client code is responsible for
															looking up the Spitter service and the service is an RMI service, there’s no opportunity to provide a different implementation of SpitterService from 
															some other source.
															@Bean
															public RmiProxyFactoryBean spitterService() {
																RmiProxyFactoryBean rmiProxy = new RmiProxyFactoryBean();
																rmiProxy.setServiceUrl("rmi://localhost/SpitterService");
																rmiProxy.setServiceInterface(SpitterService.class);
																return rmiProxy;
															}

															@Autowired
															SpitterService spitterService;

														Because RMI is java based both the client and service must be written in Java adn because RMI uses serialization, the types of the objects 
														being sent across the netweok must have the exact same version of the  Java runtime on both sides of the call.

														Hessian
															Use binary messages to communicate between client and service.The binary message is portable to languages other than Java(PHP,Python,C++ and C#)
														Burlap
															Use XML,the message structure is as simple as possible and does not require and external definition language such as WSDL or IDL.
															
															BOTH protocols work under HTTP so the Exporter is a Spring MVC controller!!!
															So we must configure the DispatchServelet
															@Bean
															public HessianServiceExporter
															hessianExportedSpitterService(SpitterService service) {
																HessianServiceExporter exporter = new HessianServiceExporter();
																exporter.setService(service);
																exporter.setServiceInterface(SpitterService.class);
																return exporter;
															}
															
															@Override
															protected String[] getServletMappings() {
																return new String[] { "/", "*.service" };
															}
															
															@Bean
															public HandlerMapping hessianMapping() {
																SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
																Properties mappings = new Properties();
																mappings.setProperty("/spitter.service","hessianExportedSpitterService");
																mapping.setMappings(mappings);
																return mapping;
															}
															
														Spring HTTPInvoker
															Performs remoting across HTTP (like Hessian and Burlap) and use Java serialization(like RMI)
															
															
														JAX-WS
															SimpleJaxWsServiceExporter requires thar JAX-WS runtime support publishing of endpoints to a specified address!!!
															If it does not support we will have to write our own JAX-WS endpoints in a more conventional way.This means the lifecycle of the endpoints
															will be managed by the JAX-WS runtime and not by Spring.
															If we extend SpringBeanAutowiringSupport we can annotate properties with @Autowire with an endpoint managed by the JAX-WS runtime.
															
															@WebService(serviceName="SpitterService")
															public class SpitterServiceEndpoint extends SpringBeanAutowiringSupport {

															@Autowired
															SpitterService spitterService;

															@WebMethod
															public void addSpittle(Spittle spittle) {
																spitterService.saveSpittle(spittle);
															}
															
														Unlike those other service exporters, SimpleJaxWsServiceExporter doesn’t need to be given a reference to the bean it’s supposed to export. 
														Instead, it publishes all beans that are annotated with JAX-WS annotations as JAX-WS services.
														
											REST
												Spring offer two options to transform a resource Java representation into the representation that's shipped to the client:
													Content negotiation
														When it comes to resolving view names into views that can produce resource representations, there’s an additional dimension to consider. 
														Not only does the view need to match the view name, but the view also needs to be chosen to suit the client.
														ContentNegotiatingViewResolver is a special view resolver that takes the content type that the client wants into consideration.
															First tries the URL's file extension.
															Second look in the Accept header field.
															Default to the configured content type.
															
														ContentNegotiatingViewResolver asks the other view resolvers to resolve the logical view name into a view.
														Every view that’s resolved is added to a list of candidate views. With the candidate view list assembled, ContentNegotiatingViewResolver
														cycles through all the requested media types, trying to find a view from among the candidate views that produces a matching content type.
														The first match found is the one that’s used to render the model.
														To configure the ContentNegotiatingViewResolver we use the ContentNegotiationManager, to configure it we have three options :
															Directly declare a bean whose type is ContentNegotiationManager.
															Create the bean indirectly via ContentNegotiationManagerFactoryBean
															Override the configurationContentNegotiation method of WebMvcConfigurer
															
															@Bean
															public ViewResolver cnViewResolver(ContentNegotiationManager cnm) {
																ContentNegotiatingViewResolver cnvr = new ContentNegotiatingViewResolver();
																cnvr.setContentNegotiationManager(cnm);
																return cnvr;
															}
															
															
															@Override
															public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
																configurer.defaultContentType(MediaType.TEXT_HTML);
															}
															
															@Bean
															public ViewResolver beanNameViewResolver() {                  <--Look up views as beans
																return new BeanNameViewResolver();
															}

															@Bean
															public View spittles() {
																return new MappingJackson2JsonView();     <- JSON views
															}
															
															In addition to what’s shown in listing 16.2, there would also be an HTML-capable view resolver (such as InternalResourceViewResolver)
														
													Message Conversion
														When using message conversion, DispatcherServlet doesn’t bother with ferrying model data to a view. 
														In fact, there is no model, and there is no view. There is only data produced by the controller and a resource representation produced when a 
														message converter transforms that data.
														If we employ message conversion, you need to tell Spring to skip the normal model/view flow and use a message converter instead.
														We can use @ResponseBody
														
														@RequestMapping(method=RequestMethod.GET,produces="application/json")
														public @ResponseBody List<Spittle> spittles

														For illustration’s sake, if the client’s Accept header specifies that the client will accept application/json, and if the Jackson JSON library is in the 
														application’s classpath, then either MappingJacksonHttpMessageConverter or MappingJackson2HttpMessageConverter will be chosen
														the @RequestBody tells Spring to find a message converter to convert a resource representation coming from a client into an object either.
														
														@RequestMapping(method=RequestMethod.POST,consumes="application/json")
														public @ResponseBody Spittle saveSpittle(@RequestBody Spittle spittle)
														
														If you’re writing a controller that has several methods, all of which should use message conversion, then those annotations get somewhat repetitive.
														@RestController
														
														JMS
															RPC over JMS !!!!Basically RPC asynchronous
																JMSMessageID
																JMSCorrelationID
															
														
														AMQP
															Defines a wire-protocol for messaging whereas JMS defines an API specification.
															JMS does not mandate that messages sent by one JMS implementation can be consumend by a different JMS implementation.
															AMQP specifies the format of the messages between the producer and the consumer.
															It is more interoperable (can be changed between systems that does not run Java)
															With JMS there is only two messaging models(point to point and publish/subscribe)
															AMQP enables to rpute in a number of ways and decouple the message producer and the queues (through Exchangers)
															
														WEBSOCKET
															Provide Bi Directional ,Full Duplex,low latency in one TCP socket connection.
															It is a protocol that operates as un upgraded HTTP connection exchanging variable length frames between the two parties instead of a stream.
															SockJS is a WebSocket emulator.
															STOMP(Asynchronous)
																Just as HTTP layers a request-response model on top of TCP sockets,STOMP layers a frame-based wire format to define messaging semanticson top 
																of WebSocket.
																STOMP uses a message broker !!!
																Spring
																	Instead of using @RequestMapping use @MessageMapping
																	@EnableWebSocketMessageBroker
																	extends AbstractWebSocketMessageBrokerConfigurer{
																	
																	@Override
																	public void registerStompEndpoints(StompEndpointRegistry registry) {
																		registry.addEndpoint("/marcopolo").withSockJS();
																	}
																	@Override
																	public void configureMessageBroker(MessageBrokerRegistry registry) {
																		registry.enableSimpleBroker("/queue", "/topic");
																		registry.setApplicationDestinationPrefixes("/app");
																	}
																	
																	
												SPRING BOOT
													Spring Boot Starters
														Aggregate common grouping of dependencies into single dependencies
													AutoConfiguration
														Leverage Spring support for conditional configuration to make reasonable guesses about the beans our application 
														needs and automatically configure them.
													CLI
													Actuator
													
													<?xml version="1.0" encoding="UTF-8"?>
													<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
													http://maven.apache.org/xsd/maven-4.0.0.xsd">
														<modelVersion>4.0.0</modelVersion>
														<groupId>com.habuma</groupId>
														<artifactId>contacts</artifactId>
														<version>0.1.0</version>
														<packaging>jar</packaging>
														<parent>
															<groupId>org.springframework.boot</groupId>
															<artifactId>spring-boot-starter-parent</artifactId>
															<version>1.1.4.RELEASE</version>
														</parent>
														<dependencies>
															<dependency>
																<groupId>org.springframework.boot</groupId>
																<artifactId>spring-boot-starter-web</artifactId>
															<dependency>
															<dependency>
																<groupId>org.thymeleaf</groupId>
																<artifactId>thymeleaf-spring4</artifactId>
															</dependency>
														</dependencies>
														<build>
															<plugins>
															<plugin>
															<groupId>org.springframework.boot</groupId>
															<artifactId>spring-boot-maven-plugin</artifactId>
															</plugin>
															</plugins>
														</build>
											</project>
												
															
															
											
											
											
										
										
										
									


									
									
								
								
								
								
								
								
								
								
								
								
								
								
						

								
							
						 
						
						
				  
				
				
			
			
			
	
	
			
			
		