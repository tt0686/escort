Frameworks
	HazelCast
	EhCache
	Redis
	Lombok
	slf4j

Use of annotations
Design patterns
AOP
JPA
Functional Programming


Optional
ForkJoinPool
Design Patterns
Stream  reduce
        collects
		parallel Stream  <------
Lambda Expressions
Method Reference
Generics
Functional Programming
Type annotations         <-----
Type inference           <-----
Chained Exceptions       <-----
varargs                  <-----
try with resources       <-----
multiple exception handling <-----
instrumentation
hot swaping

Spring Containers
	Bean Factories
	ApplicationContext(Builds on top of Bean Factories , it is a super class)
		Implementations
			ClassPathXmlApplicationContext ....
			
Spring Bean Life Cycle
	Constructor
	Setter Methods
	BeanNameAware
	BeanClassLoaderAware
	BeanFactoryAware
	BeanPostProcessor.postProcessorBeforeInitialization--------|
	@PostConstruct											   |
	InitializinBean(interface).afterSetProperties              |---> Every Bean that implements this interface will be called each time a bean is requested
	init-method                                                |     Better implement Order interface in the case more than one bean implements this interface
	BeanPostProcessor.postProcessorAfterInitialization---------|
	
	
Three ways to configure application context
		@Configuration
		@ComponentScan(basePackages={"sdasda","asdasda"})
		@ComponentScan(basePackages={CDPlayer.class,DVDPlayer.class})
			@Component
		
		@Configuration
		@Import(CDConfig.class)
		@ImportResource("classpath:cd-config.xml")
			@Bean
			@Autowired
			
		XML
			Contructor injection
			Property injection
			C-namespace
			P-namespece
			
			inport java config in XML , use the bean tag <bean>
			
			Environment
				1 Configure each artifact in a separate configuration class and then use MAVEN PROFILES!!!
				2 Actually we use the ant task to choose which file goes into the artifact war file
				  services-was.xml file is deployed on different foldess (dev/rec/prd)
				  We use the jndi to acess the datasource for instance
				In local enviornment we use the 
					context.xml (Tomcat specific file)
					server.xml
					In both we define the resources 
					
				3 Spring
				  Bean profiles
					@Profile("dev") -> COULD BE USED AT CLASS AND METHOD LEVEL
					
					spring.profiles.active
					spring.profiles.default
					
					Active the profile -> Parameters on DispatchServlet
					                      Context Parameters of a web application
										  JNDI entries
										  Environment variables
										  JVM system properties
										  @ActiveProfiles on integration test class
					
			Annotation are METADATA.Metadata is data about data.So annotations are metadata for code.
			For instance the @Override annotation 
			
			@Override
			public String toString(){
				...
			}
			
			Defines annotation
			@Target(ElementType.METHOD)
			@Retention(RetentionPolicy.SOURCE)
			public @interface Override{
			
			}
			
			
			Declares to the compiler that the method is an overridden method and if any such method exist in the parent class,then throw a compiler error!!!
			
			The consumer of the annotation could be the JVM the compiler 
					
			Conditional Beans
				@Bean
				@Conditional(implements Conditional interface)
					
					public interface Condition{
						boolean matches(ConditionContext ctxt,AnnotatedTypeMetadata metadata);
					}
					
				Ambiguity
					@Primary
					@Qualifier
					
					Because @Qualifier is not annotated with @Repeatable there is no way to apply more tha one @Qualifier in the same item
					So create custom Qualifier annotattion
					@Target
					@Retention
					@Qualifier
					public @interface Cold
					
				Bean Scopes
					Singleton (Default)
					Prototype
					Session (Web Application)
					Request (Web Appplication)
					
					@Scope
						When injecting a session or request scoped bean into a singleton bean (this bean is immediatelly instantiated)
							There is two challenges :
								1) How to insert a bean which does not yet exist ?
								2) Because there may be several sessions in parallel, which one to choose ?
								
								Use a proxy that redirects to the correct session bean!!!
								
								@Scope(value = WebApplicationContext.SCOPE_SESSION,proxyMode = ScopedProxyMode.INTERFACES)
								
								If the Session bean is an inteface then use the INTERFACES values.Otherwise if the Session Bean is a concrete class we must use CGLib to generate a class-based proxy!!!
					
					Inject RUNTIME values in a BEAN
						1) Defines the properties in a property source and retrieve the properties via the Spring Environment.
						
						@Configuration
						@PropertySource("classpath:/com/soundsystem/app.properties")
						public class ExpressConfig{
							@Autowired
							Environment env;
							
							@Bean
							public BlankDisc disc(){
								return new BlankDisc(env.getProperty("disc.title"),env.getProperty("disc.artist"))
							}
							
						2)@Bean public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {
							PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer = new PropertySourcesPlaceholderConfigurer();
							propertySourcesPlaceholderConfigurer.setLocations(new ClassPathResource("application-db.properties"));
							return new PropertySourcesPlaceholderConfigurer();
						 }*We may not use the two below lines 
										PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer = new PropertySourcesPlaceholderConfigurer();
										propertySourcesPlaceholderConfigurer.setLocations(new ClassPathResource("application-db.properties"));
										
										BUT INSTEAD USE THE @PropertySource , the main objective of PropertySourcesPlaceholderConfigurer bean is allow to use the placeholders!!!!
										
								@Value("${disc.title}")
								
						3)Use SPEL
							@Value("#{systemProperties['disc.title']}")
							
							Evaluating Collections
							.? operator Filter a Collection into a subset of the collection
							#{jukebox.songs.?[artist eq 'Aerosmith']}
							.^[] First matching entry
							.$[] Last matchinf entry
							.![] project properties from the elements in the collection onto a new collection.
							#{jukebox.songs.![title]} -> Collection of all song titles.
							
				AOP
					Spring aspects are implemented as PROXIES that wrap the target object.Because of that Spring only supports method join points!!!!
					SPRING AOP IS PROXY BASED(Run Time).There is no need of Compiler(special compiler) or ClassLoader(special classloader) special features provided by other provideder.
					
					PointCut
						execution(* concert.Performance.perform(..))
						
						@Configuration
						@EnableAspectJAutoProxy  <---- Enable Aspects
						@ComponentScan
						public class ConcertConfig{
							@Bean
							public Audience audience(){
								return new Audience();
							}
						}
						
						@Aspect
						public class Audience{
							@Pointcut("execution(** concert.Performance.perform(..))")
							public void performance(){}
							
							@Before("performance()")
							...
						}
						
						Passing and access parameters
							@Pointcut("execution(* soundsystem.CompactDisc.playTrack(int)) && args(trackNumber)")
							public void trackPlayed(int trackNumber){}
							
							@Before("trackPlayed(int trackNumber)")
							
							The args qualifier indicates that any int argument that is passed into the execution of playTrack() should also be passed into the advice.
							The parameter name,trackNumber,also matches the parameter in the pointcut method signature.
							
							INTRODUCTIONS(Like Mixins in Javascript)
								Aspects can attach new methods to Spring beans!!!
								Aspects are proxies that implement the same interfaces as the beans they wrap.If the proxy also expose some new interface than is like adding new methods to the beans they wrap to.
								
								@Aspect
								public class EncorableIntroducer{
									@DeclareParents(value="concert.Performance+",defaultImpl=DefaultEncorable.class)
									public static Encorable encorable;
								}
								
								The value identifies the kinds of beans that should be introduced with the interface.(The plus sign specifies any subtype of Performance)
								The defaultImpl attribute identifies the class that will provide the implementation for the introduction.
								The static property specifies the interface that is to be introduced.
								
								
				SPRING MVC
					Request -> DispatchServlet(Front Controller Pattern) -> Handler Mapping(Which controller should treat this request?) -> Controller (Shoul delegate responsibility for the business logic to one 
					or more service objects,it PACKAGE THE MODEL DATA AND IDENTIFY THE NAME OF A VIEW THAT SHOULD RENDER THE OUTPUT)->  VIEW RESOVER -> VIEW -> RESPONSE
					
					Configure Dispatch Servlet
						1) web.xml
						2) Servlet 3.0
							Container looks for any classes in the classpath that implement the javax.servlet.ServletContainerInitializer interface that is used to configure the servlet container!!!
							
							Service Provider Interface(SPI) CONCEPT:
								Allows the applications to be extensible without modifying its original code base.It is like using plug ins or modules.
								
								HOW TO MAKE THE HOOK IN THE SERVICE PROVIDER FRAMEWORK ?
									WE NEED TO CREATE A FILE IN THE FOLDER META-INF/services !!!!!
										The file will be named the interface of the service and the content will be the service provider!!!
										https://itnext.io/java-service-provider-interface-understanding-it-via-code-30e1dd45a091
										
										The framework provides the ServiceLoader.load(name of the interface)
										loader.iterator -> Iterate through all the services that implement that interface !!!!
										
										So in this case , Servlet 3.0 through the SPI look for implementations of the ServletContainerInitializer!!
										Spring implements ServletContainerInitializer through SpringServletContainerInitializer, this implementation is in the 
										spring-web*.jar and the hook in the META-INF/services/javax.servlet.ServletContainerInitializer
										
										https://www.logicbig.com/tutorials/java-ee-tutorial/java-servlet/servlet-container-initializer-example.html
										
										The ServletContainerInitializer has just one method
											public void onStartup(Set<Class<?>> c,ServletContext ctx)
										
										SpringServletContainerInitializer class has a @HandlerTypes annotation with a value of WebApplicationInitializer
										This annotation is used to declare the class types that a ServletContainerInitializer can handle !!!
										In the Spring case the @HandlesType will have the WebApplicationInitializer value !!!
										
								public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
									
									@Override
									protected String[] getServletMappings() {
									return new String[] { "/" };
									}
									@Override
									protected Class<?>[] getRootConfigClasses() {
									return new Class<?>[] { RootConfig.class };
									}
									@Override
									protected Class<?>[] getServletConfigClasses() {
									return new Class<?>[] { WebConfig.class };
									}
								}
								
								We extend the AbstractAnnotationConfigDispatcherServletInitializer that implements the WebApplicationInitializer and our class will be called on start up!!!
								
							public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
								
								@Override
								protected String[] getServletMappings() {
									return new String[] { "/" };
								}
								
								@Override
								protected Class<?>[] getRootConfigClasses() {
									return new Class<?>[] { RootConfig.class };
								}
								
								@Override
									protected Class<?>[] getServletConfigClasses() {
								return new Class<?>[] { WebConfig.class };
								}
							}
							
							In SPRING MVC there are two contexts
								DispatchServlet creates web application context through getServletConfigClasses
								The ContextLoaderListener loads the root application context.
								
								Without extend any class we must register the ContextLoaderListener manually!!
								public class ApplicationInitializer implements WebApplicationInitializer{
									@Override
									public void onStartup(ServletContext servletContext){
										XmlWebApplicationContext rootContext = new XmlWebApplicationContext();
										rootContext.setConfigLocations("/WEB-INF/rootApplicationContext.xml");
										servletContext.addListener(new ContextLoaderListener(rootContext));
									}
								}
								
								If we use the AbstractContextLoaderInitializer class we must just to initialize the context , the Listener is initalized automatically!!!
								public class AnnotationsBasedApplicationInitializer extends AbstractContextLoaderInitializer {
  
									@Override
									protected WebApplicationContext createRootApplicationContext() {
										AnnotationConfigWebApplicationContext rootContext = new AnnotationConfigWebApplicationContext();
										rootContext.register(RootApplicationConfig.class);
										return rootContext;
									}
								}
								
								To configure the dispatch servlet we can use the same patterns we have used to configure the root !!!
								
								onStartup(ServletContext context){
									XmlWebApplicationContext normalWebAppContext = new XmlWebApplicationContext();
									normalWebAppContext.setConfigLocation("/WEB-INF/normal-webapp-servlet.xml");
									ServletRegistration.Dynamic normal = servletContext.addServlet("normal-webapp", new DispatcherServlet(normalWebAppContext));
									normal.setLoadOnStartup(1);
									normal.addMapping("/api/*");
								}
								
								using the AbstractDispatcherServletInitializer we can override the method 
								
								@Override
								protected WebApplicationContext createServletApplicationContext() {
								  
									AnnotationConfigWebApplicationContext secureWebAppContext = new AnnotationConfigWebApplicationContext();
									secureWebAppContext.register(SecureWebAppConfig.class);
									return secureWebAppContext;
								}
								 
								@Override
								protected String[] getServletMappings() {
									return new String[] { "/s/api/*" };
								}
								
								The root context is the parent of every dispatcher servlet context. Thus, beans defined in the root web application context are visible to each dispatcher servlet context, but not vice versa!!!
								
								https://www.baeldung.com/spring-web-contexts
								
								Enable Spring MVC
								@Configuration
								@EnableWebMvc
								@ComponentScan("spitter.web")
								public class WebConfig extends WebMvcConfigurerAdapter{
									
									@Bean
									public ViewResolver viewResolver() {
										InternalResourceViewResolver resolver = new InternalResourceViewResolver();
										resolver.setPrefix("/WEB-INF/views/");
										resolver.setSuffix(".jsp");
										resolver.setExposeContextBeansAsAttributes(true);
										return resolver;
									}
									
									@Override
									public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
										configurer.enable();
									}
									//This method is from WebMvcConfigurerAdapter
									//By calling enable() we ask the DispatcherServlet to forward request for static resources to the servlet container default servlet and not try to handle them it itself.
								
								}
								
								@Controller <- Stereotype annotation based on @Component annotation
								public class HomeController {
									@RequestMapping(value="/", method=GET)
									public String home() {
										return "home";
									}
								}
								
								Test MVC Controller 
								@Test
								public void testHomePage() throws Exception {
									HomeController controller = new HomeController();
									MockMvc mockMvc = standaloneSetup(controller).build();
									mockMvc.perform(get("/")).andExpect(view().name("home"));
								}
								
								@Controller
								@RequestMapping
								
								GET -> "/spittles?max=238900&count=50"
								@RequestMapping(value="/show",method=RequestMethod.GET)
								public String showSpittle(@RequestParam("max",defaultValue=...) ....
								
								Retrieve a page of a used ID , we could use query parameter stratagey , like this
								GET -> /spittles/show?spittle_id=12345 but this is not ideal for resource-orientation (REST services).
								Ideally,the resource being identified would be identified by the URL path and not by query parameters
								GET -> /spittles/12345 is better , it identifies a resource to be retrieved.
								
								@RequestMapping(value="/{spittleId}",method=RequestMethod.GET)
								public String spittle(@PathVariable("spittleId") long spittleId,Model model)
								
								SERVLET SPECIFICATION
									RequestDispatcher.forward -> Completely on Server side
									vs
									HttpServletResponse.sendRedirect()  -> Sent Back to client with HTTP Response 302 and a new URL in the Location header
									
								VALIDATION
									Use the Java Validation API , an implementation must be present in the classpath (like Hibernate Validator)
									@RequestMapping(value="/register", method=POST)
									public String processRegistration(@Valid Spitter spitter,Errors errors)
									
								Views
									Two interfaces
										public interface ViewResolver {
											View resolveViewName(String viewName, Locale locale) throws Exception;
										}

										public interface View {
											String getContentType();
											void render(Map<String, ?> model,HttpServletRequest request,HttpServletResponse response) throws Exception;
										}
										
								Exception handlers

									@ResponseStatus(value=HttpStatus.NOT_FOUND,reason="Spittle Not Found")
									public class SpittleNotFoundException extends RuntimeException
								
									@ExceptionHandler(*Exception.class)
									public String handle...()
									
									Advising Controllers
									@ControllerAdvice
									public class AppWideExceptionHandler{
									
										@ExceptionHandler(DuplicateSpittleException.class)
										public String duplicateSpittleHandler() {
										
									Sending data in REDIRECTS
										MODEL ATTRIBUTES ARE COPIED INTO THE REQUEST AS REQUEST ATTRIBUTES !!!
										
									Same Origin Policy
										Two URL have the same origin if PROTOCOL/PORT(If specified) AND HOST are the same
										
										<img> and <video> and <script> tags are NOT LIMITED by the Same Origin Policy !!!!
										
										Image Pings are used to pass some data to the server(Google Analytics use this technique)
										
									
									CORS(Cross Origin Resource Sharing)
									
									CSRF(Cross Site Request Forgery)
									
									
									SECURITY
										Spring employs several servlet filters to provide various aspects of security!!!!
										We only need to configure one filter that is the DelegatingFilterProxy and this filter will delegate to an implementation of javax.servlet.Filter that is
										registered as a <bean> in the Spring application context.
										We can register this filter through XML or Java
										With Java we use the following class
											public class SecurityWebInitializer extends AbstractSecurityWebApplicationInitializer {}
											THIS IMPLEMENTS THE WEBAPPLICATIONINITIALIZER, SO IT WILL BE DISCOVERY BY SPRING AND REGISTER THE DELEGATINGFILTERPROXY with the web container.
											Whether you configure DelegatingFilterProxy in web.xml or by subclassing AbstractSecurityWebApplicationInitializer, it will intercept requests coming
											into the application and delegate them to a bean whose ID is springSecurityFilterChain.
											The bean springSecurityFilterChain will be created when we enable the web security.
											
											@Configuration
											@EnableWebMvcSecurity
											public class SecurityConfig extends WebSecurityConfigurerAdapter {
											
												
												@Override
												protected void configure(AuthenticationManagerBuilder auth) throws Exception {
													//IN MEMORY DATABASE
													auth.inMemoryAuthentication().withUser("user").password("password").roles("USER").and().withUser("admin").password("password").roles("USER", "ADMIN");
													//RELATIONAL DATABASE
													//WE MUST ADHERE TO THE BASIC CONTRACT OF THE QUERIES
													//THE USERNAME MUST BE THE ONLY PARAMETER
													//THE AUTHENTICATION QUERY SELECTS THE USERNAME PASSWORD AND ENABLED STATUS FOR INSTANCE
													auth.jdbcAuthentication().dataSource(dataSource).usersByUsernameQuery(
														"select username, password, true from Spitter where username=?").authoritiesByUsernameQuery("select username, 'ROLE_USER' from Spitter where username=?");
													//CUSTOM USER SERVICE WE MUST IMPLEMENT USERDETAILSSERVICE
													public interface UserDetailsService {
														UserDetails loadUserByUsername(String username)throws UsernameNotFoundException;
													}
													//THEN USE IT LIKE THIS
													auth.userDetailsService(new SpitterUserService(spitterRepository));
													//INSTEAD OF USING ONE OF THE METHODS (inMemoryAuthentication or jdbcAuthentication or ldapAuthentication) use the userDetailsService
												}
												
												@Override
												protected void configure(HttpSecurity http) throws Exception {
													http.authorizeRequests().antMatchers("/spitters/me").authenticated().antMatchers(HttpMethod.POST, "/spittles").authenticated().anyRequest().permitAll();
													//USE SPEL WITH ACCESS
													//IT ALLOWS MORE THAN ONE DIMENSIONAL SECURITY METHOD
													//HTTPS
													.requiresChannel().antMatchers("/spitter/form").requiresSecure();
												}
												
											
											}
											
											SESSION TRACKING IN JAVA
												JSESSIONID is used to keep track of the request
													URL rewriting -> APPENDED TO THE URL
													Cookies       
													Hidden form fields
													HTTPS AND SSL
													
											ACCESS TO DATABASE
												JDBC -> DataAccessException is an unchecked exception !!!!
												Spring uses the Template Method Pattern
												
												Template Classes manage the fixed part of the process
												Callbacks are the custom data-access code
												
												Configuring DataSource
													JDBC Driver
														@Bean
														public DataSource dataSource() {
															DriverManagerDataSource ds = new DriverManagerDataSource();
															ds.setDriverClassName("org.h2.Driver");
															ds.setUrl("jdbc:h2:tcp://localhost/~/spitter");
															ds.setUsername("sa");
															ds.setPassword("");
															return ds;
														}
													JNDI
														@Bean
														public JndiObjectFactoryBean dataSource() {
															JndiObjectFactoryBean jndiObjectFB = new JndiObjectFactoryBean();
															jndiObjectFB.setJndiName("jdbc/SpittrDS");
															jndiObjectFB.setResourceRef(true);
															jndiObjectFB.setProxyInterface(javax.sql.DataSource.class);
															return jndiObjectFB;
														}
													Pool Connections
														https://www.baeldung.com/java-connection-pooling
														@Bean
														public BasicDataSource dataSource() {
															BasicDataSource ds = new BasicDataSource();
															ds.setDriverClassName("org.h2.Driver");
															ds.setUrl("jdbc:h2:tcp://localhost/~/spitter");
															ds.setUsername("sa");
															ds.setPassword("");
															ds.setInitialSize(5);
															ds.setMaxActive(10);
															return ds;
														}
														
												ORM JPA
													main interface is Session (save,update,delete and load objects)
													To get one Session we need SessionFactory interface.
													
													EXCEPTION TRANSLATION
													@Bean
													public BeanPostProcessor persistenceTranslation() {
														return new PersistenceExceptionTranslationPostProcessor();
													}
													
													Bean POSTPROCESSOR that adds an adviser to any bean that is annotated with @Repository
													
													Two kinds of entity managers
														Application Managed
														Container managed : The application does not interact with the entity manager factory at all.
														
														Spring abstracts the EntityManager creation on our behalf.
															LocalEntityManagerFactoryBean
																Application Managed entity manager factories derive most of their configuration information from persistence.xml
																(must appear in the META-INF directory in  the classpath)
																It configures  persistence units that is a grouping of one or more classes that correspond to a single data source.
																DO NOT FORGET THAT SPRING IS A CONTAINER !!!
															LocalContainerEntityManagerFactoryBean
																@Bean
																public LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource, JpaVendorAdapter jpaVendorAdapter) {
																	LocalContainerEntityManagerFactoryBean emfb = new LocalContainerEntityManagerFactoryBean();
																	emfb.setDataSource(dataSource);
																	emfb.setJpaVendorAdapter(jpaVendorAdapter);
																	emfb.setPackagesToScan("com.habuma.spittr.domain");
																	return emfb;
																}
																
																ENTITY MANAGER IS NOT THREAD SAFE !!!!
																
																
																@PersistenceContext
																private EntityManager em;
																The truth is that @PersistenceContext doesn’t inject an EntityManager—at least,not exactly. 
																Instead of giving the repository a real EntityManager, it gives a proxy to a real EntityManager. 
																That real EntityManager either is one associated with the current transaction or, if one doesn’t exist, creates a new one. 
																Thus, you know that you’re always working with an entity manager in a thread-safe way.
																It’s important to understand that @PersistenceUnit and @PersistenceContext aren’t Spring annotations!
																In order for Spring to understand them and inject we need a Spring PersistenceAnnotationBeanPostProcessor must be configured.
																@Transactional indicates that the persistence methods in this repository are involved in a transactional context.
																Without a template to handle exception translation, you need to annotate your repository with @Repository so PersistenceExceptionTranslationPostProcessor 
																knows that this is a bean for which exceptions should be translated into one of Spring’s unified data-access exceptions.
																
																CERTAIN DYNAMIC PERSISTENCE FEATURES REQUIRE THAT  THE CLASS OF PERSITENT OBJECTS BE MODIFIED WITH INTRUMENTATION TO SUPPORT THE FEATURE.
																OBJECTS WHOSE PROPERTIES ARE LAZY LOADED MUST HAVE THEIR CLASS INSTRUMENTED WITH CODE THAT KNOWS TO RETRIEVE UNLOADED DATA ON ACCESS.SOME 
																FRAMEWORKS USE DYNAMIC PROXIES TO IMPLEMENT LAZY LOADING.OTHERS PERFORM CLASS INSTRUMENTATION AT COMPILE TIME.
																
																TO AVOID THIS BOILERPLATE CODE 
																public void addSpitter(Spitter spitter) {
																	entityManager.persist(spitter);
																}
																
																WE CAN USE SPRING DATA JPA WE JUST HAVE TO WRITE THE INTERFACE LIKE THIS ONE
																public interface SpitterRepository extends JpaRepository<Spitter, Long> {
																}
																
																JpaRepository is parameterized such that it knows this is a repository for persisting Spitter objects and that Spitters have an ID of type Long.
																It also inherits 18 methods for performing common persistence operations.
																To ask Spring Data to create an implementation of SpitterRepository we need to add the annotation 
																
																@Configuration
																@EnableJpaRepositories(basePackages="com.habuma.spittr.db")
																public class JpaConfiguration {
																
																SpitterRepository interface, it extends JpaRepository.
																JpaRepository extends the marker Repository interface (albeit indirectly).
																Therefore, SpitterRepository transitively extends the Repository interface that repository-scanning is looking for.
																When Spring Data finds it, it creates an implementation of SpitterRepository, including an implementation of all 18 methods inherited
																from JpaRepository, PagingAndSortingRepository, and CrudRepository.
																
																We can add methods to the interface through a domain specific language where persistence details are expressed in interface methods signatures.
																For instance findByUsername
																Four verbs are allowed in this dsp (get,read,find and count)
																
																@Query
																
																Custom methods
																Spring also looks for a class whose name is the same as the interface's name postfixed with Impl.
																If the class exists,Spring Data Jpa merges its methods with those generated by Spring Data Jpa.
																
																public class SpitterRepositoryImpl implements SpitterSweeper {
																	@PersistenceContext
																	private EntityManager em;
																	
																	public int eliteSweep() {
																	 String update ="UPDATE Spitter spitter SET spitter.status = 'Elite' WHERE spitter.status = 'Newbie' " +
																	"AND spitter.id IN (SELECT s FROM Spitter s WHERE (" +
																	" SELECT COUNT(spittles) FROM s.spittles spittles) > 10000)";
																	return em.createQuery(update).executeUpdate();
																	}
																}
																
														CACHING
															@Configuration
															@EnableCaching
															
															Under the hood
																It creates an aspect with pointcuts that trigger off of Spring's caching annotations.
															
																
																@Bean
																public EhCacheCacheManager cacheManager(CacheManager cm) {
																	return new EhCacheCacheManager(cm);
																}
																
																@Bean
																public EhCacheManagerFactoryBean ehcache() {
																	EhCacheManagerFactoryBean ehCacheFactoryBean = new EhCacheManagerFactoryBean();
																	ehCacheFactoryBean.setConfigLocation(new ClassPathResource("com/habuma/spittr/cache/ehcache.xml"));
																	return ehCacheFactoryBean;
																}
																
																@Cacheable -> Method is only invoked if the value is not on the cache
																When you annotate the interface method, the @Cacheable annotation will be inherited by all implementations of SpittleRepository, 
																and the same caching rules will be applied.
																
																@CachePut -> Method is always invoked!!!
																Used on save methods for instance !!!!
																@CachePut(value="spittleCache", key="#result.id")
																Spittle save(Spittle spittle);
																
														METHODS SECURITY
														@Configuration
														@EnableGlobalMethodSecurity(securedEnabled=true)	
														public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
														}

														@Secured(Spring) and @RolesAllowed(JSR)
														Just takes into account the user's granted authorities
														
														@PreAuthorize -> evaluated before the method invocation
														@PostAuthorize -> evaluated after the method invocation
														@PostFilter
														@PreFilter
														
														ALL USE THE SPEL !!!!!
														
														@PreAuthorize("hasRole('ROLE_SPITTER')") equivalent to @Secure and @RolesAllowed
														
														PERMISSION EVALUATOR
															By default Spring is configured with a DefaultMethodSecurityExpressionHandler that is given an instance of DenyAllPermissionEvaluator,
															always return false from its hasPermission() methods.
															
															Customizing the GlobalMethodSecurityConfiguration !!!!
															
															@Override
															protected MethodSecurityExpressionHandler createExpressionHandler() {
																DefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler();
																expressionHandler.setPermissionEvaluator(new SpittlePermissionEvaluator());
																return expressionHandler;
															}
														
															Now anytime you secure a method with an expression that uses hasPermission(), the SpittlePermissionEvaluator will be invoked!!!
															
													RPC Models
														RMI -> Java Based Services (firewalls are not a factor)
														Hessian/Burlap -> Java Servives when firewall are a factor
														Http Invoker -> Spring based services when network constraints are a factor and we desire Java serialization over XML
														JAX-RPC /JAX-WS plataform neutral services ,SOAP-based
														
														
														VERY IMPORTANT:
															ANY FACTORY BEAN IN SPRING , THAT IS , ANY BEAN THAT IMPLEMENTS THE SPRING'S FACTORYBEAN INTERFACE) 
															THE BEAN THAT IS REGISTERED IN THE SPRING APPLICATION CONTEXT IS NOT AN INSTANCE OF *FACTORYBEAN BUT RATHER IS AN INSTANCE OF 
															THE CLASS RETURNED FROM THE FACTORY !!!!
															
															Client -> Proxy(Handle netweok communication) 
															
															Service Interface -> Remote Exporter(Handle Marshaling/Unmarshaling) -> Has a Service implementation bean
															
															In RMI usually the following steps are made :
																1 Create Service Implementation with methods that throw java.rmi.RemoteException
																2 Service Interface that extends java.rmi.Remote
																3 Run the RMI compiler (rmic) produce stub and server skeleton
																4 Start RMI registry
																5 Register the service
																
															Exposing	
															@Bean
															public RmiServiceExporter rmiExporter(SpitterService spitterService) {
																RmiServiceExporter rmiExporter = new RmiServiceExporter();
																rmiExporter.setService(spitterService);
																rmiExporter.setServiceName("SpitterService");
																rmiExporter.setServiceInterface(SpitterService.class);
																rmiExporter.setRegistryHost("rmi.spitter.com");
																rmiExporter.setRegistryPort(1199);
																return rmiExporter;
															}
															Consuming
															Using RMI to get a remote service
															String serviceUrl = "rmi:/spitter/SpitterService";
															SpitterService spitterService = (SpitterService) Naming.lookup(serviceUrl);
															
															this code is in direct opposition to the principles of dependency injection (DI). Because the client code is responsible for
															looking up the Spitter service and the service is an RMI service, there’s no opportunity to provide a different implementation of SpitterService from 
															some other source.
															@Bean
															public RmiProxyFactoryBean spitterService() {
																RmiProxyFactoryBean rmiProxy = new RmiProxyFactoryBean();
																rmiProxy.setServiceUrl("rmi://localhost/SpitterService");
																rmiProxy.setServiceInterface(SpitterService.class);
																return rmiProxy;
															}

															@Autowired
															SpitterService spitterService;

														Because RMI is java based both the client and service must be written in Java adn because RMI uses serialization, the types of the objects 
														being sent across the netweok must have the exact same version of the  Java runtime on both sides of the call.

														Hessian
															Use binary messages to communicate between client and service.The binary message is portable to languages other than Java(PHP,Python,C++ and C#)
														Burlap
															Use XML,the message structure is as simple as possible and does not require and external definition language such as WSDL or IDL.
															
															BOTH protocols work under HTTP so the Exporter is a Spring MVC controller!!!
															So we must configure the DispatchServelet
															@Bean
															public HessianServiceExporter
															hessianExportedSpitterService(SpitterService service) {
																HessianServiceExporter exporter = new HessianServiceExporter();
																exporter.setService(service);
																exporter.setServiceInterface(SpitterService.class);
																return exporter;
															}
															
															@Override
															protected String[] getServletMappings() {
																return new String[] { "/", "*.service" };
															}
															
															@Bean
															public HandlerMapping hessianMapping() {
																SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
																Properties mappings = new Properties();
																mappings.setProperty("/spitter.service","hessianExportedSpitterService");
																mapping.setMappings(mappings);
																return mapping;
															}
															
														Spring HTTPInvoker
															Performs remoting across HTTP (like Hessian and Burlap) and use Java serialization(like RMI)
															
															
														JAX-WS
															SimpleJaxWsServiceExporter requires thar JAX-WS runtime support publishing of endpoints to a specified address!!!
															If it does not support we will have to write our own JAX-WS endpoints in a more conventional way.This means the lifecycle of the endpoints
															will be managed by the JAX-WS runtime and not by Spring.
															If we extend SpringBeanAutowiringSupport we can annotate properties with @Autowire with an endpoint managed by the JAX-WS runtime.
															
															@WebService(serviceName="SpitterService")
															public class SpitterServiceEndpoint extends SpringBeanAutowiringSupport {

															@Autowired
															SpitterService spitterService;

															@WebMethod
															public void addSpittle(Spittle spittle) {
																spitterService.saveSpittle(spittle);
															}
															
														Unlike those other service exporters, SimpleJaxWsServiceExporter doesn’t need to be given a reference to the bean it’s supposed to export. 
														Instead, it publishes all beans that are annotated with JAX-WS annotations as JAX-WS services.
														
											REST
												Spring offer two options to transform a resource Java representation into the representation that's shipped to the client:
													Content negotiation
														When it comes to resolving view names into views that can produce resource representations, there’s an additional dimension to consider. 
														Not only does the view need to match the view name, but the view also needs to be chosen to suit the client.
														ContentNegotiatingViewResolver is a special view resolver that takes the content type that the client wants into consideration.
															First tries the URL's file extension.
															Second look in the Accept header field.
															Default to the configured content type.
															
														ContentNegotiatingViewResolver asks the other view resolvers to resolve the logical view name into a view.
														Every view that’s resolved is added to a list of candidate views. With the candidate view list assembled, ContentNegotiatingViewResolver
														cycles through all the requested media types, trying to find a view from among the candidate views that produces a matching content type.
														The first match found is the one that’s used to render the model.
														To configure the ContentNegotiatingViewResolver we use the ContentNegotiationManager, to configure it we have three options :
															Directly declare a bean whose type is ContentNegotiationManager.
															Create the bean indirectly via ContentNegotiationManagerFactoryBean
															Override the configurationContentNegotiation method of WebMvcConfigurer
															
															@Bean
															public ViewResolver cnViewResolver(ContentNegotiationManager cnm) {
																ContentNegotiatingViewResolver cnvr = new ContentNegotiatingViewResolver();
																cnvr.setContentNegotiationManager(cnm);
																return cnvr;
															}
															
															
															@Override
															public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
																configurer.defaultContentType(MediaType.TEXT_HTML);
															}
															
															@Bean
															public ViewResolver beanNameViewResolver() {                  <--Look up views as beans
																return new BeanNameViewResolver();
															}

															@Bean
															public View spittles() {
																return new MappingJackson2JsonView();     <- JSON views
															}
															
															In addition to what’s shown in listing 16.2, there would also be an HTML-capable view resolver (such as InternalResourceViewResolver)
														
													Message Conversion
														When using message conversion, DispatcherServlet doesn’t bother with ferrying model data to a view. 
														In fact, there is no model, and there is no view. There is only data produced by the controller and a resource representation produced when a 
														message converter transforms that data.
														If we employ message conversion, you need to tell Spring to skip the normal model/view flow and use a message converter instead.
														We can use @ResponseBody
														
														@RequestMapping(method=RequestMethod.GET,produces="application/json")
														public @ResponseBody List<Spittle> spittles

														For illustration’s sake, if the client’s Accept header specifies that the client will accept application/json, and if the Jackson JSON library is in the 
														application’s classpath, then either MappingJacksonHttpMessageConverter or MappingJackson2HttpMessageConverter will be chosen
														the @RequestBody tells Spring to find a message converter to convert a resource representation coming from a client into an object either.
														
														@RequestMapping(method=RequestMethod.POST,consumes="application/json")
														public @ResponseBody Spittle saveSpittle(@RequestBody Spittle spittle)
														
														If you’re writing a controller that has several methods, all of which should use message conversion, then those annotations get somewhat repetitive.
														@RestController
														
														JMS
															RPC over JMS !!!!Basically RPC asynchronous
																JMSMessageID
																JMSCorrelationID
															
														
														AMQP
															Defines a wire-protocol for messaging whereas JMS defines an API specification.
															JMS does not mandate that messages sent by one JMS implementation can be consumend by a different JMS implementation.
															AMQP specifies the format of the messages between the producer and the consumer.
															It is more interoperable (can be changed between systems that does not run Java)
															With JMS there is only two messaging models(point to point and publish/subscribe)
															AMQP enables to rpute in a number of ways and decouple the message producer and the queues (through Exchangers)
															
														WEBSOCKET
															Provide Bi Directional ,Full Duplex,low latency in one TCP socket connection.
															It is a protocol that operates as un upgraded HTTP connection exchanging variable length frames between the two parties instead of a stream.
															SockJS is a WebSocket emulator.
															STOMP(Asynchronous)
																Just as HTTP layers a request-response model on top of TCP sockets,STOMP layers a frame-based wire format to define messaging semanticson top 
																of WebSocket.
																STOMP uses a message broker !!!
																Spring
																	Instead of using @RequestMapping use @MessageMapping
																	@EnableWebSocketMessageBroker
																	extends AbstractWebSocketMessageBrokerConfigurer{
																	
																	@Override
																	public void registerStompEndpoints(StompEndpointRegistry registry) {
																		registry.addEndpoint("/marcopolo").withSockJS();
																	}
																	@Override
																	public void configureMessageBroker(MessageBrokerRegistry registry) {
																		registry.enableSimpleBroker("/queue", "/topic");
																		registry.setApplicationDestinationPrefixes("/app");
																	}
																	
																	
												SPRING BOOT
													Spring Boot Starters
														Aggregate common grouping of dependencies into single dependencies
													AutoConfiguration
														Leverage Spring support for conditional configuration to make reasonable guesses about the beans our application 
														needs and automatically configure them.
													CLI
													Actuator
													
													<?xml version="1.0" encoding="UTF-8"?>
													<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
													http://maven.apache.org/xsd/maven-4.0.0.xsd">
														<modelVersion>4.0.0</modelVersion>
														<groupId>com.habuma</groupId>
														<artifactId>contacts</artifactId>
														<version>0.1.0</version>
														<packaging>jar</packaging>
														<parent>
															<groupId>org.springframework.boot</groupId>
															<artifactId>spring-boot-starter-parent</artifactId>
															<version>1.1.4.RELEASE</version>
														</parent>
														<dependencies>
															<dependency>
																<groupId>org.springframework.boot</groupId>
																<artifactId>spring-boot-starter-web</artifactId>
															<dependency>
															<dependency>
																<groupId>org.thymeleaf</groupId>
																<artifactId>thymeleaf-spring4</artifactId>
															</dependency>
														</dependencies>
														<build>
															<plugins>
															<plugin>
															<groupId>org.springframework.boot</groupId>
															<artifactId>spring-boot-maven-plugin</artifactId>
															</plugin>
															</plugins>
														</build>
											</project>
												
	JPA
		PERSITENCE BOOTSTRAP-> PERSISTENCE UNIT -> ENTITY MANAGER FACTORY  -> ENTITY MANAGER -> PERSISTENCE CONTEXT(SET OF ALL ENTITIES INSTANCES MANAGED BY A SPECIFIC ENTITY MANAGER)
		
		IN Java SE we use the Persistence BootStrap.
		CHANGES TO ENTITIES MUST BE MADE PERSISTENT USING A TRANSACTION.
		NON MUTATING OPERATIONS LIKE FIND DO NOT NEED A A TRANSACTIONN.
		
		SO IF WE ARE RUNNING IN AN JAVA EE CONTAINER ENVIRONMENT THE JTA IS USED.The transaction model when running in the container is to assume the application will ensure that a transactional
		context is present when one is required.
		IN JAVA SE WE USE javax.persistence.EntityTransaction
		
		em.getTransaction().begin();
		createEmployee(158, "John Doe", 45000);
		em.getTransaction().commit();
		
		TRANSACTIONAL DEMARCATION
		
			Resource Local transaction are always demarcated EXPLICITLY by the application.
			Container transactions can either be demarcated automatically by the container or by using a JTA interface.
			CMT Container management transaction
			BMT Bean management transaction
			
			EJBs by default use CMT
			Servlets are limited to BMT
			
			@Stateless
			@TransactionManagement(TransactionManagementType.BEAN)   -----------> USED ONLY IN EJBs
			public class ProjectService
			
				Transaction attributes :
					MANDATORY
					REQUIRED     ------> DEFAULT
					REQUIRES_NEW
					SUPPORTS
					NOT_SUPPORTED
					NEVER
					
			With transactional interceptors it is possible to apply CMT to other components besides EJBs !!!!!
			@Transactional
			
			IMPORTANT : Transactions of BMT EJBs do not propagate to methods called on another BMT EJB!!!
			
			Each JTA is associated with an execution thread, with CMT the container can suspend the current transaction ,in this way , multiple transactions can be associated with a single thread 
			even though only one can ever be active.
			
			Two types of accessing Entity State
				Field
				Property
				Mixed
					@Entity
					@Access(AcessType.FIELD)
					public class Employee{
						...
						@Transient
						private String phoneNum;
						
						@Access(AcessType.PROPERTY)
						@Column(name="PHONE")
						protected String getPhoneNumberForDb(){...}
					}
					
				
				TABLE
				
				@TableGenerator(name="Emp_Gen",table="ID_GEN",pkColumnName="GEN_NAME",valueColumnName="GEN_VAL")
				@Id
				@GeneratedValue(generator="Emp_Gen")
				private long id;
				
				SEQUENCE
				
				@SequenceGenerator(name="Emp_Gen", sequenceName="Emp_Seq")
				@Id @GeneratedValue(generator="Emp_Gen")
				private long getId;
				
				DATABASE IDENTITY  -> CAN NOT ALLOCATE BLOCKS IN ADVANCE AND THE IDENTIFIER IS NOT AVAILABLE UNTIL AFTER COMMIT TIME.
				
				RELATIONSHIPS
					Single Value Association(Many To One / One To One)
					THE SIDE THAT OWNS THE JOIN COLUMN(FOREIGN KEY) IS CALLED THE OWNING SIDE!!!!
					The physical annotations that define the mappings to the columns in the database are always defined on the owning side of the relationship.
					
					@ManyToOne
					@JoinColumn(name="")
					
					@OneToOne(mappedBy="parkingSpace")
					mappedBy indicates the INVERSE SIDE of the relationship.
					THE VALUE OF THE MAPPEDBY IS THE NAME OF THE ATTRIBUTE IN THE OWNING ENTITY THAT POINTS BACK TO THE INVERSE ENTITY!!!!
					
					Collection-Value Associations
						A bidirectional one to many relationship always implies a many to one mapping back to the source
						IN THE BIDIRECTIONAL ONE-TO-MANY RELATIONSHIPS
							THE MANY TO ONE SIDE SHOULD BE THE OWNING SIDE,SO THE JOINCOLUMN SHOULD BE DEFINED ON THAT SIDE
							THE ONE TO MANY MAPPINGS SHOULD BE THE INVERSE SIDE,SO THE MAPPEDBY ELEMENT SHOULD BE USED
							Failing to specify the mappedBy element in the @OneToMany annotation will cause the provider to treat it as a unidirectional one-to-many relationship that is defined to use a join table.
							
					@ManyToMany
					@JoinTable(name="EMP_PROJ",@JoinColumns(name="EMP_ID"),inverseJoinColumn(name="PROJ_ID"))
					private Collection<Project> projects;
					
					UNIDIRECTIONAL COLLECTION MAPPING
						When an entity has a one to many mapping to a target entity,but the @OneToMany annotation does not include the "mappedBy" element,it is assumed to be in a unidirectional relationship.
						A Join table is needed!!!!
						
						
						@OneToMany
						@JoinTable(name="EMP_PHONE",joinColumns=@JoinColumn(name="EMP_ID"),
						inverseJoinColumns=@JoinColumn(name="PHONE_ID"))
						private Collection<Phone> phones;
						
						
					@Embeddable
					@Access(AccessType.FIELD)
					public class Address

					@Embedded
					@AttributeOverrides({
						@AttributeOverride(name="state", column=@Column(name="PROVINCE")),
						@AttributeOverride(name="zip", column=@Column(name="POSTAL_CODE"))
					})
					private Address address;

					ELEMENT COLLECTIONS
					
					@ElementCollection(targetClass=VacationEntry.class)
					@CollectionTable(name="VACATION", joinColumns=@JoinColumn(name="EMP_ID"))
					@AttributeOverride(name="daysTaken", column=@Column(name="DAYS_ABS"))
					private Collection vacationBookings;
					@ElementCollection
					private Set<String> nickNames;
					
					If there is a collection of embeddables how would it be possible to store a multiplicity of like-mapped objects in a single row
					
					
					MAP
					@ElementCollection
					@CollectionTable(name="EMP_PHONE")
					@MapKeyColumn(name="PHONE_TYPE")   -> Indicate the column in the collection table that stores the basic key!!!
					private Map<String,String> phoneNumbers;
					
					In the relational model
						EMPLOYEE       EMP_PHONE
						PK ID          PK FK1 EMPLOYEE_ID
						   NAME        PK     PHONE_TYPE
						   SALARY             PHONE_NUM
					
					
					Instead of String use the Enumerated , not the Enumerated ordinal value but the String value.
					In a Collection we will use the @Enumerated to override the values but in a Map we want to override the key so we use
					@MapKeyEnumerated
					
					@ElementCollection
					@CollectionTable(name="EMP_PHONE")
					@MapKeyEnumerated(EnumType.STRING)
					@MapKeyColumn(name="PHONE_TYPE")
					@Column(name="PHONE_NUM")
					private Map<PhoneType, String> phoneNumbers;
					
					
					@OneToMany(mappedBy="department")
					@MapKey(name="id")   -------------------> Designate the attribute of the TARGET entity that is being keyed on.
					private Map<Integer, Employee> employees;
					
					@ElementCollection
					@CollectionTable(name="EMP_SENIORITY")
					@MapKeyJoincolumn(name="EMP_SENIORITY") -----> Instead of @MapKey , to differentiate join columns that point to map keys from the ones used in relationship this annotation was created.
					@Column(name="SENIORITY")
					private Map<Employee,Integer> seniorities;
					
					RULES TO MAPS !!!
						use @MapKey with one-to-many or many-to-many relationship Map thta is keyed on an attribute of the target entity
						use @MapKeyJoinColumn to override the join column of the entity key
						use @MapKeyColumn to override the column storing the keys when keyed by basic type
						
					CORE
						IF THE PERSISTENCE CONTEXT PARTICIPATES IN A TRANSACTION,THE IN-MEMORY STATE OF THE MANAGED ENTITIES WILL GET SYNCHRONIZED TO THE DATABASE.
						
						CONTAINER-MANAGED ENTITY MANAGERS
							TRANSACTION SCOPED : scoped by the JTA transaction , ending when the transaction is complete
							EXTENDED : single persistence context tied to the lifecycle of stateful session bean
							
							If transaction scoped entity manager is state how can it work with Persistence Context ? THROUGH JTA transaction !!!
							
						APPLICATION MANAGED ENTITY MANAGERS
							In terms of persistence context,the application managed entity manager is SIMILAR to an EXTENDED container managed entity manager. <-<-<-<-<-<-<-!!!!!
							IN JAVA EE IF RESOURCE LOCAL TRANSACTIONS ARE REQUIRED FOR AN OPERATION,AN APPLICATION MANAGED ENTITY MANAGER IS THE ONLY TYPE OF ENTITY MANAGER THAT CAN BE CONFIGURED WITH THAT
							TRANSACTION TYPE WITHIN THE SERVER!!!
							
						UNDERSTAND HOW PERSISTENCE CONTEXTS INTERACT WITH TRANSACTIONS IS A FUNDAMENTAL PART OF WORKING WITH JPA.
						There are TWO TYPES of transaction management supported by JPA :
							Resource-local transaction(native transactions of the JDBC drivers)
							JTA transactions (transactions of the Java EE server,supporting multiple participating resources,distributed XA transactions and transaction lifecycle management).
								Container Managed entity managers always use JTA.
								Application managed entity managers can use either type.
								
								JTA
									Transaction synchronization -> Process by which a persistence context is registered with a transaction so that the persistence context can be notified when a transaction commits.
									Transaction association -> Binding a persistence context to a transaction.
									Transaction propagation -> Sharing a persistence context between multiple container-managed entity managers in a single transaction.
									
									
									Because transaction scope entity manager will use an existing persistence context associated with a transaction before it will create a new persistence context,it is possible 
									to share an extended persistence context with other transaction scope entity managers.AS LONG AS THE EXTENDED PERSISTENCE CONTEXT IS PROPAGATED BEOFRE ANY TRANSACTION SCOPED
									ENTITY MANAGERS ARE ACCESSED.
									TWO EXTENDED PERSISTENCE CAN BE SYNCHRONIZED WITH EACH OTHER!!!
									ONE TRANSACTION SCOPE CAN NOT BE SINCHRONIZED WITH A EXTENDED!!!
									
									THERE IS NO LIMIT TO THE NUMBER OF APPLICATION MANAGED PERSISTENCE CONTEXTS THAT CAN BE SYNCHRONIZED WITH A TRANSACTION!!!
									BUT ONLY ONE CONTAINER MANAGED PERSISTENCE CONTEXT WILL EVER BE ASSOCIATED!!!
									
							CASCADES
							
								SPECIAL CASES!!!!
									The FLUSH operation is related with a very deep degree of relation with CASCADING.
									We iterate through all linked relationships and could call PERSISTE on the objects to become managed!!!
									If we stumble in a detached object during the iteration and this object is the TARGET of the one-to-one or many-to-one relationship 
									where the source entity is the owner , the FLUSH will still proceed because the act of persisting the owning entity does not depend on the target!!!!
									The owning entity has the foreign key column and needs to store only the primary key value of the target entity!!!
									
								MERGE	
									WE GENERALLY CASCADE OPEARATIONS ONLY DOWN FROM PARENT TO CHILD,NOT UPWARD FROM CGILD TO PARENT.


								PLANNING FOR DETACHMENT
									Triggering Lazy Loading
										List<Employee> emps = (List<Employee>)em.createQuery("SELECT e FROM Employee e").getResultList();
										for (Employee emp : emps) {
											Department dept = emp.getDepartment();
											if (dept != null) {
												dept.getName();
											}
											
									EAGER LOADING
									PROJECTION QUERIES
									KEEPING PERSISTENCE CONTEXT OPEN THROUGH APPLICATION MANAGER OR EXTENDED PERSISTENCE CONTEXT OR LEAVES A TRANSACTION OPEN THROUGH FOR INSTANCE
									THE TRANSACTIO VIEW PATTERN !!!!
										WE USE BEAN_MANAGED TRANSACTION
											@Resource UserTransaction tx;
											...
											tx.begin();
											List emps = bean.findAll();
											request.setAttribute("employees", emps);
											...
											finally{
												tx.commit();
												Complex to implements in the Front Controller pattern
												It could be implemented in Filters but be carefull with updates in session beans ,they should have REQUIRES_NEW transaction attribute!!!
									
										https://vladmihalcea.com/a-beginners-guide-to-jpa-hibernate-entity-state-transitions/
										https://vladmihalcea.com/jpa-persist-and-merge/
												
									SESSION FAÇADE
									EDIT SESSION THROUGH STATEFUL EXTENDED PERSISTENCE CONTEXT
									
							QUERIES
								JP QL
								NATIVE SQL
								CRITERIA API 								
								
									The result type of a select query CANNOT BE A COLLECTION,IT MUST BE A SINGLE VALUED OBJECT!!!
									JOIN
										SELECT p.number
										FROM Employee e, Phone p
										WHERE e = p.employee  AND e.department.name = " 'NA44'
										
										SELECT p.number
										FROM Employee e JOIN e.phones p
										WHERE e.department = 'NA44'
										
										Query and TypedQuery
											Three approaches to define JP QL query
												Dynamically specified (Through a String concatenation)
													The query engine will have to parse the JP QL string into a syntax tree,get the object-relational mapping metadata for each entity in each expression and then 
													generate the equivalent SQL.
													MANY QUERY ENGINES WILL CACHE THE TRANSLATED SQL FOR LATER USE, BUT THIS CAN EASILY BE DEFEATED IF THE APPLICATION DOES NOT USE PARAMETER 
													BINDING AND CONCATENATES PARAMETER VALUES DIRECTLY INTO QUERY STRINGS!!!
												Configured in persistence unit metadata(annotation or XML)
													@NamedQuery(name="zxczxcz",query="zsdasdasd")
													Dynamicy Named QUERY
														private static final String QUERY = "SELECT ....";
														TypeQuery<Long> q = em.createQuery(QUERY,Long.class);
														emf.addNamedQuery("findSalaryForNameAndDepartment",q);
														
												Dynamic specified and saved to be later referenced by name
												
												Query and TypedQuery objects may be reused as often as needed so long as the same persistence context that was used to create the query is still active.
												
												OPTIMIZING READ ONLY QUERIES
													When the query result will not be modified, queries using transaction scoped entity managers outside of a transaction can be more efficient than queries execured within
													a transaction when the result type is an ENTITY!!!!
													When query results are prepared within a transaction, the persistence provider has to take steps to convert the results into managed entities. 
													This usually entails taking a snapshot of the data for each entity in order to have a baseline to compare against when the transaction is committed. 
													If the managed entities are never modified, the effort of converting the results into managed entities is wasted.
													Note that this technique does not work on application-managed or extended entity managers because their persistence context outlives the transaction.
													
											SPECIAL RESULT TYPES
												Whenever a query involves more than one expression in the SELECT clause, the result of the query will be a List of Object arrays.
													For instance "SELECT e.name, e.department.name " +
												Instead of doing this 
													for (Iterator i = result.iterator(); i.hasNext();) {
													Object[] values = (Object[]) i.next();
												We can use Constructor expressions to provide developers with a way to map an array of Object result types to custom objects.	
												The only requirement for this class is that it has a constructor with arguments matching the exact type and order that will be specified in the query.
												createQuery("SELECT NEW example.EmpMenu("e.name, e.department.name) " +
												
											IMPORTANT
												Queries and uncommitted changes.
												Executing queries against entities that have been created or changed in a transaction is a topic that requires special consideration.
												ALL ENTITY OPERATIONS OTHER THAN QUERIES CAN BE SATISFIED WITHOUT FLUSHING THE PERSISTENCE CONTEXT TO THE DATABASE.
												Queries are a special case because they are executed directly as SQL against the database. Because the database executes the query 
												and not the persistence provider, the active persistence context cannot usually be consulted by the query.
												As a result, if the persistence context has not been flushed and the database query would be impacted by the changes pending in the persistence context, 
												incorrect data is likely to be retrieved from the query.
												To offer more control over the integrity requirements of queries, the EntityManager and Query interfaces support a setFlushMode() method to set the flush mode.
												AUTO and COMMIT.
												
												BULK UPDATE AND DELETE
													JP QL UPDATE AND DELETE statements are designed to make changes to large numbers of entities in a single operation without requiring the individual
													entities to be retrieved and modified using the entity manager.
													Persistence Context is not updated to reflect the results of the operation.
													The developer can rely only on entities retrieved after the bulk operation completes.
													
														A new transaction starts
														Entity A is created by calling persist() to make the entity managed
														Entity B is retrieved from a find() operation and modified
														A bulk remove deleted entity A
														A bulk update changes the same properties on entity B that were modified in Step 3
														The transaction commits.
														
													DELETE statements do not cascade to related entities even if the REMOVE cascade option is set on a relationship!!!
													The alternative to JP QL DELETE statementes is to retrieve the entities and call remove in each one!!!
													
													Query best practices
														NAMED QUERIES
														PROJECTION
														QUERIES TO RUN OUTSIDE OF A TRANSACTION
														BULK OPEARATIONS RUNNING IN AN ISOLATED TRANSACTION
														FLUSH MODE
														
													QUERIES
														FECTH -> Allows queries to specify relationships that should be prefetched to avoid the lazy loading detachment problem.
														
														select e
														from Employee e JOIN FECTH e.address
														
														The engine transforms to the following :
														
														select e,a
														from Employee e JOIN FECTH e.address a
														
														Creates the Address in memory and assign it to the Employee entity and then it drops it from the result collection!!!
														A consequence is that fecthing a colllection association results in duplicate results :
														
														select d
														from Department d LEFT JOIN FETCH d.employees (collection association)
														
														engine transforms to this 
														
														select d,e
														from Department d LEFT JOIN FECTH d.employees e
														
														The employees are dropped from the result and the Department instances become duplicated!!!
														
														MEMBER OF
														IS EMPTY -> To collections
														IS NULL
														EXISTS -> subqueries
														ALL,ANY,SOME
														
													POLYMORPHISM
														Subclass discrimination
															Select p
															From Project p
															Where TYPE(p) = DesignProject OR TYPE(p) = QualityProject
															
														Downcasting
															TREAT in WHERE and FROM
															
													Scalar Expressions Literals Temporal
														{d 'yyyy-mm-dd'}
														{t 'hh-mm-ss'}
														{ts 'yyyy-mm-dd hh-mm-ss.f'}
														
													METAMODEL API
														metamodel of a persistence unit is a description of the persistent type, state, and relationships of entities, embeddables, and managed classes.
														The Metamodel interface can be used to list the persistent classes in a persistence unit or to retrieve information about a specific persistent type.
														
													Criteria API
														String Api vs Strongly Typed API (CANONICAL METAMODEL)
														
													CONVERTERS
														implements the AttributeConverter<X,Y>
															public Y convertToDatabaseColumn(X attribute);
															public X convertToEntityAttribute(X dbData);
															
															
															@Converter
															public class BooleanToIntegerConverter implements AttributeConverter<Boolean,Integer> {
																public Integer convertToDatabaseColumn (Boolean attrib) {
																	return (attrib ? 1 : 0);
																}
																
																public Boolean convertToEntityAttribute (Integer dbData) {
																	return (dbData > 0)
																}
															}
															
													@Convert(converter=BooleanToIntegerConverter.class)
													private Boolean bonded;
													
													Compound Primary Keys
														ID Class
														
															@Entity
															@IdClass(EmployeeId.class)
															public class Employee{
															@Id
															private String country;
															@Id
															@Column(name="EMP_ID")
															private int id;
															
															public class EmployeeId implements Serializable {
																private String country; --->
																private int id;         ---> MUST EXISTS IN THE ENTITY
																
																public EmployeeId() {}
																
																public EmployeeId(String country, int id) {
																	this.country = country;
																	this.id = id;
																}
																
																public String getCountry() { return country; }
																
																public int getId() { return id; }
																
																public boolean equals(Object o) {
																	return ((o instanceof EmployeeId) & country.equals(((EmployeeId)o).getCountry()) && id == ((EmployeeId)o).getId());
																}
																
																public int hashCode() {
																	return country.hashCode() + id;
																}
															}
															
															equals and hasCode must be implemented !!!!
															
														Embedded ID Class
															@Embeddable
															public class EmployeeId{
																private String country;
																@Column(name="EMP_ID")
																private int id;
																
																public EmployeeId(){}
																public EmployeeId(String country,int id){...}
																...
															}
															
															@Entity
															public class Employee{
																@EmbeddedId
																private EmployeeId id;
																
																....
																
													Derived Identifiers
														One to One relationship between Employee and EmployeeHistory
														
														The EmployeeHistory shares the primary key with Employee
														
														public class EmployeeHistory{
															@Id
															@OneToOne
															@JoinColumn(name="EMP_ID")
															private Employee employee;
															....
															
															If Employee has a compound primary key, either with an ID class or an embedded ID class, then EmployeeHistory is going to share the same ID class 
															(and should also be annotated with the @IdClass annotation).
															THE PROBLEM IS THAT THIS TRIPS OVER THE ID CLASS RULE THAT THERE SHOULD BE A MATCHING ATTRIBUTE IN THE ENTITY FOR EACH ATTRIBUTE IN ITS ID CLASS. 
															THIS IS THE EXCEPTION TO THE RULE, BECAUSE OF THE VERY FACT THAT THE ID CLASS IS SHARED BETWEEN BOTH PARENT AND DEPENDENT ENTITIES.
															
															@Entity
															@IdClass(ProjectId.class)
															public class Project {
																@Id 
																private String name;
																@Id
																@ManyToOne
																@JoinColumns({
																@JoinColumn(name="DEPT_NUM",referencedColumnName="NUM"),
																@JoinColumn(name="DEPT_CTY",referencedColumnName="COUNTRY")})
																private Department dept;
																// ...
															}

															public class ProjectId implements Serializable {
																private String name;
																private DeptId dept;
																
																public ProjectId() {}
																public ProjectId(DeptId deptId, String name) {
																	this.dept = deptId;
																	this.name = name;
																}
																// ...
															}

															public class DeptId implements Serializable {
															private int number;
															private String country;
															public DeptId() {}
															public DeptId (int number, String country) {
																this.number = number;
																this.country = country;
															}
															// ...
															}
															
															Unidirectional relationship without using a JOIN TABLE
															we first indicate that the one-to-many relationship is unidirectional by not specifying any mappedBy element in the annotation. 
															Then we specify a @JoinColumn annotation on the one-to-many attribute to indicate the foreign key column. 
															The catch is that the join column that we are specifying applies to the table of the target object, not to the source object in which the annotation appears.
															
															ORPHAN REMOVAL
																Parent-Child relationships
																
															Relationship State
																The relational table starts to have an entity
																The owning and target entities start to have one relationship oneToMany to the relational entity 
																And the relational entity has ManyToOne
																
															@SecondaryTables
															
															
														MAPPED SUPERCLASSES
															Entities can inherit from them but itseld is not a PERSISTENCE CLASS.It cannot be queried over and cannot be the target of a relatioship.
															Usually they are Java abstract classes.
															
														Transient Classes
															Classes in an entity hierarchy,that are not entities ir mapped superclasses,are called transient classes.
															Entities may extend transient classes either directly or indirectly through a mapped superclass.When an entity inherits from a transient class,the state
															defined in the transient class is still inherited in the entity,but it is not persistent.
															
														Inheritance
															Single Table Strategy
															    @Inheritance(strategy=InheritanceType.SINGLE_TABLE)
																@DescriminatorColumn(name="EMP_TYPE")
																@DescriminatorValue("xxxx")
																
															Joined Strategy
															Table per concrete class
															
														NATIVE SQL
															Native SQL queries that return ENTITIES will become MANAGED like the results of a JP QL query!!!
															IT IS IMPORTANT TO ENSURE THAT ALL THE NECESSARY DATA REQUIRED TO FULLY CONSTRUCT THE ENTITY IS PATY OF THE QUERY.
															IF WE LEAVE OUT A FIELD FROM THE QUERY THERE IS A POSSIBILITY THAT WE WILL OVERWRITE THE CORRECT VERSION ALREADY STORED IN THE DATABASE.
															
														@NamedNativeQuery(name="orgStructureReportingTo",
																		 query="SELECT emp_id, name, salary, manager_id, dept_id, address_id FROM emp START WITH manager_id = ? CONNECT BY PRIOR emp_id = manager_id",
																		 resultClass=Employee.class)	
															
														@SqlResultSetMapping(name="EmployeeResult",entities=@EntityResult(entityClass=Employee.class))	
														
														MAPPING COLUMN ALIASES
															@FieldResult
															
														ENITY GRAPHS
															Entity Graphs is not really a graph of entities ,but rather a template for specifying entity and embeddable attributes.It serves as a pattern that can
															be passed into a find method or query to specify which entity and embedddable  attributes should be fecthed in the query result.
															In more concrete terms, entity graphs are used to override at runtime the fetch settings of attribute mappings. 
															For example, if an attribute is mapped to be eagerly fetched (set to FetchType.EAGER), it can set to be lazily fetched for a single execution of a query.
															EVERY ENTITY AND EMBEDDABLE CLASS HAS A DEFAULT FECTH GRAPH!!!!
															When a relationship attribute is listed in the graph but does not have any accompanying subgraph,then the default fetch group of the related class
															will be assumed!!!
															
															FETCH GRAPH
															LOAD GRAPH
															
														LIFECYCLE CALLBACKS
															PrePersist
															PostPersist
															PreUpdate
															PostLoad ...
															
														Entity Listeners
															@Entity
															@EntityListeners({EmployeeDebugListener.class, NameValidator.class})
															public class Employee implements NamedEntity
															
															DEFAULT ENTITY LISTENERS MUST BE DECLARED IN XML!!
															@ExcludeDefaultListeners use this annotaion if we want not to use the default listeners on a specific entity.
															
															Inheriting callback methods
																Rule : Every callback method will be invoked in the order according to its place in the hierarchy,most general classes first!!!
																
														VALIDATION
															JSR 303
																@Null
																
																Validation Groups
																
																New Constraints
																@Constraint(validatedBy={EvenNumberValidator.class})
																@Target({METHOD, FIELD})
																@Retention(RUNTIME)
																public @interface Even {
																	String message() default "Number must be even";
																	Class<?>[] groups() default {};
																	Class<? extends Payload>[] payload() default {};
																	boolean includeZero() default true;
																}
																
															Validation in JPA
																When validating JPA entities there is a specific integration required with the JPA Provider.
																
														REFRESH ENTITY STATE
															The refresh() method can be useful in situations when we know that there are changes in the database that we do not have in our managed entity!!!
															The refresh operation applies only when an entity is managed because when we are detached we typically only need to issue a query to get an updated version
															of the entity from the database.
															Refreshing is especially relevant when using an extended or application-managed persistence context because it prolongs the interval of time that an entity is
															effectively cached in the persistence context in isolation from the database.
															
														LOCKING
															JPA by default use OPTIMISTIC LOCKING
															How the provider knows that a entity was changed in the intervening time since the committing transaction ?
															Through VERSIONING
																The entity must have a dedicated persistent field or property declared in it to store the version number of the entity that was obtained in the
																transaction.
																
														CACHING

				JAVASCRIPT
					Use <script> after the page content <body> this way the page is completely rendered in the browser before the javascript code os processed.
					Or we can use the defer attribute
					Async attribute will execute before the page load event and may execute before or after DOMContentLoaded.
					Defining a variable using VAR makes it local to the scope in which it was defined.By removing the var operator the variable becomes GLOBAL!!!
					Five primitive types
						undefined , null , boolean , number , string
					On Complex
						Object which is an unordered list of name-value pairs.
						typeof OPERATOR(not a function)
						typeOf null returns Object because null is considered to be an empty object reference!!!!
					ALL TYPES OF VALUES HAS BOOLEAN EQUIVALENTS
					NAN SPECIAL NUMERIC VALUE WHICH IS USED TO INDICATE WHEN AN OPERATION INTENDED TO RETURN A NUMBER HAS FAILED !!!
					ANY OPERATION INVOLVING NAN ALWAYS RETURNS NAN!!!
					NUMBER("12312lkl")  -> NAN
					NUMBER("") -> 0
					parseInt("12312lkl") -> 123121
					parseInt(22.5) -> 22
					parseInt("0xA") -> 10 converts from Hexadecimal
					
					Object type
						Each object instance has the following properties and methods:
							constructor    -> Function that was used to create the object.
							hasOwnProperty
							isPrototypeOf
							propertyIsEnumerable
							toString
							valueOf
							toLocaleString
							
							OBJECT IS THE BASE FOR ALL OBJECTS IN ECAMSCRIPT!!!
							
						BITWISE OPERATORS
							ALL NUMBERS IN ECMASCRIPT ARE STORED IN IEEE-754 64 BIT FORMAT BUT THESE OPERATORS DO NOT WORK DIRECTLY ON THE 64 BIT REPRESENTATION INSTEAD THE VALUE IS CONVERTED INTO
							A 32 BIT INTEGER THE OPERATION TAKES PLACE AND THE RESULT IS CONVERTED BACK INTO 64 BITS.
							
						for-in statement
							Used to enumerate the properties of an object.
							
						Function arguments
							arguments are represented as an array internally, the array is always passed to the function,but the function does not care what is in the array.
							arguments values always stays in sync with the values of the corresponding named parameters!!!
							Changig the named parameter does not change the corresponding value in arguments !!!
							If only one argument is passed in,then setting arguments[1] to a value will not be reflected by the named parameter!!!!
							
						instanceof operator used to identify the type of object!!!!
						
						Execution Context has an associated VARIABLE OBJECT upon which all of its defined variables and functions exist!!!
						Each execution context has a Scope Chain!!!!
						IN JAVASCRRIPT THERE IS ONLY GLOBAL AND FUNCTION CONTEXT NOT BLOCK LEVEL SCOPE!!!
						VARIABLE DECLARED WITHOUT USING THE VAR KEYWORD ARE ATTACHED TO THE GLOBAL CONTEXT!!!
					
						OBJECTS ARE CONSIDERED TO BE INSTANCES OF A PARTICULAR REFERENCE TYPE.
						
						new or literal notation !!!
						We can access object properties through the "."(dot) notation or bracket notation.
						
						Detecting arrays
							Problem : different frames in a web page (different global execution contexts) and therefore two versions of the Array constructor!!!
							Solution Array.isArray()
							
						Date -> Stores dates as the number of miliseconds that have passed since midnight on january 1 1970 UTC.
						To create dates based on another date or time we MUST pass in the millisecond representation of the date.To aid in this process,ECMASCript provides two methods
							Date.parse() and Date.UTC()
							
							Under the hood the constructor used one of the two methods above.
							
							The valueOf method returns the milliseconds representation.
							
						Each function is an instance of the Function type that has properties and methods.
						Function names are simply pointers to function objects!!!!!
						
						function  sum(num1,num2){
							return num1 + num2;
						}
						
						var sum = function(num1,num2){
							return num1+num2;
						}
							
						var sum = new Function("num1","num2","return num1 + num2");
						
						FUNCTION EXPRESSIONS DO NOT LEVERAGE THE FUNCTION DECLARATION HOISTING!!!
						
						Two special objects exist inside a function:arguments and this
						
						arguments.callee points to the function who owns the arguments array!!!
						
						this it is a reference to the context object that the function is operating on!!!
						The value of this is not determined until the function is called !!!!
						Other property of the function type is "caller" that points to the function caller.
						Length returns the number of named parameters!!
						
						prototype -> Actual location of all instances methods for references types,meaning methods such as toString and valueOf actually exist on the prototype and then are accessed from the
						object instances!!!
						
						apply,call and bind -> Change the context in which the function is executed.
						
						window.color = "red";
						var o = {color : "blue"};
						function sayColor(){
							console.log(this.color);
						}
						var objectSayColor = sayColor.bind(o);
						sayColor();-> Red
						sayColor.call(o);-> Blue
						objectSayColor();-> Blue
						
						eval method is perhaps the most powerful in ECMAScript language,it works like an entire ECMAScript interpreter.
						Code executed by eval is considered to be part of the execution context in which the call is made.So has the same scope chain as that context.
						Variable and functions created inside of eval() will not be hoisted!!!!
						
						Characteristics of properties through the use of internal only attributes
							Data properties [[Configurable]]
											[[Enumerable]]
											[[Writable]]
											[[Value]]
											
											Object.defineProperty(person,"name",{writable:false,value:"Nicholas"});
							Accessor properties
											[[Configurable]]
											[[Enumerable]]
											[[Get]]
											[[Set]]
											
											var book = {
												_year : 2004,
												edition : 1};
												
											Object.defineProperty(book,"year",{
												get : function(){
													return this._year;
												},
												set : function(newValue){
													if(newValue > 2004){
														this._year = newValue;
														this.edition += newValue - 2004;
													}
												}
											});	
											
											
							Object Creation
								Factory Pattern
											function createPerson(name,age,job){
												var o= new Object();
												o.name = name;
												o.age = age;
												o.job = job;
												o.sayName = function(){
													alert(this.name);
												};
												return o;
											}
											
											PROBLEM : OBJECT IDENTIFICATION
											
								Constructor Pattern
											function Person(name,age,job){
												this.name = name;
												this.age= age;
												this.job = job;
												this.sayName = function(){
													alert(this.name);
												}	
											}
											
								Prototype Pattern
									Each function is created with a prototype property,which is an object containing properties and methods that should be available to instances of a particular reference type.
									
									             ---------------------------------------------|
												\/											  |	
									Person(Function)  _prototype --------> Person Prototype   |
																|			constructor ------|
																|						  |
						                                        |                         |
								   person1(instance)[[prototype]]                    person2(instance)[[prototype]]
								   
								   Object.getPrototypeOf
								   .isPrototypeOf
								   .hasOwnProperty
								   Object.keys()
								   Object.getOwnPropertyNames
										
										function Person(){};
										
										Person.prototype.name
										Person.prototype.age
										Person.prototype.job
										Person.prototype.sayName
										
								Combination Contructor/Prototype Pattern
									function Person(name, age, job){										
									//methods
										if (typeof this.sayName != "function"){
											Person.prototype.sayName = function(){
											
								Parasitic Constructor Pattern
									function SpecialArray(){
										var array = new Array();
										array.push.apply(array,arguments);
										array.toPipedString = function(){...}
										return array;
									}
								Durable Constructor
									No public properties
									Methods do reference the this object.
									
									function Person(name,age,job){
										var o = new Object();
										//optional : define private variables/functions here 
										
										o.sayName() = function(){
											alert(name);
										}
										
										return o;
									}
									
								Prototype Chaining
									Constructor Stealing
									Combination Inheritance
										function SuperType(name){
											this.name = name;
											this.colors = ["red","blue","green"];
										}
										
										SuperType.prototype.sayName = function(){
											alert(this.name);
										}
										
										function SubType(name,age){
											SuperType.call(this,name);
											this.age = age;
										}
										
										SubType.prototype = new SyperType();
										SubType.prototype.sayAge() = function(){
											alert(this.age);
										}	
										
									Prototypal Inheritance
										Basically a shadow copy of an object
										
										function object(o){
											function F(){};
											F.prototype = o;
											return new F();
										}
										
										ECMASCRIPT FORMALIZE THE CONCEPT THROUGH
											Object.create()
											
									Parasitic Inheritance

									Parasitic Combination Inheritance
										To avoid the duplication of SuperType code we use the Prototypal Inheritance in the SuperType assign to the SubType prototype.
										
									CLOSURES
										STATIC PRIVATE VARIABLE TO SHARE FUNCTIONS THROUGH PROTOTYPES!!!
										MODULE PATTERN
										
										
									DOM
										Node type
											Each node contains a childNodes property containing NodeList array-like object.
											appendChild -> if the node is already part of the document it is removed from its previous location and placed at the new location.
											removeChild The removed node is still owned by the document but does not have any specific location in the document.
											cloneNode could make a shallow copy or a deep copy , the events of each node are not copied!!!
											cloneNode does not copy Javascript properties added by us to DOM nodes such as event handlers!!!
										Document node is the root it is and instance of HTMLDocument
											It could have four types of childreen , DocumentType,Element,ProcessingInstruction,Comment
											<html>
												<body>
												</body>
											</html>
											document.documentElement == document.childNodes[0];
											
											As an instance og HTMLDocument the document object has several additional properties that standard Document objects do not have.
											One of this properties is the domain property , this property has some restrictions because of security issues.
											The ability to set document.domain is useful when there is a frame or iframe on the page from a different subdomain.Pages from different subdomains can not communicate
											with one another via Javascript because of cross domain security restrictions.
											
										Element Type
											Represents an XML or HTML element.
											All HTML elements are represented by the HTMLElement which inherits directly from Element.
											One of the properties from this elemeny is the className which is used to specify CSS classes on an  element.
											The class name could not be used because is an ECMAScript reserved word.
											Custom attributes are not access has object properties , we must use the getAttribute method
											
										DocumentFragment type
											Is the only node that has no representation in markup.
											It is a lightweight document.
											
											<ul id="myList"></ul>
											We want to add three list items to this ul element.Adding each item directly to the element causes the browser to rerender the page.To avoid :
											var fragment = document.createDocumentFragment();
											var ul = document.getElementById("myList");
											var li = null;
											for(var i=0;i < 3;i++){
												li = document.createElement("li");
												li.appendChild(document.createTextNode("Item " + (i+1));
												fragment.appendChild(li);
											}
											ul.appendChild(fragment);
											
											To facilitate the tables creation and manipulation the DOM adds several properties to the <table> <tbody> and <tr> elements 
											
										NodeList,NamedNodeMap and HTMLCollection
											They are queries that run against the DOM docuemnt whenever they are accessed.
											
										Selectors API
											Retrieve a number of DOM elements matching a pattern specified using CSS selectors.
											querySelector() 
											querySelectorAll()
											
											#myDiv     ->element with the ID myDiv
											.selected  ->first element with a class of "selected"
											img.button ->image with class of "button"
										Element	Travessal to overcome the IE problem of not return text nodes for white spaces in between elements.
										HTML 5
											One of the major changes in web developemnt since the time HTML4 was adopted is the increased usage of the class attribute to indicate both stylistic and semantic
											information about elements.This caused a lot of Javascript interaction with CSS classes,including the dynamic changing of classes and querying the document to find elements
											with a given class or set of classes.
											
												getElementsByClassName()
												
											DOM3 setUserData() assigns data to a node , a key , the actual data and handler function that is called when the node cloned,removed,renamed or imported into another document.

											Computed Styles
												Information about styles that have cascaded from styles sheets and affect the element.
												
												document.defaultView.getComputedStyle
												
												Traversal -> TreeWalker NodeIterator
													Perform Depth-first traversals!!!
													
										Event Flow
											Event Bubbling Start at the deepest and flow upward to the least specific
											Capturing Flow From least to the target
											
											DOM Event Flow
												First the Capturing (opportunity to intercept)
												Actual target receives the event
												Then Bubbling (Final Resposnse)
												
												Event Handlers(or Event Listerners)
												
												Each event supported by an element can be assigned using an HTML attribute with the name of the event handler.
												Events handlers have some unique aspects, a function is created that wraps the attribute value, that function has a special local variable , which is the event object.
												The this value inside if the function is equivalent to the event's target element
												It augments the scope chain 
													function(){
														with(document){
															with(this){
																//attribute value
															}
														}
													}
													
												If it is a form element
													function(){
														with(this.form){
															with(document){
																with(this){
																	//attribute value
																}
															}
														}	
													}
													
												To not couple HTML to Javascript , it is better to use Javascript to assign event handlers!
												Each Element as well as window and document has event handlers properties
													var btn = document.getElementById("myBtn");
													btn.onclink = function(){
														alert("Clicked");
													};
													
													Using event handlers using DOM Level 0 method,the event handler is considered to be a method of the element therefore is run within the scope of the element.
													var btn = document.getElementById("myBtn");
													btn.onclink = function(){
														alert(this.id);
													};
													
													DOM Level 2 Event Handlers
														addEventListener
														removeEventListener
														
														var btn = document.getElementById("myBtn");
														btn.addEventListener("click", function(){
														alert(this.id);},false);
														
														DOM Level 2 Event handlers also runs in the scope of the element on which it is attached!!!
														
														Internet Explorer use the attachEvent that is very similar to DOM Level 2 There is a huge difference between the two that is the scope where the function executes,
														the Internet Explorer attachEvent runs in the global scope.
														
														The event object allow to assign event handlers to parents nodes that catch the event either in the capturing or bubbling phase!!!
														For instance , the this object is always equal to the currentTarget whereas target property contains the actual target of the event!!!
														
														DOMContentLoaded fires as soon as the DOM tree is completely formed and without regard to images,Javascript files ,Css files or other such resources!!
														
													RICH TEXT
														Implemented through an iframe and the respective design mode property or contenteditable property.
														The contenteditable property allows any element of the page to become editable and it does not require the overhead of an iframe,blank page and Javascript.
														Since rich text is implemented through iframe or contenteditable element instead of a form control,a rich editor is technically not part of a form.
														This means the HTML will not be submitted to the server unless we extract the HTML manually and submit it ourself.
														This is typically done by having a hidden form field that is updated with the HTML from the iframe or the contenteditable element.
														
													Cross Document Messaging or XDM
														Ability to pass information between pages from different origins.
														postMessage() at the heart of Html5 XDM!!!
														
													ERROR LOGS IN THE SERVER
														function logError(sev, msg){
															var img = new Image();
															img.src = “log.php?sev=” + encodeURIComponent(sev) + “&msg=” +
															encodeURIComponent(msg);
														}
														
														AJAX AND CORS
															The basic idea behind CORS is to use custom HTTP headers to allow both the browser and the server to know enough about each
															other to determine if the request or response should succeed or fail.
															Preflighted Requests
																CORS allows the use of custom headers,methods other than GET or POST and different body content types through a transparent mechanism of server 
																verification called PREFLIGHTED REQUESTS!!!
																
														Alternate Cross Domain Techniques
															Image Pings
															JSONP https://www.w3schools.com/js/js_json_jsonp.asp
															Comet
															
													ADVANCED TECHNIQUES
														SCOPE SAFE CONSTRUCTORS
															function Person(name,age,job){
																if(this instanceOf Person){
																	this.name = name;
																	this.age = age;
																	this.job = job;
																}else{
																	return new Person(name,age,job);
																}
															}
															
															Be careful when using Constructor stealing!!!
															
														LAZY LOADING FUNCTIONS
															if(typeof ...){
																return new XMLHttpRequest();
															}
															
														function createXHR(){	
															if(typeof ....){
															 var createXHR = function(){
																return new XMLHttpRequest();
															 };
															}
															
															OR USE  IIFE (Immediately Invoked Function Expression)
															
															var createXHR = (function(){
																if(typeof ...){
																	return function(){
																		return newHttpRequest();
																}
																
														FUNCTION CURRYING
															function curry(fn){
																var args = Array.prototype.slice(arguments,1);
																return function(){
																	var innerArgs = Array.prototype.slice.call(arguments);  <- Clone purpose
																	var finalArgs = args.concat(innerArgs);
																	return fn.apply(null,finalArgs);
																}
															}
															
														TAMPER PROOF OBJECTS
															Nonextensible
																Object.preventExtensions(person); -> Properties and methods an not be added
															Sealed Objects
																Object.seal -> Non extensible and [[Configurable]] set to false , properties and methods cannot be deleted and data properties be changed to
																accessor properties.
															Frozen Objects -> Non extensible , Sealed and [[Writable]] attribute set to false
																Object.freeze
																
														Timers
															setTimeout -> Specified intervals indicates when the timers code will be added to the queue,not when the code will actually be executed!!!
															Using setIntervals could result in intervals being skipped and intervals be smaller than expected between multiple timer code executions!!!
															
															setTimout(function(){
																//processing
																setTimeout(arguments.callee,interval);
																},interval);
																
															Array Chunking(Avoid blocking operations)
															function(array,process,context){
																setTimeout(function(){
																		var item = array.shift();
																		process.call(context, item);
																		if(array.length > 0){
																			setTimeout(arguments.callee, 100);
																		}
																	}, 100);
																}
																
															FUNCTION THROTTLING
																var processor = {
																
																	timeoutId: null,
																	
																	performProcessing : function(){
																		//actual processing code
																	}
																	
																	process : function(){
																		clearTimeout(this.timeoutId);
																		var that = this;
																		setTimout(function(){
																			that.performProcessing();
																		},100)
																	}
																}
																
																General
																	function throttle(method,context){
																		clearTimeout(method.tId);
																		method.tId = setTimeout(function(){
																			method.call(context);
																		},100);
																	}
																	
															APPLICATION CACHE -> manifest file with the path specified on html attribute
															DATA STORAGE
																Cookies	
																	name
																	value
																	domain
																	path
																	expiration
																	secure
																
																
																
															
																
															
															
																
														
														
														
														
													
											
												
											
											
											
											
											
											
										
									
										
						                             
						
							
							
							
							
						
					
						
															
																
																
															
															
															
															
															
																
															
														
															
															
														
														
														
															
															
																
															
															
														
														
														
													
														
														
												
												
												
												
												
											
							
							
							
							
						
						
					
					
					
					
					
					
					
					
					
					
					
					
					
						
							
					
					
					
					
					
				
				
					
			
			
			
			
		
		
		
		
		
		
															
											
											
											
										
										
										
									


									
									
								
								
								
								
								
								
								
								
								
								
								
								
						

								
							
						 
						
						
				  
				
				
			
			
			
	
	
			
			
		