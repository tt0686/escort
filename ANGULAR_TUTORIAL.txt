ANGULAR

	https://blog.thoughtram.io/angular/2015/05/03/the-difference-between-annotations-and-decorators.html

	TYPESCRIPT
	
		METADATA ANNOTATIONS
			@Component({
			  selector: 'tabs',
			  template: `
				<ul>
				  <li>Tab 1</li>
				  <li>Tab 2</li>
				</ul>
			  `
			})
			export class Tabs {

			}
			
			We have a class Tabs that is basically empty. The class has one annotation @Component. If we’d remove all annotations, what would be left is just an empty class that doesn’t have any special meaning right? 
			So it seems that @Component add some metadata to the class in order to give it a specific meaning. This is what annotations are all about. They are a declarative way to add metadata to code.
			
			Where do those annotations come from? This is nothing that JavaScript gives us out of the box right?
			
				import { 
				  ComponentMetadata as Component,
				} from '@angular/core';
				
				export class ComponentMetadata extends DirectiveMetadata {

				  constructor() {
					...
				  }
				}
				
				We can see that ComponentMetadata is in fact an implementation detail of the Angular framework. This answers our second question.
				But wait. It’s just yet another class? How can just a simple class change the way how other classes behave? 
				And why are we able to use those classes as annotations by just prefixing them with an @ sign? Well, actually we can’t. 
				Annotations are not available in browser’s of today, which means we need to transpile it to something that does run in current browsers.
				Even though we have a couple of transpilers we can choose from. Babel, Traceur, TypeScript, … 
				It turns out there’s only one that actually implements annotations as we know them from AtScript: Traceur. Taking the component code from above, this is what it translates to using Traceur
				
				var Tabs = (function () {
				  function Tabs() {}

				  Tabs.annotations = [
					new ComponentMetadata({...}),
				  ];

				  return Tabs;
				})
				
				In the end, a class is just a function, which is also just an object, and all annotations end up as instance calls on the annotations property of the class.
				class MyClass {

				  constructor(@Annotation() foo) {
					...
				  }
				}
				This would translate to something like this:

				var MyClass = (function () {
				  function MyClass() {}

				  MyClass.parameters = [[new Annotation()]];

				  return MyClass;
				})
				
				The reason why this translate to a nested array, is because a parameter can have more than one annotation.
				Another very interesting learning is that Angular expects the metadata on annotations and parameters properties of classes. 
				If Traceur would not translate them to those particular properties, Angular wouldn’t know from where to get the metadata. Which makes AtScript Annotations just a very specific implementation of what annotations could actually be.
				Wouldn’t it be nicer if you as a consumer could decide where your metadata is attached to in your code? Yes! And this is where decorators come into play.
				
				Decorators
					Decorators are a proposed standard for ECMAScript 2016 by Yehuda Katz, to annotate and modify classes and properties at design time. 
					This sounds pretty much like what annotations do right? Well… sort of. Let’s take a look at what a decorator looks like:

						// A simple decorator
						@decoratorExpression
						class MyClass { }
						
				Wait. This looks exactly like an AtScript annotation! That’s right. But it isn’t. From a consumer perspective, a decorator indeed looks like the thing that we know as “AtScript Annotation”. 
				There is a significant difference though. We are in charge of what our decorator does to our code. 
				Taking the code above, a corresponding decorator implementation for @decoratorExpression could look like this:

						function decoratorExpression(target) {
						   // Add a property on target
						   target.annotated = true;
						}
				
				Right. A decorator is just a function that gives you access to the target that needs to be decorated. 
				Get the idea? Instead of having a transpiler that decides where your annotations go, we are in charge of defining what a specific decoration/annotation does.
				This, of course, also enables us to implement a decorator that adds metadata to our code the same way AtScript annotations do 
				(I keep referring to “AtScript annotations” because what they do, is really an AtScript specific thing). Or in other words: with decorators, we can build annotations.
				
		Interfaces
			INTERFACES ARE NOT TO BE CONVERTED TO JAVASCRIPT. IT’S JUST PART OF TYPESCRIPT!!!
			
			interface Lakes {
				name: string,
				area: number,
				countries: string[],
				frozen?: string[],
				readonly size: number,
				[extraProp: string]: any
			}
			
			Function and Interfaces
			
			interface EnemyHit {
				(name: Enemy, damageDone: number): number;
			}
			 
			let tankHit: EnemyHit = function(tankName: Enemy, damageDone: number) {
				tankName.health -= damageDone;
				return tankName.health;
			}
			
		Types
			Javascript has seven different types:
				Undefined,Null,Boolean,Number,String,Symbol,Object
			Typescript
				Null      let a:null = null;
				Undefined
				Void
				Boolean
				Number
				String
				Array  let a: number[] = [1, 12, 93, 5];
					   let d: Array<number> = [null, undefined, 10, 15];
				Tuple
					let a: [number, string] = [11, "monday"];
					let b: [number, string] = ["monday", 11]; // Error
					let d: [number, string] = [105, "owl", 129, 45, "cat"];
					let e: [number, string] = [13, "bat", "spiderman", 2];
				Enum
					enum Animals {cat, lion, dog, cow, monkey}
					let c: Animals = Animals.cat;
					console.log(Animals[3]); // cow
					console.log(Animals.monkey); // 4
				Any
					let a: any = "apple";
					let b: any = 14;
					let c: any = false;
					let d: any[] = ["door", "kitchen", 13, false, null];
					b = "people";
				Never
				
		Classes
			class Person{
				private name:string;
				constructor(theName: string){
					this.name = theName;
				}
				introducedSelf(){
					console.log(...)
				}
			}
			
		Inheritance
			class Friend extends Person {
				yearsKnown: number;
				constructor(name: string, yearsKnown: number) {
					super(name);
					this.yearsKnown = yearsKnown;
				}
				timeKnown() {
					console.log("We have been friends for " + this.yearsKnown + " years.")
				}
			}
			
				class Person {
					private name: string;
					protected age: number;
					protected constructor(theName: string, theAge: number) {
						this.name = theName;
						this.age = theAge;
					}
					introduceSelf() {
						console.log("Hi, I am " + this.name + "!");
					}
				}
 
				class Friend extends Person {
					yearsKnown: number;
					constructor(name: string, age: number, yearsKnown: number) {
						super(name, age);
						this.yearsKnown = yearsKnown;
					}
					timeKnown() {
						console.log("We have been friends for " + this.yearsKnown + " years.")
					}
					friendSince() {
						let firstAge = this.age - this.yearsKnown;
						console.log(`We have been friends since I was ${firstAge} years old.`)
					}
				}

		Generics
			function randomElem<T>(theArray: T[]): T {
				let randomIndex = Math.floor(Math.random()*theArray.length);
				return theArray[randomIndex];
			}
			 
			let colors: string[] = ['violet', 'indigo', 'blue', 'green'];
			let randomColor: string = randomElem(colors);

			INSTEAD OF USING THE ANY TYPE !!!
			
			interface People {
				name: string
			}
 
			interface Family {
				name: string,
				age: number,
				relation: string
			}
			 
			interface Celebrity extends People {
				profession: string
			}
			 
			function printName<T extends People>(theInput: T): void {
				console.log(`My name is ${theInput.name}`);
			}
			 
			let serena: Celebrity = {
				name: 'Serena Williams',
				profession: 'Tennis Player'
			}
			
			
			MIXIN
				https://javascript.info/mixins
				http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/
				http://raganwald.com/2015/06/17/functional-mixins.html
				
				In JavaScript we can only inherit from a single object. There can be only one [[Prototype]] for an object. And a class may extend only one other class.
				But sometimes that feels limiting.
				As defined in Wikipedia, a mixin is a class that contains methods for use by other classes without having to be the parent class of those other classes.
				In other words, a mixin provides methods that implement a certain behavior, but we do not use it alone, we use it to add the behavior to other classes.
				
			DECORATORS
				https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841
			
				'@' indicates to the parser that we’re using a decorator while mydecorator references a function by that name. Our decorator takes an argument (the function being decorated) and returns the 
				same function with added functionality.
				Decorators are helpful for anything you want to transparently wrap with extra functionality. These include memoization, enforcing access control and authentication, 
				instrumentation and timing functions, logging, rate-limiting, and the list goes on.
				
				class Cat{
					meow() {return `${this.name} says Meow!`;}
				}
				
				equivalent to this
				
				Object.defineProperty(Cat.prototype,'meow',{value : "function() {return `${this.name} says Meow!`;}",enumerable :false ,configurable :true ,writable :true})
				
				Imagine we want to mark a property or method name as not being writable. A decorator precedes the syntax that defines a property. We could thus define a `@readonly` decorator for it as follows:
				
				function readonly(target,key,descriptor){
					descriptor.writable = false;
					return descriptor;
				}
				
				class Cat{
					@readonly
					meow() {return `${this.name} says Meow!`;}
				}
				
				Can decorate classes either 
				
				function superhero(target){
					target.isSuperHero = true;
					target.power = "flight";
				}
				
				@superhero
				class MySuperHero(){}
				
				function superhero(isSuperHero){
					return function(target){
						target.isSuperhero = isSuperhero;
					}
				}
				
				@superhero(true)
				class MySuperHero(){}
				
		ANGULAR
			The 1.x version had limitations, and a number of optimizations were built into the framework. The concept of two-way databinding (being able to sync data between the controller and the view automatically), 
			which was touted early on as its best feature, became a performance bottleneck in large applications that abused its utility. To help mitigate this problem, one-way and one-time binding options were 
			introduced to improve performance, but they required developers to opt in. Also, components were introduced as a better way to organize and structure applications, 
			but taking advantage of them required refactoring of existing applications.
			
			COMPONENT BASED ARCHITECTURE
				Components key characteristics
					Encapsulation
					Isolation
					Reusability
					Evented
					Customizable
					Declarative
					
					Standard required to implement web components :
						Custom elements
							https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements
							Mean to be able to extend HTML with our own additional elements
						Shadow DOM
							https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM
							Isolate styling behaviors inside of a component.Is an isolated Document Object Model tree that is detached from the typical CSS inheritance, allowing us to create a barrier
							between markup inside and outside of the Shadow DOM.
							For example, if you have a button inside of a Shadow DOM and a button outside, any CSS for the button written outside the Shadow DOM won’t affect the button inside it. 
							This is important for Angular because it allows us to have better control over how CSS affects the way the components display.
							Shadow DOM allows hidden DOM trees to be attached to elements in the regular DOM tree — this shadow DOM tree starts with a shadow root, 
							underneath which can be attached to any elements you want, in the same way as the normal DOM.
						Templates
						
					REACTING PROGRAMMING
						https://medium.com/@tkssharma/reactive-programming-rx-js-introduction-32bf963eee1b
						https://dzone.com/refcardz/rxjs-streams?chapter=6
						https://www.sitepoint.com/functional-reactive-programming-rxjs/
						https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators
						https://www.47deg.com/blog/road-to-frp-js-part-1/
						
						"Reactive programming is programming with asynchronous data streams."

						In a way, this isn’t anything new. Event buses or your typical click events are really an asynchronous event stream, on which you can observe and do some side effects. 
						Reactive is that idea on steroids. You are able to create data streams of anything, not just from click and hover events. 
						Streams are cheap and ubiquitous, anything can be a stream: variables, user inputs, properties, caches, data structures, etc. 
						For example, imagine your Twitter feed would be a data stream in the same fashion that click events are. You can listen to that stream and react accordingly.
						On top of that, you are given an amazing toolbox of functions to combine, create and filter any of those streams.That’s where the “functional” magic kicks in. 
						A stream can be used as an input to another one. Even multiple streams can be used as inputs to another stream. You can merge two streams. 
						You can filter a stream to get another one that has only those events you are interested in. You can map data values from one stream to another new one.
						A stream is a sequence of ongoing events ordered in time. It can emit three different things: a value (of some type), an error, or a “completed” signal.
						
						
						
					https://codeburst.io/javascript-es-2017-learn-async-await-by-example-48acc58bad65
					Async Functions and Promises
						Async functions return a PROMISE.
						
						
		COMPILER

			https://blog.angularindepth.com/a-deep-deep-deep-deep-deep-dive-into-the-angular-compiler-5379171ffb7a
			
			ANGULAR RESUME
			
			COMPONENT ARCHITECTURE
				
				Concepts :
					Encapsulation
					Isolation
					Reusability
					Evented
					Customizable
					Declarative
					
					The W3C is developing an official Web Component specification:
						Custom Elements(encapsulation,declarative,reusability,customizable)
							Allow developers to create new HTML elements that essentially blend naturally and natively into the DOM.
							Custom elements have a lot of the stuff necessary for building components. In fact, we could stop with custom elements and be fairly happy. It gives us a declarative way to create
							a reusable component, which encapsulates the internal mechanics of the component away from the rest of the application, but can emit events to enable other components to hook into the lifecycle. 
							Angular uses these concepts in its implementation of components.
							
							<tabs>
								<tab title="About">
									<h1>This is the about tab</h1>
								</tab>
								<tab title="Profile">
									<h2>This is the profile tab</h2>
								</tab>
								<tab title="Contact Us">
									<form>
										<textarea name="message"></textarea>
										<input type="submit" value="Send">
									</form>
								</tab>
							</tabs>
							
								This looks and feels like natural HTML because these would be two custom elements: tabs and tab elements.
							
						Shadow DOM (isolation,encapsulation,customizable)
							Despite the rather ominous-sounding name, the Shadow DOM is really your best friend when it comes to trying to isolate styling behaviors inside of a component.
							The Shadow DOM is an isolated Document Object Model (DOM) tree that’s detached from the typical CSS inheritance, allowing you to create a barrier between markup inside and outside
							of the Shadow DOM
						Templates(encapsulation,isolation)
						Javascript modules(encapsulation,isolation,reusability)
						
						
						import {Component} from '@angular/core';
							
							@Component({                                        The Decorator : Way to add metadata to the class , Angular use them as a way to understand what type of class has been declared.
								selector: 'my-component',                                       In this case, it is a component and Angular will know how to render a component based on this decorator.
								template: `                                                     There are several other ones,such as Injectable and Pipe.
									<div>
									<h4>{{title}}</h4>
									</div>
									`
								})
							export class MyComponent {
								constructor() {
								this.title = 'My Component';
								}
							}
							
							Observables
								New pattern to Javascript applications to manage asynchronous activities.
								Promises have a major limitation in that they're only useful for one call cycle. For example, if you wanted to have a promise return a value on an event like a user click, 
								that promise would resolve on the first click. But you might be interested in handling every user click action.
								Reactive programming is the higher-level name for what observables provide, which is a pattern for dealing with asynchronous data streams.
								Another interesting capability of observables is that they are composable into many combinations. Observables can be combined, flattened into one, filtered, and more.
								
								e2e 							End-to-end testing folder, contains a basic stub test
								node_modules 					Standard NPM modules directory, no code should be placed here
								src 							Source directory for the application
										app 				Contains the primary App component and module
										assets 				Empty directory to store static assets like images
										environments		Environment configurations to allow you to build for different targets, like dev or production
										favicon.ico 		Image displayed as browser favorite icon
										index.html  		Root HTML file for the application
										main.ts     		Entry point for the web application code
										polyfills.ts		Imports some common polyfills required to run Angular properly on some browsers
										styles.css  		Global stylesheet
										test.ts     		Unit test entry point, not part of application
										tsconfig.app		TypeScript compiler configuration for apps
										tsconfig.spec.json  TypeScript compiler configuration for unit tests
										typings.d.ts        Typings configuration
										
								.editorconfig 		Editor configuration defaults
								.angular-cli.json 	Configuration file for the CLI about this project
								karma.conf.js 		Karma configuration file for unit test runner
								package.json 		Standard NPM package manifest file
								protractor.conf.js 	Protractor configuration file for e2e test runner
								README.md 			Standard readme file, contains starter information
								tsconfig.json 		Default configuration file for TypeScript compiler
								tslint.json 		TSLint configuration file for TypeScript linting rules
								
								
								src/app/app.component.ts -> File that contains the App Component,which is the root of the application.
								
									import { Component } from '@angular/core';
									
									@Component({
										selector: 'app-root',
										templateUrl: './app.component.html',
										styleUrls: ['./app.component.css']
									})
									export class AppComponent {
										title = 'app works!';
									}
									
								app/app.component.html
										<h1>
										{{title}}  <- Interpolation
										</h1>

								The App module is the packaging that helps tell Angular what's available to render.
								
								src/app/app.module.ts
								
									import { BrowserModule } from '@angular/platform-browser';
									import { NgModule } from '@angular/core';
									import { AppComponent } from './app.component';
									
									@NgModule({
										declarations: [AppComponent],  <- Components and directives to make available to the entire application
										imports: [BrowserModule,],     <- Array of another modules upon which this module depends
										providers: [],                 <- Services
										bootstrap: [AppComponent]      <- Which components to bootstrap at runtime.
									})
									export class AppModule { }
									
								BOOTSTRAPPING THE APPLICATION

									The application must be bootstrapped at runtime to start the process of rendering.The CLI takes care of wiring up the building tooling,which is based on webpack(module bundler).
									At the .angular-cli.json file. You’ll see an array of apps, and one of the properties is the main property. By default, it points to the src/app/main.ts file.
									This means that when the application gets built, it will automatically call the contents of the main.ts file as the first set of instructions.
									The role of main.ts is to bootstrap the Angular application.
									
									import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
									import { enableProdMode } from '@angular/core';
									import { environment } from './environments/environment';
									import { AppModule } from './app/';
									
									if (environment.production) {
										enableProdMode();
									}
									platformBrowserDynamic().bootstrapModule(AppModule); <- That is the point where code begins to execute !!!
									
									src/index.html file:
										<body>
											<app-root></app-root>
										</body>
										
									SERVICE
										ng generate service services/stocks
									
										CLI doesn’t automatically register the service with the App module, and we need to register HttpClient with the application.
										
										import { Injectable } from '@angular/core';
										import { HttpClient } from '@angular/common/http';
										
										let stocks: Array<string> = ['AAPL', 'GOOG', 'FB', 'AMZN', 'TWTR'];
										let service: string = 'https://angular2-in-action-api.herokuapp.com';
										
										export interface StockInterface {
											symbol: string;
											lastTradePriceOnly: number;
											change: number;
											changeInPercent: number;
										}
										
										@Injectable()
										export class StocksService {
											constructor(private http: HttpClient) {}
											
										src/app/app.module.ts
										
										imports: [
											BrowserModule,
											HttpClientModule
											],
								
										Now we need to register the new StocksService with the providers property to inform Angular that it should be made available for the module to use:
											providers: [StocksService]
											
											<div ...[ngClass]="{increase: isPositive(), decrease: isNegative()}">  -> DIRECTIVE(ngClass)
												...
												{{stock?.lastTradePriceOnly | currency:'USD':'symbol':'.2'}}  | -> PIPE
												
												ncClass is able to add or remove CSS classes to and from the element.
												The properties map to methods on the controller
												Pipes only modify the data before it is displayed, and do not change the value in the controller!!!
												
										In the controller :
											@Input() stock: any; -> DECLARES A PROPERTY THAT IS AN INPUT VALUE.
												This indicates that this property is to be provided to the component by a parent component passing it to the summary.
												
												<summary [stock]="stockData"></summary>
												
										In the component css file
											:host .stock-card...   -> Because components need to be as self-contained as possible, they rely on the Shadow DOM concepts. When Angular renders this component,
																		it will modify the output to ensure that the CSS selector is unique and doesn’t accidentally interfere with other elements on the page. 
																		This behavior is configurable.The host selector is a way to specify that you want the styles to apply to the element that hosts the element, 
																		so in this case it will look at the Summary component element itself rather than the contents inside it.
											
											
										export class DashboardComponent implements OnInit
										
											must implement 
													
												ngOnInit() {
													this.service.load(this.symbols).subscribe(stocks => this.stocks = stocks);
												}
												
												In the constructor 
												
													constructor(private service: StocksService) {
														this.symbols = service.get();
													}
													
													The constructor method runs as soon as the component is created.
													It will import the Stocks service onto the service property and then request the current list of stock symbols from it. 
													This works because this is a synchronous action that loads a value directly from memory.
													The constructor fires early in the rendering of a component, which means that often, values are not yet ready to be consumed.
													Components expose a number of lifecycle hooks that allow we to execute commands at various stages of rendering, giving we greater control over when things occur.
													In our code, we use the ngOnInit lifecycle hook to call the service to load the stock data.
													
													*ngFor="let stock of stocks"
													
													EVENT BIDING
														(submit) = "add()"
														
														TWO WAY BINDING -> [(ngModel)]="stock" IT WILL SYNC THE VALUE OF THE INPUT AND THE VALUE OF THE PROPERTY IN THE CONTROLLER ANYTIME IT CHANGES FROM EITHER LOCATION.
														
														
							BINDINGS IN ANGULAR !!!!
								A template in angular is a HTML with additional markup in it.
								A view is according to angularJs documentation is the parsed and processed template (the DOM)
							
								Bindings are the conduit for data or methods to be used from a controller in the template;they allow data  in the controller to flow into the template or events to call from the template
								back in the controller.
								 Interpolation {{prop}} -> Get prop from the controller
												{{getName()}}
												<a href="/users/{{user.user_id}}">View Profile</a>
												
								 Property Binding
										<img [src]="user.img" />
										Using the [] syntax binds to an element’s property, not the attribute. This is an important distinction, because properties are the DOM element’s property. 
										That makes it possible to use any valid HTML element property (such as the img src property).
										Instead of binding the data to the attribute, you’re binding data directly to the element property, which is quite efficient.
										
										Special Binding
											[class.className] ->  The class binding syntax is useful for targeting specific classes to be added or removed from an element. 
											It also only adds to the existing classes instead of replacing them entirely, like if we use [class]="getClass()".
											
								Attribute Binding
										Some element properties can’t be directly bound, because some HTML elements have attributes that aren't also made available as properties of the element. 
										The aria (accessibility) attributes are one such example of an attribute that doesn’t get added as a property to the element.
										If we try to do aria-required="{{isRequired()}}" or [aria-required]="isRequired()", we’ll get a template parsing error. 
										Because this attribute isn’t a property, it can’t be directly bound to.
										The workaround is using the special attribute binding syntax, which looks like a property binding, except you put the name of the attribute in the brackets 
										with the prefix attr., like this:
											<input id="username" type="text" [attr.aria-required]="isRequired()" />
											
								 Event Binding
									So far, all data has flowed from the component into the template elements. 
									That’s great for displaying data, but we need some way for the elements in our template to bind back into the component. 
									The good news is that JavaScript has a great mechanism built in to pass data back up, by using events!!!
									The syntax for event bindings uses parentheses () to bind to a known event.
									
									(submit)="add"
								    (click)="remove(symbol)" -> symbol in this case is a local variable
									
								TWO WAY DATABINDING
									It uses both the property and event binding syntax together.
									Those familiar with AngularJS will be familiar with how it allows you to sync the value of a binding as it changes in either the template or the controller. 
									It does this by doing a regular property binding and setting up an event binding for you behind the scenes.
									You can only use NgModel with form elements, but you can use two-way binding syntax on properties.
									[(ngModel)]=""
									
							ROUTING
								Configures the different pages that the application can render!!!
								src/app/app.routes.ts
								
									import { Routes, RouterModule } from '@angular/router';
									import { DashboardComponent } from './components/dashboard/dashboard.component';
									import { ManageComponent } from './components/manage/manage.component';
									
									const routes: Routes = [
									{
										path: '',
										component: DashboardComponent
									},
									{
										path: 'manage',  ----> In this case it will be the follow URL http://localhost:4200/manage
										component: ManageComponent
									}
									];
									
									export const AppRoutes = RouterModule.forRoot(routes);
									
									Placeholder for the router
									<router-outlet></router-outlet>
									
									Links in the application
									 Directive
																 [routerLink]="['/']">Dashboard</a>
										<a class="mdl-navigation__link" [routerLink]="['/manage']">
										
										The directive parses the array and tries to match to a known route. Once it matches a route, it will add an href to the anchor tag that correctly links to that route.
										
										
										ENTITIES
											Modules   -> Objects that help you to organize dependencies into discrete units
											Components-> New elements that will compose the majority of your application's structure and logic
											Directives-> Objects that modify elements to give them new capabilities or change behaviors 
											Pipes     -> Functions that format data before it's rendered 
											Services  -> Reusable objects that fill niche roles such as data access or helper utilities
											
											<Core Pipes>--->[Angular Core]<----<Core Directives>  ANGULAR CORE LIBRARIES,INCLUDING PIPES AND DIRECTIVES ARE LOADED
														        |
																|
																|          |Browser PLataform Module  THE APPLICATION MODULE IS BOOTSRAPPED AND INCLUDES DEPENDECY MODULES
															   \ /         |Forms Module
														  (APP MODULE)<--- |Http Module
														        |
																|
																|
															   \ /
														  (APP COMPONENT)	   THE APP COMPONENT IS RENDERED,WHICH THEN TRIGGERS CHILDREN TO BE RENDERED.
												-----------------------------------
									      Route									Route
										    |                                     |
											|									  |
											|                                     |
								 	  DashBoard Component			        Manage Component 
								       [NgFor Directive]
							------------------------------------				
							Summary Summar Summary Summary ...Component		   
								|
								|
								|
							Currency Pipe 
                            Percent  Pipe

								Modules
									There are two kinds of modules in Angular
										Javascript Modules
											Every TypeScript file we wrote was a JavaScript module because it either imported or exported some values.
										Angular Modules
											Angular modules are logical constructs used for organizing similar groups of entities (such as all things needed for the router) and are used by Angular to understand 
											what needs to be loaded as well as what dependencies exist.
											An App module that holds a reference to all the application logic for Angular to render. There must always be an App module, but there will likely be additional modules 
											in your application—either official Angular modules, third-party ones, or other ones you may create.
											A module is declared by creating a class and decorating it with the @NgModule decorator.
											
								Components
									Encapsulation
									Isolation
									Reusability
									Event Based
									Customizable
									Declarative
									
									THE BASIC ITERATION OF COMPONENTS IS TO PUSH DATA DOWN FROM PARENTS TO COMPONENTS USUALLY THROUGH BINDING AND BACK UP USUALLY THROUGH EVENTS.
									A COMPONENT CREATES A VIEW, WHICH IS THE RENDERED RESULT OF A COMPONENT THAT THE USER CAN INTERACT WITH AND IS COMPRISED OF RENDERING THE COMPONENT TEMPLATE.
									Have a lifecycle:
										Component register with the module (NgModule) (during application bootstrap)
																			When the component is registered, it creates a component factory class and stores it for later use.
																			There is a registry of components that belong to the module, and Angular will look up the component in question and
																			retrieve its component factory, which is generated during the compilation using the CLI before the app is run.
										Template includes a component
										Component is instantiated
										Controller constructor is called
										Compiler renders any child components in template
								Components lifecycle hooks begin     ^
																	 |
										Application state changes  --- 
										Component removed from view
										
									Lifecycle hooks
										OnChanges            Input values have changed.
										OnInit               Runs once after the component has fully initialized(though not necessarily when all child components are ready)
										OnDestroy
										DoCheck              Any time that change detection runs
										AfterContentInit     When any content children have been fully initialized
										AfterContentChecked  Every time that Angular checks the content children
										AfterViewInit        This hook lets you run logic after all View Children have been initially rendered.
										AfterViewChecked     When Angular checks the component view and any View Children have been checked
										
										NESTING COMPONENTS
											There are two ways to nest components
												Most often, components are nested by being declared in the template of another component. Any component that’s nested inside another’s template is called a View Child, 
												so named because the template represents the view of the component and therefore is a child inside that view.
												A View Child is declared inside the component template.
												
												Occasionally a component accepts content to be inserted into its template, and this is known as a Content Child, so named because these components are inserted as content
												inside the component rather than being directly declared in the template. A Content Child is declared between the opening and closing tags when a component is used.
											
												Example
													UserProfile component where the template take the following structure :
														<user-avatar [avatar]="avatar"></user-avatar>    <--View Child
														<ng-content></ng-content>                        <--Content Child
										
												Using the UserProfile component
													<user-profile [avatar]="user.avatar">
														<user-details [user]="user"></user-details>
													</user-profile>
									Inputs
										When you create your own components, you can define properties that can accept input through property bindings.
										By default, all properties of a component aren’t immediately bind-able, as you saw earlier. They must be declared as an input to allow the property to be bound. 
										One reason is that we want encapsulation of our components, and it’s best not to automatically expose all properties. 
										Another reason is that Angular needs to know which properties exist so it can properly handle the wiring of values into a component.
										
										@Input() title: string = '';
										@Input() description: string = '';
										@Input('used') value: number = 0;       <-- Alias 
										@Input('available') max: number = 100;
										
									Intercepting Inputs
										private _max: number = 100;
										
										@Input('used')
										set value(value: number) {
											if (isNaN(value)) value = 0;
											this._value = value;
										}
										get value(): number { return this._value; }
										
										There’s another way to intercept and detect changes using the OnChanges lifecycle hook.
										
										implements OnChanges
										
										ngOnChanges(changes) {
											if (changes.value && isNaN(changes.value.currentValue)) this.value = 0;
											if (changes.max && isNaN(changes.max.currentValue)) this.max = 0;
										}
										
									Content Projection
											<thead>
												<tr>
													<th>Node</th>
													<th [colSpan]="2">CPU</th>
													<th [colSpan]="2">Memory</th>
													<th>Details</th>
												</tr>
											</thead>
											<ng-content></ng-content>  <--Insertion Point

											On the @Component decorator change the selector property -> select : '[app-nodes]' 
												INSTEAD OF LOOKING FOR AN ELEMENT ("TAG") IT WILL LOOK FOR THE ATTRIBUTE app-nodes
												WE DO THIS SO WE CAN APPLY THIS COMPONENT ONTO ANOTHER ELEMENT
	
											In the DashBoard component
												<table app-nodes class="table table-hover">
													<tr app-nodes-row *ngFor="let node of cluster1" [node]="node"></tr>
												</table>
		
											Because we used the attribute selector for the Nodes component on the table element, it will apply the component template inside the table. 
											That will insert the table head elements that are in the Nodes component template, but it also contains the NgContent insertion point.

											But what if we want to have multiple insertion points?
											
												<ng-content select="metric-title"></ngcontent>
												
												<app-metric class="col-sm-6" [used]="cpu.used" [available]="cpu.available">
													<metric-title>CPU</metric-title>
													<metric-description>utilization of CPU cores</metric-description>
												</app-metric>

												Now if you run the code, you’ll get a compilation error from Angular. 
												It will try to parse these new elements, recognize that they’re not registered components, and throw an error.
												
									Communication between components
										Inputs are the way to push data down the component tree to children and events are the way to pass data and notifications up through the component tree to parents.
										
										AppComponent
											NavBar    Component
											DashBoard Component
											
											
											In NavBar controller
												@Output() onRefresh: EventEmitter<null> = new EventEmitter<null>();
												
												refresh() {
													this.onRefresh.emit();
												}
												
												We begin by importing the Output decorator and EventEmitter factory object. We need both of these to set up an output event. 
												The EventEmitter is a special object that helps us emit custom events that work with Angular’s change detection.
												
											In NavBar template
												<button class="btn btn-success" type="button" (click)="refresh()">Reload</button>
												
											App component
												<app-navbar (onRefresh)="dashboard.generateData()"></app-navbar> <<<<<<<<<<<<<<<<local template variable
												<app-dashboard #dashboard></app-dashboard>
												
												If no components are listening to the event, then it will not propagate up the component tree. 
												Output events only go to the parent component, unlike regular DOM events (such as click or keypress) that do propagate up the DOM tree.
												
												View Child to reference components
												
													In order to access a child component’s controller inside a parent controller, we can leverage ViewChild to inject that controller into our component.
													
													export class AppComponent {
														@ViewChild(DashboardComponent) dashboard: DashboardComponent;
														
														refresh() {
														this.dashboard.generateData();
														}
													}
													
													<app-navbar (onRefresh)="refresh()"></app-navbar>
													<app-dashboard></app-dashboard>
													
									Styles to components
										1 navbar/navbar.component.css
										2
										  styleUrls: ['./navbar.component.css'],
										  styles: [`.btn { background-color: #999999; }`]
										  
										  The trick here is that whichever is declared last will win, so when we have both styles and styleUrls, the one declared last will override the first regardless of which
										  one is used, due to the way the compiling works.
										  
										3 navbar/navbar.component.html

									      <style>.btn { background-color: #3274b8; }</style>
											Once we save this, the application will reload, and all of a sudden your button will now
											be blue, which means that inline style declarations will override any values provide via
											the styles or styleUrls properties.
											
										4 navbar/navbar.component.html
											<button class="btn btn-success" type="button" style="background-color: #8616f6" (click)="refresh()">Reload</button>
											
											It should be noted that using the !important value will raise that particular rule above any others.
											All CSS rules are added to the end of the document head inside a new style element.
											As the application is rendered, components will get loaded, and those styles will get added to the document head. 
											But depending on the encapsulation mode, the way those styles are rendered can change the way those styles are processed.
											
									Encapsulation modes
										The most common approach is to use specific class naming conventions, as are found in most popular CSS libraries. 
										These conventions provide a specific nomenclature for CSS classes that limits the chances of the same class being used elsewhere.
										Enter the Shadow DOM, the official native browser standard for encapsulating styles.
										Three encapsulation mode:
											None
												Once the mode is set, any styles you declare for the component will be hoisted up from the component template into the document head, and this is the only real modification
												made to the markup. The style element is moved into the document head as is, which is a way of injecting global CSS rules.
											Default(Emulated)
												Emulated mode applies some transformations to any styles by adding unique attributes to HTML markup and CSS rules to increase the specificity of the CSS rules by making
												them unique.
											Native
												While the component renders, it creates a shadow root in the component. The template is injected into the shadow root, along with the styles from the sibling and any
												parent component.
												
									Dynamic Components
										
										1 USE NG_BOOTSPRAP
										
											constructor(public activeModal: NgbActiveModal) {}
											
												Unlike other components so far, this component won’t be called from a parent’s template. 
												But we will need to pass it an input for the data, so we still need to declare the input property.
												
											In template
												(click)="activeModal.dismiss()">
												
											In template in the Row component
												<td><button class="btn btn-secondary" (click)="open(node)">View</button></td>
												
											Now in the controller
												
													constructor(private modalService: NgbModal) {}
													
													open(node) {
														const modal = this.modalService.open(NodesDetailComponent);
														modal.componentInstance.node = node;
													}
											Now lastly in the parent Dashboard Component
												<template ngbModalContainer></template>     <-----PLACEHOLDER
												
											And in the application module
												entryComponents: [NodesDetailComponent],
												
												Entry components are any components that need to be rendered dynamically in the browser, which will also include components that are linked to routes
												
										2 ANGULAR APIs
											ViewContainerRef
											ViewChild
											ComponentFactoryResolver
											
											In alert.component.html
												<div class="container mt-2">
													<div class="alert alert-warning" role="alert">
														The data was refreshed at {{date | date:'medium'}}
													</div>
												</div>
												
											Controller
												@Component({
													selector: 'app-alert',
													templateUrl: './alert.component.html',
													styleUrls: ['./alert.component.css']
													})
												export class AlertComponent {
													@Input() date: Date;
												}
												
												modules.ts
													entryComponents: [
														NodesDetailComponent,
														AlertComponent
													]
													
												dashboard.component.html
													<app-navbar (onRefresh)="refresh()"></app-navbar>
													<ng-template #alertBox></ng-template>
													<app-dashboard></app-dashboard>
													
														
												app/app.component.ts
													export class AppComponent {
														alertRef: ComponentRef<AlertComponent>;
														@ViewChild(DashboardComponent) dashboard: DashboardComponent;
														@ViewChild('alertBox', {read: ViewContainerRef}) alertBox: ViewContainerRef;
														
															constructor(private ComponentFactoryResolver: ComponentFactoryResolver) {}
															
														alert(date) {
															if (!this.alertRef) {
															const alertComponent = this.ComponentFactoryResolver.resolveComponentFactory(AlertComponent); //NOT yet rendered it is in RAW form.
															this.alertRef = this.alertBox.createComponent(alertComponent);
																//alertBox is the instance of the element where we will inject  the component,wrapped in a ViewContainerRef instance
																//At this point, the component will be rendered into the template where the template element was declared.
															}
															this.alertRef.instance.date = date;
															this.alertRef.changeDetectorRef.detectChanges(); //Trigger the change detection
															setTimeout(() => this.destroyAlert(), 5000);
														}
														
														destroyAlert() {
															if (this.alertRef) {
															this.alertRef.destroy();
															delete this.alertRef;
														}
													}
													
													We then add two properties, with alertRef being a component reference to the Alert component (which is the declared typing). 
													We will want to have this reference so we can keep track of the alert and later remove it if we want. 
													The second property is another View Child, called alertBox. The ViewChild syntax is different because it allows us to pass in a string to reference a 
													local template variable by that name and then "read" it as a particular type of entity—in this case, a ViewContainerRef. 
													It will get the element based on the template variable and then parse it as a ViewContainerRef type.
											
											
											
											
											
											
										EXPLORING DOM ABSTRACTIONS
											
											
											
												
												
									
										
									
								Directives
									Three categories of directives:
										attribute (ngClass), 
										structural Modify the DOM tree (ngIf) (ngFor)
										componentes directives
										
										Directives make life much easier because they modify an element to give it a new capability, without having to use JavaScript to reach into the template and modify it on the fly.
								Pipes
								
							Bootstrapping process
								The CLI uses webpack to build, and it compiles all the JavaScript and adds it as script tags to the bottom of the index.html on build.
								This is when it will run the code to begin your app.
								Now that Angular has started, it loads your App module and reads through any additional dependencies that need to be loaded and bootstrapped. In the base app, 
								the Browser module is loaded into the application before further execution happens.
								Then Angular renders the App component, which is the root element of your application.
								As this App component renders, any child components are also rendered as part of the component tree. This is like the DOM tree, except any special Angular template
								syntax has to be rendered by Angular. As it renders, it will also resolve bindings and set up event listeners for anything that declares it.
								
								TWO TYPES OF COMPILER
									Ahead Of Time (AoT)
									Just In Time (JiT)
									
									One big difference is that with JiT, the application must also load the compiler library before the application can execute, whereas the AoT version is able to drop this
									payload from being sent, causing a faster load experience.
									
								Dependency Injection
									Dependency injection (DI) is a pattern for obtaining objects that uses a registry to maintain a list of available objects and a service that allows you to request the
									object you need. Rather than having to pass around objects, you can ask for what you need when you need it.
									There are a few key pieces to the DI system. The first is the injector. This is the service that Angular provides for requesting and registering dependencies. 
									The injector is often at work behind the scenes, but occasionally is used directly. Most of the time, you’ll invoke the injector by declaring a type annotation on the property. 
									We injected the HttpClient service like this:
										
										constructor(private http: HttpClient) {}
										
										Because we declare the type as HttpClient (which is a known service in Angular), the application will use the injector to ensure that the http property contains an instance
										of the HttpClient service. This seems like magic, but it’s merely a way to alias the dependency you would like to request without directly calling the injector API.
										The second part of DI is providers. 
										Providers are responsible for creating the instance of the object requested. The injector knows the list of available providers, and based on the name (which above is HttpClient),
										it calls a factory function from the provider and returns the requested object.
										Anything that has been registered with an NgModule’s providers array is available to be injected in your application code. You can inject anywhere, but I prefer to use the 
										TypeScript approach, as we saw earlier, where the constructor properties are annotated with the specific type of service to inject. 
										Alternatively, you could use the @Inject decorator to inject the Http service, like this:
											constructor(private @Inject(HttpClient) http) {}
	
										This decorator wires up the dependency injection the same way as the TypeScript typing information. Either way you’ll get the same result.
										Providers don’t have to be exposed to the root module and instead can be made visible only to a particular component or component tree.
										
								Change Detection
									https://blog.thoughtram.io/angular/2016/02/22/angular-2-change-detection-explained.html#reducing-the-number-of-checks
									http://teropa.info/blog/2015/03/02/change-and-its-detection-in-javascript-frameworks.html
									https://blog.thoughtram.io/angular/2016/01/22/understanding-zones.html
									http://teropa.info/blog/2015/03/02/change-and-its-detection-in-javascript-frameworks.html
									https://medium.com/codingthesmartway-com-blog/angular-and-redux-ecd22ea53492
									https://vsavkin.com/change-detection-in-angular-2-4f216b855d4c
									https://blog.angularindepth.com/these-5-articles-will-make-you-an-angular-change-detection-expert-ed530d28930
									https://blog.angular-university.io/how-does-angular-2-change-detection-really-work/
									https://medium.com/@bencabanes/angular-change-detection-strategy-an-introduction-819aaa7204e7
									https://blog.angular-university.io/angular-2-redux-ngrx-rxjs/
									https://dzone.com/articles/why-should-you-be-using-redux-with-angular
								
									Change detection is the mechanism for keeping data and the rendered views in sync with one another.
									Changes always come down from the model into the view, and Angular employs a unidirectional propagation of changes from parents down to children. 
									This helps ensure that if a parent changes, any children are also checked, due to potential linked data.
									
									Basically application state change can be caused by three things:

										Events - click, submit, …
										XHR - Fetching data from a remote server
										Timers - setTimeout(), setInterval()
										
										Angular has to know that an asynchronous activity occurred,but setInterval and setTimeout APIs in Javascript occur outside Angular's awareness.
										So Angular use Zone.js that MONKEY-PATCHED the default implementation of setInterval and setTimeout to have them properly trigger Angular change detection when 
										an interval or timeout is resolved.Likewise, when an event binding is handled in Angular, it knows to trigger change detection(monkey-patched method addEventListener).
										One the change detection mechanism is triggered, it will start from the top of the component tree and check each node to see whether the component model has
										changed and requires rendering. That’s why input properties have to be made known to Angular, or it would fail to know how to detect changes.
										Angular has two change detection modes: Default and OnPush.
										You can also use the OnPush mode, which explicitly tells Angular that this component only needs to check for changes if one of the component inputs has changed.
										That means if a parent component hasn’t changed, it’s known that the child component’s inputs won’t change, so it can skip change detection on that component
										
										
										
										
										
									
									
								    ZONES (zone.js)
										https://blog.strongbrew.io/how-the-hell-do-zones-really-work/
										https://blog.angularindepth.com/i-reverse-engineered-zones-zone-js-and-here-is-what-ive-found-1f48dc87659b
										
										A Zone is an execution context that PERSISTS across async tasks. You can think of it as thread-local storage for JavaScript VMs!!!
										When zone.js is loaded
											function zoneAwareAddEventListener() {...}
											function zoneAwarePromise() {...}
											
											window.prototype.addEventListener = zoneAwareAddEventListener;
											window.prototype.promise = zoneAwarePromise;
											
										zone.js overrides some of the functions on the window prototype and replaces the defaults with a proxy.	
										This means that every event scheduled or every promise created after loading the file, will be wrapped in the proxy. This concept is called monkey-patching.
										After that it creates a global property which we can use to access the root Zone.
										
										Zone.current.fork({}).run(function () {
											Zone.current.inTheZone = true;

											setTimeout(function () {
												console.log('in the zone: ' + !!Zone.current.inTheZone);
														}, 0);
										});  <- A NEW ZONE IS CREATED BY FORKING THE ROOT ZONE VIA THE Zone.current
										        CALLING RUN TO RUN SOMETHING INSIDE THIS ZONE.

										console.log('in the zone: ' + !!Zone.current.inTheZone);
										
										'in the zone: false'
										'in the zone: true'   <<<< WHY IF IT POINT TO THE SAME PROPERTY !!!!?
										
										Zone.current.fork({}).run(function () {
											SETUP ZONE :
												trigger : A call to the run function is made.First setup the zone before executing the function param
												actions : Zone.current is set to the Zone in which the function is executed, in this case it is the one created by forking the root zone.
												          zone lifecycles hooks are called.
														  
										 setTimeout(
											...., 0);				  
											
											a timeout is registered.This is not the default timeout since these are monkey-patched.This is calling the proxy.
											THIS PROXY WILL HOLD A REFERENCE TO THE ZONE IN WHICH IT WAS CREATED.
											
										});
											TEARDOWN ZONE
												Zone.current property is reset to the root Zone
												Zone liufecycle hooks are called
												
											Log statement. The Zone.current property is currently pointing to the root Zone. Since this does not know an 'inTheZone' property, this will log false.
												console.log('in the zone: ' + !!Zone.current.inTheZone);	

											// The stack is cleared and the timer callback is executed
											
											SETUP ZONE
											// trigger: The monkey-patched event is fired. The proxy wrapper
											//          will trigger a Zone setup. Remember that the proxy
											//          wrapper holds a reference to the Zone in which it
											//          was created.
											// actions:
											//      - Zone.current property is set to the exampleZone (the
											//        proxy holds a reference to the exampleZone)
											//      - Zone lifecycle hooks are called
										function () {
												// The exampleZone does contain the 'inTheZone'
												// property. So this will log true.
												console.log('in the zone: ' + !!Zone.current.inTheZone);
										}
										
										
										https://blog.angularindepth.com/i-reverse-engineered-zones-zone-js-and-here-is-what-ive-found-1f48dc87659b
										Zones work by associating each async operation with a zone. 
										A developer can take advantage of this binding to:

											Associate some data with the zone, analogous to thread-local storage in other languages, which is accessible to any async operation inside the zone.
											Automatically track outstanding async operations within a given zone to perform cleanup or rendering or test assertion steps
												PROBABLY THE POINT WHERE ANGULAR IS INTERESTED
											Time the total time spent in a zone, for analytics or in-the-field profiling
											Handle all uncaught exceptions or unhandled promise rejections within a zone, instead of letting them propagate to the top level
											
											When using fork we create a new CHILD zone and sets its parent to the zone used for forking
											The object passed to the fork method is called ZoneSpec and defines a name, properties used to associate data with a zone.
											The other properties are interception hooks that allow parent zone intercept certain operations of child zones.
											
										Javascript RunTime
											https://medium.com/@gaurav.pandvia/understanding-javascript-function-executions-tasks-event-loop-call-stack-more-part-1-5683dea1f5ec
											SINGLE THREADED
											
											Call Stack
												https://www.learncpp.com/cpp-tutorial/79-the-stack-and-the-heap/
												Stack Pointer
												Each function call creates one stack frame which contains all the data associated with one function call.
													The address of the instruction beyond the function call(called the return address)
													All function arguments
													Memory for any local variable
													Saved copies of any registers modified by the function that need to be restored when the function returns
											Heap
											Message Queue
												Fullfilled mainly  by browser APIs which are basically threads created by browser implemented in C++ to handle async events like DOM events, http request, setTimeout, etc.
												Now these WebAPIs can’t themselves put the execution code on to the stack, if it did, then it would randomly appear in the middle of your code.
												Any of the WebAPI pushes the callback onto this queue when it’s done executing. The Event Loop now is responsible for the execution of these callbacks in the 
												queue and pushing it in the stack, when it is empty												
											Event loop
												https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/
												Event loop basic job is to look both at the stack and the task queue, pushing the first thing on the queue to the stack when it see stack as empty
												
										TOOLS
											SessionStack
										
										
										
							
						
						
					
				
			
						
							
							
					
				
				
				
				