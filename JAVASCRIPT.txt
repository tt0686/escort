																		
													        JAVASCRIPT					
												ECMASCRIPT(The Core)  DOM   BOM
												
										An host environment provides the base implementation of ECMAScript and implementation EXTENSIONS(like DOM and BOM) designed 
                                        to interface with the environment itself.Extensions,such as the DOM,use ECMAScript core types and syntax to provide additional 
										functionality that is more specific to the environment.		

			DOM Levels
				DOM 1 : DOM Core (Map the structure of an XML-based document to allow for easy access to and manipulation of any part of a document)
						DOM HTML : Extended the Core by adding HTML specific objects and methods
						
				DOM 2 : Support for mouse and user interface events,ranges,traversals(iterate over a DOM document) and support for CSS through object interfaces.
						Support for XML Namespaces.
						Introduces the following new modules of the DOM to deal with the new types of interfaces:
							DOM VIEWS : Describe interfaces to keep track of the various views of a document(the document before and after CSS)
							DOM EVENTS
							DOM STYLE
							DOM TRAVERSAL AND RANGE
				DOM 3 : Methods to Load and Save an document in a uniform way and methods to validate a document
						The Core is extended to support all of XML1.0,including XML Infoset,XPath and XML Base.
						
			
			BOM Deals with browser window and frames but generally any browser-specific extension to Javascript is considered to be part of the BOM.
				Pop up new Browsers Windows
				Move , resize and close browser windows
				Navigator object
				Location object
				Screen object
				Support for cookies
				Custom objects such as XMLHttpRequest or ActiveXObject
				
					NO STANDARD EXISTED FOR THE BOM FOR A LONG TIME,EACH BROWSER HAS ITS OWN IMPLEMENTATION.
					HTML5 TRY TO FIX THAT ISSUE!!!
					
		<script> element
				attributes 
					async   : 
					language
					type
					src
					charset
					defer
				ONE OF THE MOST POWERFUL AND MOST CONTROVERSIAL PARTS OF THE <SCRIPT> ELEMENT IS ITS ABILITY TO INCLUDE JAVASCRIPT FILES FROM OUTSIDE DOMAINS!!!!MUCH LIKE THE IMG ELEMENT.
				INCLUDING ALL JAVASCRIPT FILES IN THE <HEAD> OF A DOCUMENT MEANS THAT ALL OF THE JAVASCRIPT CODE MUST BE DOWNLOADED,PARSED AND INTERPRETED BEFORE THE PAGE BEGINS RENDERING
				(RENDERING BEGINS WHEN THE BROWSER RECEIVES THE OPENING <BODY> TAG).FOR PAGES THAT REQUIRED A LOT OF JAVASCRIPT CODE,THIS CAN CAUSE A NOTICEABLE DELAY IN PAGE RENDERING!!!
				MODERN PAGES TYPICALLY INCLUDE ALL JAVASCRIPT REFERENCES IN THE <BODY> ELEMENT,AFTER THE PAGE CONTENT 
				
					<body>
						<!-- content here -->
						<script type="text/javascript" src="example1.js" />
						<script type="text/javascript" src="example2.js" />
					</body>

					defer : Indicates the script will not be changing the structure of the page as it executes.As such,the script can be run safely after the page the entire page has been parsed.
					        THE DOWNLOAD SHOULD BEGIN IMMEDIATELY BUT EXECUTION SHOULD BE DEFERRED!!!
						     THE SCRIPTS JUST BEGIN TO EXECUTE AFTER THE BROWSER HAS RECEIVED THE CLOSING <HTML> ELEMENT!!!
							NORMALLY THE DEFER SCRIPTS EXECUTE BEFORE THE DOMContentLoaded event has occur but IS NOT GUARANTEED!!!
							
					asyn : Similar to "defer" attribute , only applies to external scripts and signal the browser to begin downloading the file immediately.
						   UNLIKE "defer" scripts marked as async are not guaranteed to execute in the order in which they are specified.
						   SO IT IS IMPORTANT THAT THERE ARE NO DEPENDENCIES BETWEEN THE TWO!!!The purpose of the attribute is to indicate that the page need not wait 
						   for the script to be downloaded and executed before continuing to load and it also need not wait for another script to load and execute before it can do the same.
						   Becauseof this is, it is not recommended that asynchronous scripts not modify the DOM as they are loading.
						   ASYNCHRONOUS SCRIPTS ARE GUARANTEED TO EXECUTE BEFORE THE PAGE LOAD EVENT AND MAY EXECUTE BEFORE OR AFTER DOMContentLoaded
						   
						   PAGE LIFECYCLE :
							DOMContentLoaded    : the browser fully loaded HTML,and the DOM tree is built , but external resources like pictures <img> and stylesheets may be not yet loaded.
							Load                : The browser loaded all resources (images,styles ...)
							beforeunload/unload : When the user leaves the page
							
				DOCUMENT NODES
					Quirks mode   : Omit the doctype at the beginning of the document.Poor practice , quirks mode is very different across all browsers.
					Standard mode : 
									<!--HTML 4.01 Strict-->
									<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
									
									<!-- XHTML 1.0 Strict -->
									<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
									
									<!-- HTML5 -->
									<!DOCTYPE html>
					Almost Standard mode
										Triggered by transitional and frameset doctypes !!!
									<!-- HTML 4.01 Transitional -->
									<!DOCTYPE HTML PUBLIC"-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
									<!-- HTML 4.01 Frameset -->
									<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">
									<!-- XHTML 1.0 Transitional -->
									<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
									<!-- XHTML 1.0 Frameset -->
									<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
									
				Javascript Strict Mode
					To enable strict mode for an entire script 
							"use strict";
					Just a function to execute in strict mode
							function doSomething(){
								"use strict";
								...
							}
							
				The VAR operator makes a variable local to the scope in which was defined !!!!
				OMITING THE VAR OPERATOR TURNS A VARIABLE GLOBAL!!!!
				
		DATA TYPES
				5 simple datatypes : UNDEFINED , NULL , STRING , NUMBER , BOOLEAN [Primitive datatypes]
				[Complex datatype] : Object
				There is no way to define our own data types in ECMAScript.
				Typeof null returns "Object" because the special value NULL is considered to be an empty object reference.
				Typeof returns UNDEFINED in NON DECLARED VARIABLE AND IN VARIABLE NOT INITIALIZE !!!!
				
				Using equality operador (==) between NULL and UNDEFINED always return true!!!This operand converts its operands for comparison purposes.
				Undefined is a derivative of null!!!
				
				Boolean 
					All types of values have booleans equivalents in ECMAScript.To convert a value into its Boolean equivalent,the special Boolean()  casting function is called :
						String 
							  Any non empty string  -> True  Empty string -> False
						Number 
							Any nonzero number(including infinity) -> True 0,NaN -> False
						Object
							Any object -> True Null -> false
						Undefined 
                             None
				Number
					Uses IEEE-754 format to represent both integers and floating-point values.
					Octal
						Leading zero
					Hexadecimal
						0x
					Floating points can be represented using e-notation !!!
						Used to indicate a number that should be multiplied by 10 raised to a given power.
						Floating-point values are accurate up to 17 decimal places but are far less accurate in arithmetic computations than whole numbers.
						We should never test for specific floating point values!!!
					NaN
						Indicate when an operation intended to return a number has failed , for example , dividing any number by 0.
						Any operation involving NaN always returns NaN.
						NaN is not equal to any value, including NaN!!!!
						We should use isNaN function !!!!
					Numbers conversions:
						3 functions
							Number() casting function -> Applied to any object
								Booleans return 1 or 0.
								NULL returns 0.
								Undefined returns NaN
								String
									Strings contain only numbers are converted to decimal values
									String contains floating point converts to floating points
									String contains hexadecimal value converts to an integer that matches the hexadecimal value.
									String empty converts to 0.
									String contains anything other that these previous formats, it is converted into NaN.
								Objects
									valueOf is called and the returned value is converted based on the previous described rules.
									if the conversion results in NaN the toString() method is called and the rules for converting String are applied.
							parseInt()   -> Only applied to Strings
								It is better when converting numbers!!!!
								   parseInt("1234Blue") ---> 1234
								   parseInt("10",2) ---> 2
							parseFloat() -> Only applied to String much more closely to see if it matches a number pattern.
								   Only parses decimal values,there is no radix mode.
								   parseFloat("1234Blue")----> 1234
								   parseFloat("22.5");-------> 22.5
								   parseFloat("22.34.25")----> 22.34
								   parseFloat("0908.5")------> 908.5
				String data type
					REPRESENTS A SEQUENCE OF ZERO OR MORE 16 BIT UNICODE!!!!
					Strings are immutables !!!!
		
		OBJECT IS THE BASE FOR ALL OBJECTS IN ECMASCRIPT!!!
			each object instance has the following properties and methods:
				constructor
				hasOwnProperty
				isPrototypeOf
				prototypeIsEnumerable
				toLocaleString
				toString
				valueOf
				
		Bitwise Operators
			All numbers in ECMAScript are stored in IEEE-754 64 bit-format but the bitwise operators convert the value into a 32 bit integer!!!
				Left Shift preserves the sign number!!
				Signed Right Shift preserves the sign number.
		Boolean Operators
			Logical Not
				May be applied to any value in ECMAScript.Always return a Boolean value.
						If operand is an object,FALSE is returned.
						if operand is an empty String , true is returned.
						non empty String , true is returned
						number 0 -> true
						Any number other than 0 -> False is returned
						null -> true
						NaN -> true
						undefined -> true
						
				Using two NOT operators we get the same result has using Boolean() casting function!!!
			Logical AND
				If the first operand is an object ,then the second operand is always returned.
				If the second operand is an object,then the object is returned only if the first operand evaluates to true.
				IF BOTH OPERANDS ARE OBJECTS,THEN THE SECOND OPERAND IS RETURNED!!!!!
				If either operand is null,then null is returned
				If either operand is NaN, then NaN is returned
				If either operand is undefined,then undefined is returned.
			Logical OR	
				If the first operand is an object ,then the FIRST operand is always returned.
				If the first operand evaluates to false,then the second operand is returned.
				IF BOTH OPERANDS ARE OBJECTS,THEN THE FIRST OPERAND IS RETURNED!!!!!
				If BOTH operand is null,then null is returned
				If BOTH operand is NaN, then NaN is returned
				If BOTH operand is undefined,then undefined is returned.
				
				WE CAN ALSO USE THE OR OPERATOR TO AVOID ASSIGNING A NULL OR UNDEFINED VALUE TO A VARIABLE.
					var myObject = preferredObject || backupObject
					
			Multiplicative Operators 
				Automatic type conversion, use the Number() casting function
			Additive Operators
				Automatic type conversion, use the Number() casting function
				If one operand is a String the other is converted to a String and the result is the concatenation of the two Strings.
		
		Relational Operators
			Both Numbers -> numeric conversion
			Both Strings -> Compare the character codes 
			One operand is Number - > Convert the other operand to a number and perform a numeric comparison.
			One operand is an object -> call valueOf() and use its results to perform the comparison according to the previous rules.If valueOf() is not available,call toString() and use that
			value according to the previous rules.
			Boolean -> convert to Number 
		Equality Operators
			== && !==
				Do conversions before comparison
					If an operand is a boolean -> convert it into a numeric value
					If an operand is a String and the other is a number , attempt to convert the string into a number 
					If one of the operands is an object and the other is not,the valueOf method is called 
					If both are objects , compare the reference !!!
					null and undefined are equal
					NaN is never equal to NaN
					
			=== && !===
				DO NOT DO CONVERSIONS!!!
		Switch Statement
			Has some unique characteristics in ECMAScripts :
				Works with all data types 
				USES THE IDENTICALLY EQUAL OPERATORS!!!!
				Case values need not be constants , can be variables and even expressions
				
					switch("hello world"){
						case "hello" + "world" : ...;break;
						...
					}
					
					var num = 25;
					switch(true){
						case num < 0 : ...;break;
						case num > 0 && num <= 10 ; ...
						....
					}
					
		Function Arguments	
			An ECMAScript function does not care how many arguments are passed in, JUST BECAUSE WE DEFINE A FUNCTION TO ACCEPT TWO ARGUMENTS DOES NOT MEAN WE CAN PASS IN ONLY TWO ARGUMENTS.
			This happens because arguments in ECMAScript are represented as an array internally!!!!
			
			function sayHi(){
				alert(arguments[0]+' '+arguments[1]);
			}
			
			arguments object acts like an array , THOUGH IT IS NOT AN INSTANCE OF ARRAY !!!!!
			arguments values always stay in SYNC with the values of the corresponding NAMED parameters.This effect goes only one way!!!!:changing the named argument does not result in a change to the 
			corresponding value in arguments!!!
			
			Two types of data :
				PRIMITIVE -> null,undefined,Number,String,Boolean
				REFERENCE -> Objects
				
			All function arguments are passed by VALUE !!!!!!	
			
				function setName(obj){
					obj.name = "Nicholas";
					obj = new Object();
					obj.name = "Greg";
				}
				
				var person = new Object();
				setName(person);
				alert(person.name); -> //Nicholas
				
				If the arguments were passed by reference , the person variable will be set with the object containing the "Greg" name;
				
				typeof operator -> determine the object type -> string/boolean/number/undefined/object
				instanceof operator -> Type of Object
				
			EXECUTION CONTEXT
				When code is executed in a context,a scope chain of variable objects is create.The front of the scope chain is always the variable object of the context whose code is executing.
				if the context is a function,then the activation object is used as the variable object!!!An activation object starts with as single defined variable called ARGUMENTS!!!
				THERE ARE ONLY TWO TYPES OF EXECUTION CONTEXTS -> GLOBAL AND FUNCTION
				(The third exists inside of a call to eval())
				When a variable is declared using VAR it is automatically added to the most immediate context available.
				If the VAR keyword is ommitted it becomes accessible in the global context.
				
			GARBAGE COLLECTOR
				Mark and Sweep
				Reference Counting 
					Every value keeps track of how many references are made to it.
					When a variable is declared and a reference value is assigned , the reference count is one.If another variable is assigned the same value,the reference count is incremented.
					When the reference count of a value reaches zero,there is no way to reach that value and it is safe to reclaim the associated memory.
						function problem(){
							var oA = new Object(); // This object has reference count equal to one
							var oB = new Object(); // This object has reference count equal to one
							
							oA.someOther = oB;  //Reference count equal to two
							oB.another = oA;   //Reference count equal to two
						}
					Problem with Circular References 
						In the Mark and Sweep system,this would not be a problem because both objects go out of scope after the function has completed!!!
						
					Not all objects in Internet Explorer are native Javascript objects.Objects in the BOM and DOM are implemented as COM objects in C++, and COM objects use reference counting for garbage collection.
					So even though the IE Javascript engine uses a Mark and Sweep implementation, any COM object that are accessed in Javascript still use reference counting, meaning circular references are still
					a problem when COM objects are involved.
					
				Using OBJECT LITERAL NOTATION property names can be specified as Strings or Numbers

					var person = {
						"name" : "Nicholas",
						"age" : 29,
						5 : true
					};

					We can access object properties through dot notation or through brackets
						alert(person.name);
						alert(person["name"]); -> The main adaventage is the ability to use variables for property access or when the property name contains characters that would be either 
						a syntax error or a reserved keyword
						person["first name"] = "Nicholas";
						
			ARRAY TYPE
				The length property is not READ ONLY, change it will augment or reduce the array.
				There is no array out of bond exception !!!Adding a value to an index bigger the length will augment the array with length equal to the index value!!!
				DETECTING AN ARRAY !!!!
					If there is only one GLOBAL EXECUTION CONTEXT the instanceof operator works well!!!!
					If we are dealing with multiple frames in a web page, we are dealing with two distincts global execution context and therefore two versions of the Array constructor.
					To work around this problem,ECMAScript 5 introduced the Array.isArray() method.
					Iterative methods:
						every()
						filter()
						forEach()
						map()    -----|
						some()        |
									  |->	var numbers = [1,2,3]
											numbers.map(function(item.index.array){return item * 2;}); -> [2,4,6]
					Reduce Methods
						reduce and reduceRight
							Both iterate over all items in the array and build up a value that is ultimately returned.
							var values = [1,2,3];
							var sum = values.reduce(function(prev,cur,index,array){return prev + cur;}); ----> 6
							
			Regular Expressions
				Regular Expressions literals always share the same RegExp instance,while creating a new RegExp via constructor always
				results in a new instance.
					STUDY IN DEPTH!!!!!
					
			FUNCTION TYPE
				Functions are actually objects.Each function is an instance of the Function type that has properties and methods like any other reference type.
					Valid syntax
						var sum = new Function("num1","num2","return num1 + num2");
						
				Function Internals
					Two specials objects exist inside a function : arguments and this!!!
						arguments is an array-like object and has a property named CALLEE,which is a pointer to the function that owns the arguments object.
							function factorial(num){
								if(num <= 1){
									return 1;
								}else{
									return num * arguments.callee(num - 1);
								}	
							}
						
						THIS -> It is a reference to the CONTEXT OBJECT where the function is operating on!!!
						        The value of THIS is not determined until the function is called.
								
					EcmaScript5 also formalizes an additional property on a function object : CALLER !!!
						References the function that called this function or null if the function was called from the global scope.
					
				Functions are objects in ECMAScript , therefore have properties and methods.Each function has two properties :
					LENGTH -> number of named arguments
					PROTOTYPE
					
					Methods
						apply() 
						call()
						bind()
						
						The true power of those methods lies in their ability to augment the THIS value inside of the function:
							
							window.color = "red";
							var o = {color : "blue"}
							
							function sayColor(){
								alert(this.color);
							}
							
							sayColor();  //red
							
							sayColor.call(window);  //red
							sayColor.call(this); //red
							sayColor.call(o); //blue
							
						window.color = "red";
						var o = {color : "blue"};
						
						function sayColor(){
							alert(this.color);
						}
						
						var objectSayColor = sayColor.bind(o);
						objectSayColor(); //blue
						
			PRIMITIVE WRAPPER TYPES
				Every time a primitive value is read, an object of the corresponding primitive wrapper type is created behind the scenes, allowing access to any number of methods for manipulating 
				the data : 
					var s1 = "some text";  ----> PRIMITIVE VALUE!!!!
					var s2 = s1.substring(2);
							 In the second line the substring() method is called, primitive values are not objects , so they should not have methods!!!
							 When s1 is accessed, it is being accessed in READ MODE !!! So the following steps occur :
								1: CREATE AN INSTANCE OF THE STRING TYPE
								2: CALL THE SPECIFIED METHOD ON THE INSTANCE
								3: DESTROY THE INSTANCE
								
						When use the Boolean type in Boolean expressions :
							var falseObject = new Boolean(false);
							var result = falseObject && true; ----> ALL OBJECTS ARE AUTOMATICALLY CONVERTED TO TRUE IN BOOLEAN EXPRESSIONS!!!
							alert(result); //true
							
							var falseValue = false;
							result = falseValue && true;
							alert(result); // false
							
							typeof falseObject -> object
							typeof falseValue  -> boolean
							
							falseObject instanceof Boolean -> true
							falseValue instanceof  Boolean -> false
			
				Types of properties
					Data properties
						[[Configurable]]::Can a property may be redefined by removing the property via delete,changing the property attribute or changing the property into an accessor property
						[[Enumerable]] Returned in the for-in loop
						[[Writable]]::Can a property value be changed
						[[Value]]::The actual value of the property
							Object.defineProperty(person,"name"{
								writable : false,
								value : "Nicholas"
							})
							
							person.name -> "Nicholas"
							person.name = "Greg";
							person.name -> "Nicholas"
							
					Accessor properties
						[[Configurable]]
                        [[Enumerable]]
						[[Get]]
						[[Set]]
							var books = {_year : 2004,
							             edition : 1};
							Object.defineProperty(book,"year",{get : function(){return this._year;},
							                                   set : function(newValue){if(newValue > 2004){this._year = newValue;this.edition += newValue - 2004;}}})

							bok.year  = 2005;
							book.edition -> 2
							
					//Prior to ECMAScript 5, there was two nostandard methods to create accessor properties :
						__defineGetter__() and __defineSetter__()
						
					MULTIPLE PROPERTIES ARE DEFINED THROUGH THE Object.defineProperties()
					READ PROPERY ATTRIBUTES
						Object.getOwnPropertyDescriptor
						
				OBJECT CREATION
					Factory Pattern
						With no way to create classes in ECMAScript,developers created functions to encapsulate the creation of objects with specifics interfaces.
						
							function createPerson(name,age,job){
								var o = new Object();
								o.name = name;
								o.age = age;
								o.job = job;
								o.sayName = function(){alert(this.name);};
								return o;
							}
							PROBLEM ->->->->->-> WHAT TYPE OF OBJECT AN OBJECT IS
					Constructor Pattern
						
						   function Person(name,age,job){
							this.name = name;
							this.age = age;
							this.job = job;
							this.sayName = function(){alert(this.name);};
						   }
						   
						   Calling a constructor in this manner essentially causes the following four steps to be taken :
						   
							1 : Create a new object 
							2 : Assign the THIS value of the constructor to the new object(so THIS points to the new object)
							3 : Execute code inside constructor
							4 : Return the new object
							
							EACH INSTANCE CONTAINS A constructor PROPERTY THAT POINTS BACK TO THE CONSTRUCTOR FUNCTION!!!
							
							DISADVANTAGE : Methods are created once for instance!!!	
							Each instance of Person gets its own instance of Function :
								person1.sayName == person2.sayName -> false
								
								
					Prototype Pattern 
						    
							EACH FUNCTION IS CREATED WITH A PROTOTYPE PROPERTY , WHICH IS AN OBJECT CONTAINING PROPERTIES AND METHODS THAT SHOULD BE AVAILABLE TO INSTANCES OF A PARTICULAR REFERENCE TYPE.
							
							function Person(){}
							
							Person.prototype.name = "Nicholas";
							Person.prototype.age = 29;
							Person.prototype.job = "Software Enginner";
							Person.prototype.sayName = function(){alert(this.name);};
							
							HOW PROTOTYPES WORK
								Whenever a function is created,its PROTOTYPE property  is also created according to a specific set of rules.
								By default,all prototypes automatically get a property called CONSTRUCTOR that points back to the function on which is a property.
								Each time the constructor is called to create a new instance,that instance has an internal pointer to the constructor prototype !!!!
									(There is no standard way to access [[Prototype]] from script,but Firefox, Chrome and Safari support a property on every object called __proto__)
								

							  ----------------------------------------------------------------------------|
							  |->  		PERSON											PERSON PROTOTYPE  |
									prototype ---------------------------------------->constructor -------|
									                                                   name
																					   age            <--------------------------|
																					   job                                       |
																					   ....                                      |
																					                                             |
									person1                                                                                      |
								[[Prototype]]------------------------------------------------------------------------------------|
								
								DISADVANTAGE : All properties are shared among instances!!!
					
					Two methods isPrototypeOf and getPrototypeOf
					
					THE CONSTRUCTOR PROPERTY EXISTS ONLY ON THE PROTOTYPE AND SO IS ACCESSIBLE FROM OBJECT INSTANCES
					
					Once a property is added to the object instance,it shadows any properties of the same name on the prototype.Even setting the property to NULL only sets the property on the instance 
					and does not restore the link to the prototype.The DELETE operator completely removes the instance property and allows prototype property to be acccessed again!!!!
					
					The hasOwnProperty method determines if a property exists on the instance or on prototype
					THE OBJECT.GETOWNPROPERTYDESCRIPTOR() METHOD WORKS ONLY ON INSTANCE PROPERTIES, TO RETRIEVE THE DESCRIPTOR OF A PROTOTYPE PROPERTY WE MUST CALL THE METHOD ON THE PROTOTYPE OBEJCT DIRECTLY.
					
					Object.keys() method retrieves a list of all enumerable instance properties on an object.
					Object.getOwnPropertyNames retrievesa list of all instance properties EITHER ENUMERABLE OR NOT !!!!
					
					Combination Contructor/Prototype Pattern
					
						function Person(name,age,job){
							this.name = name;
							this.age = age;
							this.job = job;
							this.friends = ["Shelby","court"];
						}
						
						Person.prototype = {
							constructor : Person,
							sayName : function (){alert(this.name;)};
						}
						
						THIS PATTERN IS THE MOST WIDELY USED AND ACCEPTED PRACTICE FOR DEFINING CUSTOM REFERENCES TYPES IN ECMASCRIPT !!!!
						
					Dynamic Prototype Pattern
						function Person(name,age,job){
							this.name = name;
							this.age = age;
							this.job = job;
							
							if(typeOf this.sayName != "function"){
								Person.prototype.sayName = function (){alert(this.name);};
							}
						}
					Parasitic Contructor Pattern
						function Person(name,age,job){
							var o = new Object();
							o.name = name;
							o.age = age;
							o.job = job;
							o.sayName = function (){alert(this.name);};
							return o;
						}
						
						WHEN A CONSTRUCTOR DOES NOT RETURN A VALUE,IT RETURNS THE NEW OBJECT INSTANCE BY DEFAULT , ADDING A RETURN STATEMENT AT THE END OF A CONSTRUCTOR ALLOWS US TO OVERRIDE 
						THE VALUE THAT IS RETURNED WHEN THE CONSTRUCTOR IS CALLED.
						
						This pattern allows to create constructors for objects that may not be possible otherwise.
						
						function specialArray(){
							var values = new Array();
							....
						}
					
					Durable Constructor Pattern
						Refer to objects that have no public properties and whose methods do not reference the this object.
						
						function Person(name,age,job){
							var o = new Object();
							
							//optional: define private variables/functions here
							
							//attach methods
							o.sayName = function (){alert(name);}
							
							return o;
						}
						
						INHERITANCE
							Two types of inheritance:
								interface inheritance      :Only the method signatures are inherited (not possible in Javascript , because functions do not have signatures)
								Implementation inheritance : Actual methods are inherited
									PROTOTYPE CHAINING :
										What if the prototype were actually an instance of another type ?
											That would mean the prototype itself would have a pointer to a different prototype that,in turn , would have a pointer to another constructor.
											
								function SuperType(){
									this.property = true;
								}
								
								SuperType.prototype.getSuperValue = function (){return this.property;};
								
								function SubType(){
									this.subproperty = false;
								}
								
								SubType.prototype = new SuperType();
								
								SubType.prototype.getSubValue = function (){return this.subproperty;};
								
								Default prototypes
									In reality, there is another step in the prototype chain.All reference types inherit from Object by default,which is accomplished through prototype chaining.
									The default prototype for any function is an instance of Object,meaning that its internal prototype pointer points to Object.prototype.
									This is how custom types inherit all of the default methods such as toString() and valueOf().
									
						Prototype Chaining has the problem of the prototypes contain references values, they are shared between all instances.

						Combination Inheritance
							Combines prototype chaining and constructor stealing.The basic ideia is to use Prototype Chaining to inherit properties and methods on the prototype and to use constructor stealing to
							inherit  instance properties.
							
							function SuperType(name){
								this.name = name;
								this.colors = ["blue","white","black"];
							}
							
							SuperType.prototype.sayName = function (){alert(this.name);};
							
							function SubType(name,age){
								SuperType.call(name);
								this.age = age;
							}
							
							SubType.prototype = new SuperType();
							SubType.prototype.sayAge(){alert(this.age);};
							
						PROTOTYPAL INHERITANCE
							Method of inheritance that did not involve the use of strictly defined constructors.
							Prototypes allows us to create new objects based on existing objects without the need for defining custom types!!!
							
							function object(o){
								function F(){};
								F.prototype = o;
								return new F();
							}
							
							ECMAScript5 formalizes the concept of prototypal inheritance by adding the Object.create() method.
							
						CLOSURES

							The terms anonymous functions and closures are often incorrectly used interchangeably!
							Closures are functions that have access to variables from another function's scope.
							When a function is called,an execution context and its scope chain is created.The activation object for the function is initialized with the 
							values for ARGUMENTS any named argument.The outer function activation object is the second object in the scope chain.This process continues for all containing 
							functions until the scope chain terminates with GLOBAL execution context.
							Behind the scenes,an object represents the variables in each execution context.The global context variable object always exists,whereas local context variable exist only
							while the function is being executed.When a function is defined,its scope chain is created,preloaded with global variable object and saved to the internal [[Scope]] property.
							When the function is called,an execution context is created and its scope chain is built up by copying the objects in the functions [[Scope]] property.After that an activation object
							(which also acts as an variable object) is created and pushed to the front of the context scope chain.
							
							Whenever a variable is accessed inside a function,the scope chain is searched for a variable with the given name.
							When an inner function is returned, its scope chain has been initialized to contain the activation object from the outer function and the global variable object.
							Another interesting side effect is that the activation object from the outer function cannot be destroyed once the functions finishes executing,because a reference still exists
							in the innner function scope chain.After the outer function completes,the scope chain for its execution context is destroyed,but its activation object still remain in memory until
							the inner function is destroyed.
							THE CLOSURE ALWAYS GETS THE LAST VALUE OF ANY VARIABLE FROM THE CONTAINING FUNCTION, BECAUSE CLOSURES STORES A REFERENCE TO THE ENTIRE VARIABLE OBJECT!!!
							
								function createFunctions(){
									var result = new Array();
									
									for(var i = 0 ; i < 10 ; i++){
										result[i] = function(){ return i;};
									}
									return result;
								}
								
								EVERY FUNCTION RETURNS 10.Since each function has the createFunctions activation object in its scope chain,they are all referring to the same variable "i".
								
								The THIS object 
									When a function is called automatically gets two special variables : THIS & ARGUMENTS
									
									So an inner function can never access these variables directly from an outer function.Workaround :
									
										var name = "The Window";
										
										var object = {
											name : "My Object";
											
											getNameFunc : function(){
												var that = this;
												return function(){
													return that.name;
												};
											}
										};
										
										alert(object.getNameFunc()()); ----> "My Object"
										
							MIMICKING BLOCK SCOPE
								(function(){
									//block code here
								})();
								
								What looks like a function declaration is enclosed in parentheses to indicate that it is actually a function expression!!!!This function is called via the second set of
								parentheses at the end.
								This is equal to this -> 
									var someFunction = function(){
										//block code here
									};
									someFunction();
									
									function(){
										//block code here
									}(); ----> ERROR -> Javascript sees the function keyword as the beginning of a function declaration and function declarations cannot be followed by parentheses.
									Function expressions,however,can be followed by parentheses.To turn the function declaration into a function expressions, we need only surround it with parentheses :
									
									(function(){
										//block code here
									})();
									
									function outputNumbers(count){
										(function(){
											for(var i=0;i < count;i++){
												alert(i);
											}
										})();
										
										alert(i);  ---> ERROR
									}
									
									Private Variables
										
										function MyObject(){
											//private variables and functions
											var privateVariable = 10;
											
											function privateFunction(){
												return false;
											}
											
											this.publicMethod = function(){
												privateVariable++;
												return privateFunction();
											};
										}
										
									THE MODULE PATTERN
										var singleton = function(){
											var privateVariable = 10;
											
											function privateFunction(){
												return false;
											}
											
											return {
												publicProperty : true,
												publicMethod : function(){
													privateVariable++;
													return privateFunction();
												}
											}
										}();
										
					BOM
						Each frame has its own WINDOW object.
						The top object always point to the very top(outermost) framw,which is the browser window itself.
						Any code written within a frame that references the WINDOW object is pointing to that frame's unique instance rather than the topmost one.
						Whenever frames are used,multiple Global objects exist in the browser.Since each window object contains the native type constructor,each frame has its own version of the constructor,
						which are not equal.For example,top.Object is not equal to top.frames[0].Object, which affects the use of instanceof when objects are passed across frames.
						
						Detecting Plug-ins
							Use the plugins array, each item in the array contains the following properties:
								name
								description
								filename -> The filename for the plug-in
								lenght -> Number of Mime Types handle by this plugin
								
								Detecting plug-ins in IE is more problematic,because it does not support Netscape style plug-ins.
								We have to use the proprietary ActiveXObject type and attempt to instantiate a particular plug-in.Plug-ins are implemented in IE using COM objects,which are 
								identified by unique strings.So to check for a particular plug-in, we must know its COM identifier.
								
									function hasIEPlugin(name){
										try{
											new ActiveXObject(name);
										}catch(ex){
											return false;
										}
									}
									
						Registering Handlers
							registerContentHandler() registerProtocolHandler() in NAVIGATOR object.
							Alows a website to indicate that it can handle specific types of information(online RSS readers and online e-mail applications)
							To register a website as a handler of RSS feeds :
								navigator.registerContentHandler("application/rss+xml","http://www.somereader.com?feed=%s","Some reader");
								
								The %s represents the URL of the RSS feed,which the browser inserts automatically.
								
						DOM
							A Document node represents every document as the root.The only child of the document node is the <html> which is called the document element.
							The document element is the outermost element in the document within which all the other elements exist.There can be only one document element per document.
							DOM level 1 describes an interface called Node that is to be implemented by all node types in the DOM.The Node interface is implemented in Javascript as the Node type.
							All node types inherit from Node in Javascript.
							Each node has a childNodes property containing a NodeList.A NodeList is an array-like object used to store an ordered list of nodes that are accessible by position.
							NodeList objects are unique in that they are actually queries being run against the DOM structure,so changes will be reflected in NodeList objects automatically.
							It is often said that a NodeList is a living object rather than a snapshot of what happened at the time it was first accessed.
							
							Javascript represents document nodes via the Document type.In browsers,the document object is an instance of HTMLDocument(which inherits from Document) and represent 
							the entire HTML page.The document object is a property of window.
							One property of document is the domain property.There are some restrictions as to what the value of domain can be set to because of security issues.
							If the URL contains a subdomain,such as p2p.wrox.com,the domain may be set only to "wrox.com".The property can never be set to a domain that the URL does not contain.
							THE ABILITY TO SET DOCUMENT.DOMAIN IS USEFUL WHEN THERE IS A  FRAME OR IFRAME ON THE PAGE FROM A DIFFERENT SUBDOMAIN.PAGES FROM DIFFERENT SUBDOMAINS CAN NOT COMMUNICATE WITH
							ONE ANOTHER VIA JAVASCRIPT BECAUSE OF CROSS-DOMAIN SECURITY RESTRICTIONS.BY SETTING DOCUMENT.DOMAIN IN EACH PAGE TO THE SAME VALUE,THE PAGES CAN ACCESS JAVASCRIPT OBJECTS FROM EACH
							OTHER.
							
							SPECIAL COLLECTIONS
								document.anchors -> All <a> elements with a name attribute
								document.applets
								document.forms
								document.images
								document.links -> All <a> elements with am href attribute
								
						DOM Extensions
								Selectors API
									One of the most capabilities of Javascript libraries is the ability to retrieve a number of DOM elements matching a pattern specified using CSS selectors.
									Indeed,the library jQuery is built completely around the CSS selector queries of a DOM document in order to retrieve references to elements instead of using
									getElementById() and getElementsByTagName().
									
										document.querySelector("#myDiv") -> id 
										document.querySelector("body") -> element
										document.querySelector(".selected") -> class
										document-querySelector("img.button") -> first image with class of "button"
										
										document.querySelectorAll() -> instead of one it return all matching nodes , so it return a static NodeList,the underlying implementation acts as a snapshot of elements
										rather than a dynamic query!!!
										
										matchesSelector()
										
								Html5
									One of the major changes in web development since the time HTML4 was adopted is the increased usage of the "class" attribute to indicate both stylistic and semantic 
									information about elements.This caused a lot of Javascript interaction with CSS classes,including the dynamic changing of classes and querying the document to find elements
									with a given class or set of classes.
									
										getElementByClassName()
										classList property , className contains a single String with all class names separated by white spaces.
										readyState property : Two possible values ("loading","complete")
										Custom Data attributes
											HTML5 allows elements to be specified with nostandard attributes prefixed with "data-" in order to provide information that is not necessary to the 
											rendering or semantic value of the element.
												
													<div id="myDiv" data-appId="12345" data-myname="Nicholas"></div>
													
											Those custom attributes can be accessed via the dataset property of the element.

												var div = document.getElementById("myDiv");
												
												var appId = div.dataset.appId;
												var myName = div.dataset.myname;
												
												Markup Insertion
													innerHTML property
													outerHTML property
													insertAdjacentHTML()
													
														Memory and Performance issues 
															Problem occurs when event handlers or other Javascripts objects are assigned to subtree elements that are removed.
															. If an element has an event handler (or a JavaScript object as a property), and one of these properties is used in such a way that the element 
															is removed from the document tree, the binding between the element and the event handler remains in memory.
															When using innerHTML, outerHTML, and insertAdjacentHTML(), it’s best to manually remove all event handlers and JavaScript object properties 
															on elements that are going to be removed.
															Using these properties does have an upside, especially when using innerHTML. Generally speaking,inserting a large amount of new HTML is more efficient through 
															innerHTML than through multiple DOM operations to create nodes and assign relationships between them. This is because an HTML
															parser is created whenever a value is set to innerHTML (or outerHTML). This parser runs in browser
															level code (often written in C++), which is must faster than JavaScript. That being said, the creation and destruction of the HTML parser does have 
															some overhead, so it’s best to limit the number of times you set innerHTML or outerHTML. For example, the following creates a number of list items
															using innerHTML:
															
																		for (var i=0, len=values.length; i < len; i++){
																				ul.innerHTML += ”<li>” + values[i] + ”</li>”; //avoid!!
																		}
							DOM Level 2 and 3
									XMLNamespace
										XML namespaces allow elements from different XML based languages to be mixed together in a single,well-formed document without fear of element name clashes.
										Technically,XML namespaces are not supported by HTML but supported in XHTML.
											<html xmlns="http://www.w3.org/1999/xhtml">
												<head>
													<title>Example XHTML</title>
												</head>
												<body>
													Hello World!
												</body>
											</html>
										
									For this example,all elements are considered to be part of the XHTML namespace by default.
									We can explicitly create a prefix for an XML namespace using xmlns,followed by a colon :
									
									<xhtml:html xmlns:xhtml="http://www.w3.org/19999/xhtml"> ...
									
									Attributes may also be namespaced to avoid confusion between languages 
									
									<xhtml:body xhtml:class="home">...
									
									Changes to Node 
										Node type evolves in DOM 2 to include the following namespace-specific properties :
										
											localName
											namespaceURI
											prefix
										DOM Level 3
											isDefaultNamespace
											lookupNamespaceURI
											lookupPrefix
									Changes to Document
										createElementNS
										createAttributeNS
										getElementsByTagNameNS
									Changes to Element
										getAttributeNS
										getAttributeNodeNS
										getElementsByTagNameNS
										hasAttributeNS
										removeAttributeNS
										setAttributeNS
										setAttributeNodeNS
										
									Computed Styles
										The style object offers information about the style attribute on any element that supports it but contains no information about the styles that have cascaded from
										style sheets and affect the element.DOM Level 2 Style augments document.defaultView to provide a method called getComputedStyle().
											Accept two arguments :
													element 
													pseudo-element string such (":after")
													
													<style type="text/css">
														#myDiv{
															background-color : blue;
															width : 100px;
															height : 200px;
														}
													</style>
											...
											<body>
												<div id="myDiv" style="background-color:red;border: 1px solid black"
									
									Traversals
									Ranges
									
								EVENTS
									Use the Observer pattern in traditional software engineering,allows a louse coupling between the behaviour of a page(defined in Javascript) and the appearance
									of the page(defined in HTML and CSS).
									
									Event Flow
										Bubbling
											More Specific to the least specific
										Capturing
											Least specific to the more specific,designed to capture the event before it reaches the target!!!
											
										DOM Event Flow specified by DOM Level 2
											Three Phases
												1 Capturing 
												2 Target receives the event
												3 Bubbling
												
										Event Handlers
											HTML Event Handlers
												<input type="button" value="Click Me" onclick="alert('Clicked')"/>
												<input type="button" value="Click Me" onclick="showMessage()"/>
												
												A function is created that wraps the attribute value.That function has a special local variable called event,which is the event object
												
												<input type="button" value="Click Me" onclick="alert(event.type)"/>
												
												The THIS value inside of the function is equivalent to the event's target element 
												
												<input type="button" value="Click Me" onclick="alert(this.value)"/>
												
												Another interesting aspect of this dynamically created function is how it augments the scope chain.Within the function,members of both document and the
												element itself can be accessed as if they were local variables.The function accomplishes this via scope augmentation using WITH:
												
												function(){
													with(document){
														with(this){
															attribute
														}
													}
												}
												
												<input type="button" value="Click Me" onclick="alert(value)"/>
												
												If the element is a form input element,then the scope chain also contains an entry for the parent form element :
												
												function(){
													with(document){
														with(this.form){
															with(this){
																
															}
														}
													}
												}
												
												<input type="button" value="Click Me" onclick="alert(username.value)"/>
												
											DOM Level 0 Event Handlers

												Assigning event handlers using the DOM Level 0 method,the event is considered to be a method of the element.The event is run within the scope of the element,
												meaning that this is equivalent to the element
												
													var btn = document.getElementById("myBtn");
													btn.onclick = function(){alert(this.id);};
													
													EVENT HANDLERS ADDED IN THIS WAY ARE INTENDED FOR THE BUBBLING PHASE OF THE EVENT FLOW!!!
													
											DOM Level 2 Event Handlers
											
													var btn = document.getElementById("myBtn");
													btn.addEventListener("click",function(){alert(this.id);},false); Third argument indicated if is the bubbling phase or the capturing phase
													
													Multiple event can be added :
													
														var btn = document.getElementById("myBtn");
														btn.addEventListener("click", function(){alert(this.id);}, false);
														btn.addEventListener("click", function(){alert("Hello world!");}, false);
														
													Event handlers added via addEventListener() can be removed only by using removeEventListener() and passing in the same arguments as were used when the handler
													was added.	
											
											Internet Explorer Event Handlers

													Internet Explorer implements methods similar to the DOM called attachEvent() and detachEvent().
													These methods accept the same two arguments: the event handler name and the event handler function. Since Internet Explorer 8 and earlier support only 
													event bubbling, event handlers added using attachEvent() are attached on the bubbling phase.
													A major difference between using attachEvent() and using the DOM Level 0 approach in Internet Explorer is the scope of the event handler. 
													When using DOM Level 0, the event handler runs with a this value equal to the element on which it is attached; when using attachEvent(), the event
													handler runs in the global context, so this is equivalent to window.
													Unlike the DOM method, though, the event handlers fire in reverse of the order they were added.
													
											The event object 

												In DOM-compliant browsers, the event object is passed in as the sole argument to an event handler. Regardless of the method used to assign the event handler, 
												DOM Level 0 or DOM Level 2,the event object is passed in. Here is an example:
													
													var btn = document.getElementById("myBtn");
													btn.onclick = function(event){alert(event.type); //"click"};
													btn.addEventListener("click", function(event){alert(event.type); //"click"}, false);
													
												When an event handler is assigned using HTML attributes, the event object is available as a variable called event. Here’s an example:
												
												<input type="button" value="Click Me" onclick="alert(event.type)">
												Providing the event object in this way allows HTML attribute event handlers to perform the same as JavaScript functions.
												
												document.body.onclick = function(event){
													alert(event.currentTarget == document.body);
													alert(this == document.body);
													alert(event.target === document.getElementById("myBtn"));
												}
												
												When the button is clicked,both THIS and currenTarget are equal to document.body because that is where the event handler was registered.The target property 
												is equal to the button element itself,because that is the true target of the click event.
												
												ViewPorts
												
													Device Pixels
														The real pixels.
															Element with 128px:width
															Monitor 1024px wide.
															If we maximize our browser screen,the element will fit on our monitor eigth times.
													Css Pixels
															If the user zooms , the above calculation will change.If the user zooms to 200%, our element 
															will fit only four times on his 1024px wide monitor.
															ZOOMING as implemented in modern browsers consists of nothing more than STRETCHING UP PIXELS!!
															That is, the width of the element is not changed from 128 to 246 pixels,instead the actual pixels are double
															in size.Formally,the element still has a width of 128 CSS pixels,even though it happens to take the space of 256 device pixels.
															Zooming to 200% makes one CSS pixel grow to four times the size of one device pixels(Two times the width, two times the height)!!!
															
														Screen size
															Total width and height of the user's screen,in device pixels because they never change.
														Window size
															Inner dimensions of the browser window(including scroll bars).CSS pixels.
															
													Client Coordinates
														Location of the mouse cursor within the viewport at the time of the event.
													Page Coordinates
														Location of the mouse cursor on the page,so the coordinates are from left and top of the page itself rather than the viewport.
													Screen Coordinates
														Location of the mouse in relation to the entire screen!!!
														
												HTML5 Events
													Pageshow and pagehide events
														Backward-forward cache(bfcache) designed to speed up page transitions when using the browser Back and Forward buttons.The cache stores not only
														page data but also the DOM and Javascript state,effectively keeping the entire page in memory.
													hashchange event
														Notify developers when the URL hash changed.
												Devices Events
													orientationchange event
														 Use the window.orientation
														 The developers could determine when the user switched the device from landscape to portrait mode.
													MozOrientation
														The firefox introduced a this new event	to detect device orientation.
														This event fires periodically as the device accelerometer detects changes in how the device is oriented.
														THIS IS DIFFERENT FROM ORIENTATIONCHANGE IN IOS,WHICH PROVIDES ONLY ONE DIMENSION OF MOVEMENT.
													deviceorientation event
														A device exist in three dimensional space along an x-axis a y-axis and a z-axis.
													devicemotion event 
														Inform us when the device is actually moving,not just when it has changed orientation.
														
													Touch events
													Gesture events
														A gesture occurs when two fingers are touching the screen and typically causes a change in the scale of the displayed item or the rotation.
														
												Memory and performance
													Each function is an object and takes up memory,the more objects in memory,the slower the performance.
														Event delegation
															Takes advantage of event bubbling to assign a single event handler to manage all events of a particular type.
															The click event, for example, bubbles all the way up to the document level.
															
												SIMULATING EVENTS
														Create the event object
														Fire the event through dispachEvent() method.
														
												HTML5 Scripting
													Cross Document Messaging(XDM)
													
														Is the ability to pass information between pages from different origins.For example, a page on www.wrox.com wants to communicate with a page 
														from p2p.wrox.com that is contained in an iframe. Prior to XDM, achieving this communication in a secure manner took a lot of work. XDM formalizes this
														functionality in a way that is both secure and easy to use.
														
														postMessage() -> Pass data into another location
															Accepts two arguments : The data
																					Intended recipient origin VERY IMPORTANT FOR SECURITY REASONS AND RESTRICTS WHERE THE BROWSER WILL 
																					DELIVER THE MESSAGE
																					THIS RESTRICTION PROTECTS OUR INFORMATION SHOULD THE LOCATION OF THE WINDOW CHANGE WITHOUT OUR KNOWLEDGE!!!
														a message event is fired on a window when an XDM message is received.
												
													XDM is extremely useful when trying to sandbox content using an iframe to a different domain.
													The containing page is able to keep itself secure against malicious content by only communicating into an embedded iframe 
													via XDM.In an iframe , the iframe code do not have access to the parent code!!!
														
													Log errors on servers
														
														function logError(sev, msg){
															var img = new Image();
															img.src = "log.php?sev=" + encodeURIComponent(sev) + "&msg=" +
															encodeURIComponent(msg);
														}
														
														The Image object is available in all browsers,even those that do not support the XMLHttpRequest object.
														Cross Domain restrictions do not apply.Often there is one server responsible for handling error logging from multiple servers,
														and XMLHtmlRequest would not work in that situation.
														There is less chance that an error will occur in the process of logging the error.Most Ajax communications is handled through 
														functionality wrappers provided by Javascript libraries.If that library code fails, the message will never get logged.
													
										AJAX and Comet
											Prior to the introduction of XHR(XMLHttpRequest),Ajax-style communication had to be accomplished through a number of hacks, mostly using 
											hidden frames or iframes.
											
											var xhr = createXHR();
											xhr.onreadystatechange = function(){
													if (xhr.readyState == 4){
														if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
															alert(xhr.responseText);
														} else {
															alert("Request was unsuccessful: " + xhr.status);
														}
													}
											};
											xhr.open("get", "example.txt", true);
											xhr.send(null);
											
											One of the major limitations of Ajax communications via XHR is the cross-origin security policy.
											By default,XHR objects can access resources only on the domain from which the containing web page originates!!!!
											Cross Origin Resource Sharing (CORS) is a W3C Working Draft that defines how the browser and server must communicate when accessing sources across origins.
											The basic idea behind CORS is to use custom HTTP headers to allow both the browser and the server to know enough about each other to determine 
											if the request or response should succeed or fail.
											For a simple request, one that uses either GET or POST with no custom headers and whose body is text/plain, the request is sent with an extra header called Origin. 
											The Origin header contains the origin (protocol, domain name, and port) of the requesting page so that the server can easily determine
											whether or not it should serve a response. An example Origin header might look like this:
												Origin: http://www.nczonline.net
											If the server decides that the request should be allowed, it sends an Access-Control-Allow-Origin header echoing back the same origin that was sent 
											or "*" if it’s a public resource. For example:
												Access-Control-Allow-Origin: http://www.nczonline.net
											If this header is missing, or the origins don’t match, then the browser disallows the request. If all is well, then the browser processes the request. 
											Note that neither the requests nor the responses include cookie information.
											
										Preflighted Requests
												CORS allows the use of custom headers, methods other than GET or POST, and different body content types through a transparent mechanism of 
												server verification called preflighted requests.
												When you try to make a request with one of the advanced options, a "preflight" request is made to the server. 
												This request uses the OPTIONS method and sends the following headers:
															Origin — Same as in simple requests.
															Access-Control-Request-Method — The method that the request wants to use.
															Access-Control-Request-Headers — (Optional) A comma-separated list of the custom headers being used.
															
												Here’s an example assuming a POST request with a custom header called NCZ:
												Origin: http://www.nczonline.net
												Access-Control-Request-Method: POST
												Access-Control-Request-Headers: NCZ
												
												During this request, the server can determine whether or not it will allow requests of this type. The server communicates this to the browser by sending 
												the following headers in the response:
													Access-Control-Allow-Origin — Same as in simple requests.
													Access-Control-Allow-Methods — A comma-separated list of allowed methods.
													Access-Control-Allow-Headers — A comma-separated list of headers that the server will allow.
													Access-Control-Max-Age — The amount of time in seconds that this preflight request should be cached for.
															For example:
															Access-Control-Allow-Origin: http://www.nczonline.net
															Access-Control-Allow-Methods: POST, GET
															Access-Control-Allow-Headers: NCZ
															Access-Control-Max-Age: 1728000
															Once a preflight request has been made, the result is cached for the period of time specified in the
															response; you’ll only incur the cost of an extra HTTP request the fi rst time a request of this type is made.
												Credentialed Requests
													By default, cross-origin requests do not provide credentials (cookies, HTTP authentication, and client-side SSL certificates). 
													You can specify that a request should send credentials by setting the withCredentials property to true. If the server allows credentialed requests, 
													then it responds with the following HTTP header:
														Access-Control-Allow-Credentials: true
													If a credentialed request is sent and this header is not sent as part of the response, then the browser doesn’t pass the response to JavaScript 
													(responseText is an empty string, status is 0, and onerror() is invoked). 
													Note that the server can also send this HTTP header as part of the preflight response to indicate that the origin is allowed to send credentialed requests.	

											ALTERNATE CROSS-DOMAIN TECHNIQUES
												Image Pings
													One of the first techniques for cross-domain communication was through the use of the <img> tag. Images can be loaded cross-domain by any page 
													without worrying about restrictions.This is the main way that online advertisements track views.
													var img = new Image();
													img.onload = img.onerror = function(){
														alert("Done!");
													};
													img.src = "http://www.example.com/test?name=Nicholas";
												
													The two main downsides to image pings are that you can only send GET requests and you cannot access the response text from the server. 
													This is why image pings are best used for one-way communication between the browser and the server.
												JSONP
													callback({"name": "Nicholas" });
													The JSONP format is made up of two parts: the callback and the data. The callback is the function that should be called on the page when the response 
													has been received. Typically the name of the callback is specified as part of the request.
														http://freegeoip.net/json/?callback=handleResponse
														
													JSONP is used through dynamic <script> elements, assigning the src to a cross-domain URL. The <script> element, similar to <img>, is capable of loading resources
													from other domains without restriction. Because JSONP is valid JavaScript, the JSONP response gets pulled into the page and executed immediately upon completion. 
													
												Comet
													Describe a more advanced Ajax technique sometimes referred to as server push.Whereas Ajax is described as the page requesting data from the server,
													Comet is described as the server pushing data to the page.
														Two popular approaches to Comet :
														
															Long Polling:
																Browser sends a request to the server in regular intervals to see if there is any data.(Short Polling)
																A page initiates a request to the server and the server holds the connection open until it has data to send.
																Once the data is sent,the connection is closed by the browser and a new connection is immediately opened up to the server.(Long Polling)
																
																The advantage of polling techniques is that all browsers support this through the XHR object and using setTimeout(). 
																You just need to manage when the requests are sent.
																
															HTTP Streaming
																It uses a single HTTP connection for the entire lifetime of the page.The browser sends a request to the server and the server holds 
																that connection open, periodically sending data through the connection to the server.
																All server-side languages support the notion of printing to the output buffer and then flushing
																(sending the contents of the output buffer to the client). This is the core of HTTP streaming.
																The XHR object can be used to achieve HTTP streaming in Firefox, Safari, Opera, and Chrome
																by listening for the readystatechange event and focusing on readyState 3. A readyState of 3
																will fire periodically in all of these browsers as data is being received from the server. At that point,
																the responseText property contains all of the data received, which means you need to slice off the newest piece by keeping track of what was sent previously.
																
															Server Side Events API	
																
															WebSockets
															
																The goal of Web Sockets is to provide full duplex bi directional communication with the server over a single , long lasting connection.
																When a Web Socket is created in JS , an HTTP request is sent to the server to initiate a connection.When a the server responds,the connection
																uses HTTP upgrade to switch from HTTP to the Web Socket protocol.This means that Web Sockets cannot be implemented with a standard HTTP server and must
																use a specialized server supporting the protocol to work properly.
																Since Web Sockets uses a custom protocol,the URL schema is slightly different.Instead of using the http:// or https;// schemas,there are ws:// for 
																an unsecured connection and wss:// for a secured connection.
																The advantage of using a custom protocol over HTTP is that very small amounts of data,unencumbered by the byte overhead of HTTP,can be sent between
																the client and the server.Using smaller data packets makes Web Sockets ideal for mobile applications where bandwidth and latency are a problem.
																The same origin policy does not apply to Web Sockets!!!
																Once opened, we can both send data over and receive data from the connection.
																Web Sockets can only send plain text over the connection, so we will need to serialize more complex data structures before sending them over the connection.
																
																var socket = new WebSocket("ws://...");
																socket.send("Hello World");
																
											Scope Safe Constructors
											Lazy Loading Functions
											Function Binding
											Function Currying
											Tamper prof objects
													Nonextensible objects
														Object.preventExtensions()
														Object.isExtensible()
													Sealed Object
														Object.seal()
														Object.isSealed()
													Frozen Object
														[[Writable]] attribute set to false
														Object.freeze()
														Object.isFrozen()
														
											JAVASCRIPT RUNS IN A SINGLE THREAD ENVIRONEMNT.THE TIMING OF TIMERS EXECUTION IS NOT GUARANTEED~,BECAUSE OTHER CODE MAY CONTROL THE JAVASCRIPT PROCESS AT DIFFERENT 
										    TIMES DURING THE PAGE LIFE CYCLE.CODE RUNNIG WHEN THE PAGE IS DOWNLOADED,EVENT HANDLERS AND AJAX CALLBACKS ALL MUST USE THE SAME THREAD FOR EXECUTION!!!
											ALONG SIDE THE MAIN JAVASCRIPT EXECUTION PROCESS,THERE IS A QUEUE OF CODE THAT SHOULD BE EXECUTED THE NEXT TIME THE PROCESS IS IDLE!!!AS THE PAGE GOES THROUGH ITS 
											LIFE CYCLE,CODE IS ADDED TO THE QUEUE IN THE ORDER IN WHICH IT SHOULD BE EXECUTED.WHEN AN AJAX RESPONSE IS RECEIVED,THE CALLBACK FUNCTION CODE IS ADDED TO THE QUEUE.
											NO CODE IS EXECUTED IMMEDIATELY IN JAVASCRIPT,IT IS EXECUTED AS SOON AS THE PROCESS IS IDLE.
											TIMERS WORK WITH THIS QUEUE BY INSERTING CODE WHEN A PARTICULAR AMOUNT OF TIME HAS PASSED.SETTING A TIMER FOR EXECUTION IN 150 MILLISECONDS DOES NOT MEAN THAT THE 
											CODE WILL BE EXECUTED IN 150 MILLISECONDS,IT MEANS THAT THE CODE WILL BE ADDED TO THE QUEUE IN 150 MILLISECONDS.
											
											REPEATING TIMER
																
																
																
													
											SSO
												Non SSO scenario
													1 User browses to domain1.com
													2 Ask for login info,authenticates user
													3 Stores Cookie
													4 Browses to domain2.com
													5 Ask for login info,authenticates user
													6 Stores Cookie
													
													The obvious solution to this problem is to share session information across different domains.
													For security reasons,browsers enforce a policy known as the same origin policy.This policy dictates that cookies can only be accessed by its creator,
													the domain that originally requested the data to be stored.
													
													Different SSO protocols share session information in different ways,but the  essential concept is the same : there is a central domain!!!,through which
													authentication is performed,and then the session is shared with other domains in some way.
													For instance,the central domain may generate a signed JSON Web Token.
													Whenever the user goes to a domain that requires authentication, it is redirect to the authentication domain.As the user is already logged-in at that domain,
													it can be immediately redirected to the original domain with the necessary authentication token.

													1 User browses to domain1.com
													2 Redirects to Auth0
													3 Either user logs in or cookie is available
													4 Stores cookie if in the previous step user had logged in
													5 Send token and redirects
													6 Uses token to authenticate
													7 Stores domain1.com cookie
													
											Docker
												Basic idea of a Java Application Server is its a JVM process we deploy & undeploy our java code to as a deployment unit(jar/war/ear/bundle).
												So a JVM mutates the code it runs over time.Often Java Application Servers have directories we drop files into or REST/JMX APIs to modify
												the runnig deployments units(Java codes).
												
												It is been common practice for many years in the Java ecosystem that in production we never really un-deploy Java code in a runnig JVM,since is far 
												to easy to leak resources(threads,memory,database connections,sockets...).So to upgrade the version of an application in production its better to 
												spin up a new Application Server process with the new code inside in parallel;move traffic to the new Application server instance and drain traffic 
												from the old instance.
												
												Docker containers are an ideal way to package up applications for easy deployment on linux machine,they use immutable container images for all
												operating system and code they need to use,they are isolated from each other and can have cgroups limits on IO/memory/CPU usage.
												Docker containers can spin up as many instances of a container we like on any machine and they work in a repeatable way since they are based 
												on the same reusable immutable image.A container instance can have its own persistent state mounted on a volume but the code(and possibly configuration)
												comes from an immutable image.
												SO THE DOCKER WAY TO WORK WITH JAVA APPLICATION SERVERS IS TO MAKE AN IMMUTABLE IMAGE FOR THE APPLICATION SERVER AND THE DEPLOYMENTS UNITS WE WHISH 
												TO RUN IN PRODUCTION.
												To upgrade the Java code of a service,rather than dropping a WAR in the webapps/deploy folder or calling a REST/JMX API in the application server or
												whatever,we just make a new image with the new deployment unit inside and run it.
												
												Configuration
													One thing the Java ecosystem has done well since adopting Application Servers is creating immutable binary deployments units(jar/war/ear/bundle),
													releasing them once and moving them between environments.To do that we often delegate to the application server to find resources(e.g lookup in JNDI for JEE)
													for things like discovering where the database is or message broker.Then there would be separate clusters of independently configured application servers 
													which we deployed our artifacts to.
													So it is surprisingly easy to mess up and for different environments to be running different operating systems,Java versions,application server versions or
													mismatched configurations;things may work in our staging environment but if we are not very careful they may fail in production.
													INSTEAD THE DOCKER APPROACH IS TO EXTEND THE IDEA OF IMMUTABLE IMAGES TO THE OPERATING SYSTEM AND APPLICATION SERVER TOO,SO THE EXACT SAME BINARY IMAGE OF THE 
													OPERATING SYSTEM,JAVA RUNTIME,APPLICATION SERVER AND DEPLOYMENT UNITS WOULD BE RUN IN EACH ENVIRONMENT.SO THERE IS NO CHANCE OF HITTING AN ISSUE WITH A 
													MIS-CONFIGURED APPLICATION SERVER IN A CERTAIN ENVIRONEMNT SINCE IT IS THE SAME BINARY IMAGE THAT RUNS EVERYWHERE!!!!
													TO BE ABLE TO DO THIS WELL;HAVING SERVICE DISCOVERY IN EACH ENVIRONMENT IS EXTREMELY USEFUL AS IT MAKES IT REALLY EASY TO RUN THE SAME IMAGE IN EVERY 
													ENVIRONMENT WITHOUT MESSING WITH CONFIGURATION.
													e.g : Things like kubernetes service discovery can make it trivial to run the same binary image in all environments and for services discovery of things
													like databases and message brokers to just work!!!
													
											Rest
												@Path Relative URI Path
													   @Path("/helloworld") -> Static URI  VARIABLES CAN BE EMBEDDED IN THE URIs.URI Path template are URIs variables embedded within the URI syntax.
														public class HelloWorldResource{
															....
															
											MICROSERVICES(CLOUD COMPUTING)
												Before Microservices evolved,most web-based applications were built using monolithic architectural style(Single deployable software artifact).
												A microservice is a small, loosely coupled, distributed service!!!!
												Microservices are the gateway drug for building cloud applications. You start building microservices because they give you a high degree of flexibility and autonomy 
												with your development teams, but you and your team quickly find that the small, independent nature of microservices makes them easily deployable to the cloud. 
												Once the services are in the cloud, their small size makes it easy to start up large numbers of instances of the same service, 
												and suddenly your applications become more scalable and, with forethought, more resilient.
													
												What is exactly the CLOUD ?
													THREE BASIC MODELS EXIST IN CLOUD-BASED COMPUTING :
													
														IaaS(Infrastructure as a Service)
														PaaS(Plataform as a Service)
														SaaS(Software as a Service)
														
														The different cloud computing models come down to who's responsible for what:The cloud vendor or us.
														New cloud platform types are emerging:
															FaaS 
															CaaS(Container as a Services)
																Build and deploy microservices as portable virtual containers(such as Docker) to a cloud provider.
																
																UNLIKE AS IAAS MODEL,WHERE THE DEVELOPER HAVE TO MANAGE THE VIRTUAL MACHINE THE SERVICE IS DEPLOYED TO,WITH CAAS WE ARE 
																DEPLOYING OUR SERVICE IN A LIGHTWEIGHT VIRTUAL CONTAINER.
																THE CLOUD PROVIDER RUNS THE VIRTUAL SERVER THE CONTAINER IS RUNNIG ON AS WELL AS THE PROVIDER'S COMPREHENSIVE TOOLS FOR BUILDING,DEPLOYING,
																MONITORING AND SCALING CONTAINERS.AMAZON ELASTIC CONTAINER SERVICE(ECS) IS AN EXAMPLE OF A CAAS-BASED PLATAFORM.
																
														The advantage of cloud-based microservices centers around the concept of elasticity.
														Cloud service providers allow you to quickly spin up new virtual machines and containers in a matter of minutes!!!!	
														For instance, Amazon, Cloud Foundry, and Heroku give you the ability to deploy your services without having to know about the underlying application container. 
														They provide a web interface and APIs to allow you to deploy your application as a WAR or JAR file. Setting up and tuning the application server and 
														the corresponding Java container are abstracted away from you. While this is convenient, each cloud provider’s platform 
														has different idiosyncrasies related to its individual PaaS solution.
														An IaaS approach, while more work, is portable across multiple cloud providers and allows us to reach a wider audience with our material. 
														Personally, I’ve found that PaaS-based cloud solutions can allow you to quickly jump start your development effort, but once your application 
														reaches enough microservices, you start to need the flexibility the IaaS style of cloud development provides.
														Earlier in the chapter, I mentioned new cloud computing platforms such as Function as a Service (FaaS) and Container as a Service (CaaS). 
														If you’re not careful, FaaS-based platforms can lock your code into a cloud vendor platform because your code is deployed to a vendor-specific 
														runtime engine. With a FaaS-based model, you might be writing your service using a general programming language (Java, Python, JavaScript, and so on), 
														but you’re still tying yourself heavily to the underlying vendor APIs and runtime engine that your function will be deployed to.
														
														Microservices patterns :
														
															Core development patterns
																		Service granularity
																		Communication Protocols
																		Interface Design
																		Configuration management service
																		Event processing between services
															Routing Patterns 
																		The microservice routing patterns deal with how a client application that wants to consume a microservice discovers the location of the service 
																		and is routed over to it. In a cloud-based application, you might have hundreds of microservice instances running. You’ll need to 
																		abstract away the physical IP address of these services and have a single point of entry for service calls so that you can consistently 
																		enforce security and content policies for all service calls.
																			Service discovery
																			Service routing
																				How do you provide a single entry point for all of your services so that security policies and routing rules are applied uniformly 
																				to multiple services and service instances in your microservice applications? 
																				
															Client Resilience Patterns
																Client Side Load Balancing
																Circuit Breakers Pattern 
																	How do we prevent a client from continuing to call a service that is falling or suffering performance problems ?
																Fallback pattern
																	When a service call fails, how do you provide a “plug-in” mechanism that will allow the service client to try to carry out its work through alternative means other than the 
																	microservice being called?
																Bulkhead pattern
																	Microservice applications use multiple distributed resources to carry out their work. How do you compartmentalize these calls so that the misbehavior of one service 
																	call doesn’t negatively impact the rest of the application?
																
															Security Patterns
																Authentication
																Authorization
																Credential Management and propagation
																	Token Based security standards (OAuth2 / JWT)
																
															Logging and tracing patterns
																Log correlation
																Log aggregation
																Microservice tracing
															
															Build/Deployment patterns
																We want the deployment of the microservice and the server it is running on to be one atomic artifact that is deployed as a whole
																between environments
																
																Implementing all these patterns from scratch would be a tremendous amount of work.
																Spring has integrated a wide number of battle-tested open source projects into a Spring subproject collectively known 
																as SPRING CLOUD.
																Spring Cloud wraps the work of open source companies such as Pivotal,HashiCorp and Netflix in delivering patterns.
																Spring Cloud simplifies setting up and configuring of these projects into our Spring Application.
																
																
																Spring Boot is the core technology used in our microservice implementation!!!Greatly simplifies microservice development by simplifying 
																the core tasks of building REST-based microservices.Also simplifies mapping HTTP style verbs to URLs and the serialization of the JSON
																protocol to and from Java objects
																
																Spring Cloud Config
																	Handles the management of application configuration data through a centralized service so our application configuration data is cleanly
																	separated from our deployed microservice.This ensures that no matter how many microservices instances we bring up.they will always have the 
																	same configuration.
																	Spring Cloud Config has its own property management repository,but also integrates with open source projects such as :
																		GIT
																		CONSUL
																		EUREKA
																Spring Cloud Service Discovering
																	CONSUL
																	EUREKA
																For Client Resiliency patterns 
																	Netflix Hystrix
																	Ribbon
																Spring Cloud/Netflix Zuul
																	Provide service Routing capabilities
																	Zuul is a service gateway that proxies service requests and makes sure that all calls to our microservices go through a single "front door"
																	before the targeted service is invoked.With this centralization of service calls, you can enforce standard service policies such as a 
																	security authorization authentication, content filtering, and routing rules.
																Spring Cloud Stream
																	Allows us to easily integrate lightweight message processing into our microservice.
																	With Spring Cloud Stream, you can quickly integrate your microservices with message brokers such as RabbitMQ and Kafka.
																Spring Cloud Sleuth
																	Spring Cloud Sleuth
																	Alows you to integrate unique tracking identifiers into the HTTP calls and message channels (RabbitMQ, Apache Kafka) being used 
																	within your application.
																	
																	
													SPRING 
														Primary features
															Dependency Injection(DI) and Aspect Oriented Programming(AOP)
															Four Strategies:
																POJO Oriented development
																Loose coupling through DI and interface orientation
																Declarative programming through aspects and common convention
																Eliminating boilerplate code with aspect and templates
																
															There are frameworks that lock us in by forcing us to extend one of their classes or implement one of their interfaces.
															(EJB2,Struts)
															Spring avoids littering our application code with its API.
															
															In a Spring-based application,our application objects live in the Spring container.
															Container creates the objects,wires them together,configures them, and manages their complete lifecycle from cradle to grave
															(or new to finalize() as the case may be).There is no single container.Spring comes with several container implementations that can be 
															categorized into two distinct types : 
																1 Bean factories
																2 Application Contexts
																	Build on the notion of a bean factory by providing application-framework services,such as the ability to resolve textual messages from
																	a properties files and the ability to publish application events to interested event listeners.
																	
																Working with Application Context
																	Several Application Context :
																		AnnotationConfigApplicationContext
																		ClassPathXmlApplicationContext
																		FileSystemXmlApplicationContext
																		
																	Load FileSystemXmlApplicationContext
																		ApplicationContext context = FileSystemXmlApplicationContext("C:/knight.xml");
																		
																The difference between using FileSystemXmlApplicationContext and ClassPathXmlApplicationContext is that FileSystemXmlApplicationContext 
																looks for knight.xml in a specific location within the filesystem, whereas ClassPathXmlApplicationContext
																looks for knight.xml anywhere in the classpath (including JAR files).		
																
																Lifecycle of a bean in the bean container
																
																1:Instantiate
																2:Inject values and beans references  into the bean's properties
																3:If the bean implements BeanNameAware,Spring passes the bean's ID to the setBeanName()
																4:                       BeanFactoryAware,Spring calls the setBeanFactory() method , passing in the bean factory itself.
																5:                       ApplicationContextAware setApplicationContext
																6:                       BeanPostProcessor,Spring calls its postProcessorBeforeInitialization() method
																7:                       InitializingBean , afterPropertiesSet
																	if declared with an init-method,then the specified initialization method is called
																8:                       BeanPostProcessor postProcessorAfterInitialization
																9: READY TO BE USED
															   10:                       DisposableBean calls destroys method()
																If declared with a destroy-method the specified method is called.
																
														Spring Configuration Options
															Explicit configuration in XML
															Explicit configuration in Java
															Implicit bean discovery and automatic wiring
															
															
															
																Automatic
																	@Component
																	public claxx X implements I{...
																	
																	@ComponentScan -> DEFAULT TO SCANNING THE SAME PACKAGE AS THE CONFIGURATION CLASS.
																	public class CDPlayerConfig{...
																	The default package is because that way we can keep all of our configuration code in a package of its own,separate from the rest of our application
																	code
																	To specify a different package or more than one we use
																	@ComponentScan("xxxxxx")
																	@ComponentScan(basePackages="xxxx")
																	@ComponentScan(basePackages={"xxxx","ttttt"})
																	USING TYPE-SAFE 
																	@ComponentScan(basePackagesClasses={xxxx.class,yyyy.class})
																		|--->Whatever packages those classes are in will be used as the base package for component scanning.Passw01#
																	
																	alternative we can turn on component scanning through XML
																	<beans>
																		<context:component-scan base-package="x"/>
																	</beans>	
											
												
																	All beans in a Spring application context are given an ID, by default the iID is the name of the .class
																	To explicit give an ID
																	@Component("xxxx")
																	
																	Alternatively we can use the @Named annotation, this annotation is from the JSR-330!!
																	
																	Automatically wired
																		@Autowired
																		public CDPlayer(CompactDisk cd){ //Constructor
																		
																		@Autowired  (required=false) -> If there are no matching beans it will leave the bean unwired.
																		public void setCompactDisc(CompactDisc cd) //Setter method
																		
																	Alternatively we can use the @Inject annotation, this annotation is from the JSR-330!!	
																
																
																Java Configuration
																
																	@Configuration
																	public class CDPlayerConfig {
																		@Bean
																		public CompactDisc sgtPeppers() {
																			return new SgtPeppers();
																		}
																		
																					//By default, the bean will be given an ID that is the same as the @Bean-annotated
																					//method’s name. In this case, the bean will be named compactDisc.
																					//@Bean(name="lonelyHeartsClubBand") -> Different ID
																	
																	
																		@Bean
																		public CDPlayer cdPlayer() {
																			return new CDPlayer(sgtPeppers());
																		}
																					//It appears that the CompactDisc is provided by calling sgtPeppers,but that is not exactly true!!!
																					//Because sgtPeppers() is annotated with @Bean,Spring will intercept any calls to it and ensure that the bean 
																					//produced by that method is returned rather than allowing it to be invoked again!!!
																	}                |
																					 |
																					 |
																					 |
																					 |
																					 |---> For instance
																							@Bean
																							public CDPlayer cdPlayer() {
																								return new CDPlayer(sgtPeppers());
																							}
																							@Bean
																							public CDPlayer anotherCDPlayer() {
																								return new CDPlayer(sgtPeppers());
																							}
																							If the call to sgtPeppers() was treated like any other call to a Java method, then each
																							CDPlayer would be given its own instance of SgtPeppers!!!!
																							By default, all beans in Spring are
																							singletons, and there’s no reason you need to create a duplicate instance for the second
																							CDPlayer bean. So Spring intercepts the call to sgtPeppers() and makes sure
																							that what is returned is the Spring bean that was created when Spring itself called
																							sgtPeppers() to create the CompactDisc bean. Therefore, both CDPlayer beans will
																							be given the same instance of SgtPeppers.
																							
																							Another way that might be easier to digest:
																							@Bean
																							public CDPlayer cdPlayer(CompactDisc compactDisc) {
																								return new CDPlayer(compactDisc);
																							}
																							
																							Here, the cdPlayer() method asks for a CompactDisc as a parameter. When Spring
																							calls cdPlayer() to create the CDPlayer bean, it autowires a CompactDisc into the
																							configuration method. Then the body of the method can use it however it sees fit.
																							With this technique, the cdPlayer() method can still inject the CompactDisc into the
																							CDPlayer’s constructor without explicitly referring to the CompactDisc’s @Bean
																							method.
																							This approach to referring to other beans is usually the best choice because it
																							doesn’t depend on the CompactDisc bean being declared in the same configuration
																							class. In fact, there’s nothing that says the CompactDisc bean even needs to be
																							declared in JavaConfig; it could have been discovered by component scanning or
																							declared in XML. You could break up your configuration into a healthy mix of configuration
																							classes, XML files, and automatically scanned and wired beans.
																	
																	
																XML Configuration
																	<?xml version="1.0" encoding="UTF-8"?>
																	<beans xmlns="http://www.springframework.org/schema/beans"
																	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
																	xsi:schemaLocation="http://www.springframework.org/schema/beans
																	http://www.springframework.org/schema/beans/spring-beans.xsd
																	http://www.springframework.org/schema/context">
																	<!-- configuration details go here -->
																		<bean id="compactDisc" class="soundsystem.SgtPeppers" />
																		
																		<bean id="cdPlayer" class="soundsystem.CDPlayer">
																			<constructor-arg ref="compactDisc" />
																		</bean>   <-------------------------------------------------------------------------
																------>	<bean id="cdPlayer" class="soundsystem.CDPlayer"c:cd-ref="compactDisc" />		    |
																|                                                        ___________________________________|
																|														 |
																|	</beans>											 |
																|														 |
																|		Initializing a bean with constructor injection   |
																|			1 : <constructor-arg> element ----------------
																------------2 : C-namespace
																
																				c:cd-ref  -> named argument (cd)
																				c:_0-ref  -> index argument (0)
																				c:_-ref   -> Only works with one argument
																					THE REF INDICATES THAT IT WILL BE REFERENCING AN BEAN
																					
																				To inject literal values
																					<bean id="compactDisc" class="soundsystem.BlankDisc">
																						<constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" />
																						<constructor-arg value="The Beatles" />
																					</bean>
																					
																					GET ATTENTION THAT WE HAVE REPLACED THE "REF" WORD BY "VALUE"
																					
																					<bean id="compactDisc" class="soundsystem.BlankDisc" c:_title="Sgt. Pepper's Lonely Hearts Club Band"
																					c:_artist="The Beatles" />

																					<bean id="compactDisc" class="soundsystem.BlankDisc" c:_0="Sgt. Pepper's Lonely Hearts Club Band"
																					c:_1="The Beatles" />
																					
																				Wiring Collections
																					<bean id="compactDisc" class="soundsystem.BlankDisc">
																						<constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" />
																						<constructor-arg value="The Beatles" />
																						<constructor-arg>
																						<list>
																							<value>Sgt. Pepper's Lonely Hearts Club Band</value>
																							<value>With a Little Help from My Friends</value>
																							<value>Lucy in the Sky with Diamonds</value>
																							<value>Getting Better</value>
																							<value>Fixing a Hole</value>
																							<!-- ...other tracks omitted for brevity... -->
																						</list>
																						</constructor-arg>
																					</bean>
																					
																					Bean References
																					
																					<bean id="beatlesDiscography" class="soundsystem.Discography">
																						<constructor-arg value="The Beatles" />
																						<constructor-arg>
																						<list>
																							<ref bean="sgtPeppers" />
																							<ref bean="whiteAlbum" />
																							<ref bean="hardDaysNight" />
																							<ref bean="revolver" />
																							...
																						</list>
																						</constructor-arg>
																					</bean>
																					
																						WE COULD USE <SET> INSTEAD OF <LIST>
																						
																				Setting properties in XML instead of Constructor injection
																				
																					public class CDPlayer implements MediaPlayer {
																						private CompactDisc compactDisc;
																						@Autowired
																						public void setCompactDisc(CompactDisc compactDisc) {
																							this.compactDisc = compactDisc;
																						}
																						public void play() {
																							compactDisc.play();
																						}
																					}

																					<bean id="cdPlayer" class="soundsystem.CDPlayer">
																						<property name="compactDisc" ref="compactDisc" />
																					</bean>
																					
																					Like c-namespace to constructor injection there is the p-namespace to
																					method injection
																					
																					<bean id="cdPlayer" class="soundsystem.CDPlayer" p:compactDisc-ref="compactDisc" />
																					
																						util-namespace offers <util:list> to wiring collections in XML
																						
																		IMPORTING AND MIXING CONFIGURATIONS
																		
																			@Configuration
																			public class CDConfig {
																				@Bean
																				public CompactDisc compactDisc() {
																					return new SgtPeppers();
																				}
																			}
																			
																			@Configuration
																			@Import(CDConfig.class)
																			public class CDPlayerConfig {
																				@Bean
																				public CDPlayer cdPlayer(CompactDisc compactDisc) {
																					return new CDPlayer(compactDisc);
																				}
																			}
																			
																			Create a higher-level SoundSystemConfig that uses @Import to bring both configurations together
																			@Configuration
																			@Import({CDPlayerConfig.class, CDConfig.class})
																			public class SoundSystemConfig {
																			}
																			
																			Import beans configured in XML file 
																			@ImportResource("classpath:cd-config.xml")
																			
																			Split XML files and import
																				<import resource="cd-config.xml" />
																			
																			Import 	JavaConfig Class into XML
																			<bean class="soundsystem.CDConfig" />
																			
										PROFILES

											In JavaConfig
													@Profile("prod") at class level
													@Profile("prod") at method level
											In XML
												Define all files
													<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
														   xmlns:jdbc="http://www.springframework.org/schema/jdbc"
														   xsi:schemaLocation="http://www.springframework.org/schema/jdbc
														   http://www.springframework.org/schema/jdbc/spring-jdbc.xsd
														   http://www.springframework.org/schema/beans
														   http://www.springframework.org/schema/beans/spring-beans.xsd"
														   profile="dev">
													At method level
														<beans profile="dev">
															<jdbc:embedded-database id="dataSource">
															<jdbc:script location="classpath:schema.sql" />
															<jdbc:script location="classpath:test-data.sql" />
															</jdbc:embedded-database>
														</beans>
														
												Activating Profiles
													Two separate properties:
														spring.profiles.active
														spring.profiles.default
														
														If neither are set, then there are no active profiles, and only those beans that aren’t defined as being in a profile are created!!!!!!!
														There are several ways to set these properties:
															 As initialization parameters on DispatcherServlet
															 As context parameters of a web application
															 As JNDI entries
															 As environment variables
															 As JVM system properties
															 Using the @ActiveProfiles annotation on an integration test class
										
										Conditional Beans
											@Conditional(MagicExistsCondition.class)
											
											This class must implement the Condition interface
												public interface Condition {
													boolean matches(ConditionContext ctxt,AnnotatedTypeMetadata metadata);
												}
												
												
																public interface ConditionContext {
																	BeanDefinitionRegistry getRegistry();
																		//Check for bean definitions returned from getRegistry()
																	ConfigurableListableBeanFactory getBeanFactory();
																		//Check for the presence of beans,and even dig into beans properties
																	Environment getEnvironment();
																	ResourceLoader getResourceLoader();
																	ClassLoader getClassLoader();
																}
																//Inspect annotations that may also be placed on the @Bean method
																public interface AnnotatedTypeMetadata {
																	boolean isAnnotated(String annotationType);
																	Map<String, Object> getAnnotationAttributes(String annotationType);
																	Map<String, Object> getAnnotationAttributes(
																	String annotationType, boolean classValuesAsString);
																	MultiValueMap<String, Object> getAllAnnotationAttributes(
																	String annotationType);
																	MultiValueMap<String, Object> getAllAnnotationAttributes(
																	String annotationType, boolean classValuesAsString);
																}
																
									Addressing ambiguity
										Designating a primary bean
											@Primary
											In XML
												<bean id="iceCream" class="com.desserteater.IceCream" primary="true" />
												
												This annotation can be applied to more than one bean so could be ambiguous again.
												
										Qualifying
											@Qualifier("iceCream")
											
											This is a prime example of qualifiers in their simplest form. The parameter given to @Qualifier is the ID of the bean that you want to inject.
											All beans are given a default qualifier that’s the same as their bean ID.
											CREATING CUSTOM QUALIFIERS
											Instead of relying on the bean ID as the qualifier, you can assign your own qualifier to a bean. All you need to do is place the @Qualifier annotation on the bean declaration.
											For example, it can be applied alongside @Component like this:
											@Component
											@Qualifier("cold")
											public class IceCream implements Dessert { ... }
											In this case, a qualifier of cold is assigned to the IceCream bean. Because it’s not coupled to the class name, you can refactor the name of the IceCream class all you want
											without worrying about breaking autowiring. It will work as long as you refer to the cold qualifier at the injection point:
											@Autowired
											@Qualifier("cold")
											public void setDessert(Dessert dessert) {
												this.dessert = dessert;
											}
											
											In last case we can create CUSTOM ANNOTATIONS!!!!
											
									Scoping beans
										By default, all beans created in the Spring application context are created as singletons.
										That is to say, no matter how many times a given bean is injected into other beans, it’s always the same instance that is injected each time.
										Spring defines several scopes under which a bean can be created, including the following:
										  Singleton — One instance of the bean is created for the entire application.
										  Prototype — One instance of the bean is created every time the bean is injected into or retrieved from the Spring application context.
										  Session — In a web application, one instance of the bean is created for each session.
										  Request —In a web application, one instance of the bean is created for each request.
										  
										  @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
										  In XML
											<bean id="notepad" class="com.myapp.Notepad" scope="prototype" />
											
										PROBLEM : Inject a Session or Request scoped bean into a Singleton bean 
										
											@Component
											public class StoreService {
											@Autowired
												public void setShoppingCart(ShoppingCart shoppingCart) {
													this.shoppingCart = shoppingCart;
												}
												...
											}
										
											Because StoreService is a singleton bean, it will be created as the Spring application context is loaded. As it’s created, Spring will attempt to inject ShoppingCart into the
											setShoppingCart() method. But the ShoppingCart bean, being session scoped, doesn’t exist yet. There won’t be an instance of ShoppingCart until a user comes
											along and a session is created.Moreover, there will be many instances of ShoppingCart: one per user. You don’t want Spring to inject just any single instance of ShoppingCart 
											into StoreService. You want StoreService to work with the ShoppingCart instance for whichever session happens to be in play when StoreService needs to work with the shopping cart.
											Instead of injecting the actual ShoppingCart bean into StoreService, Spring should inject a proxy to the ShoppingCart bean.
											This proxy will expose the same methods as ShoppingCart so that for all StoreService knows, it is the shopping cart. But when StoreService calls methods on ShoppingCart, the
											proxy will lazily resolve it and delegate the call to the actual session-scoped Shopping-Cart bean.
											As configured, proxyMode is set to ScopedProxyMode.INTERFACES, indicating that the proxy should implement the ShoppingCart interface and delegate to the implementation bean.
											This is fine (and the most ideal proxy mode) as long as ShoppingCart is an interface and not a class. But if ShoppingCart is a concrete class, there’s no way Spring can
											create an interface-based proxy. Instead, it must use CGLib to generate a class-based proxy. So, if the bean type is a concrete class, you must set proxyMode to 
											ScopedProxy-Mode.TARGET_CLASS to indicate that the proxy should be generated as an extension of the target class.
											
											In XML
												<bean id="cart" class="com.myapp.ShoppingCart" scope="session">
													<aop:scoped-proxy />
												</bean>
												
												It tells Spring to create a scoped proxy for the bean.
												By default, it uses CGLib to create a target class proxy. But you can ask it to generate an interface-based proxy by setting the proxy-target-class attribute to false:
												<bean id="cart" class="com.myapp.ShoppingCart" scope="session">
													<aop:scoped-proxy proxy-target-class="false" />
												</bean>
												
												*Proxy (Java)
												
													Two types :
														Pure Java Proxies
															Based on runtime implementations of interfaces
															public final and not abstract
															extend java.lang.reflect.Proxy
															
															Example:
																Suppose we want a List that can not be added elements to it.
																 1 : Create invocation handler
																	 public class NoOpAddInvocationHandler implements InvocationHandler{
																		private final List proxied;
																		
																		public NoOpAddInvocationHandler(List list){
																		  this.proxied = list;
																		}
																		
																		public Object invoke(Object proxy,Method method,Object[] args){
																			if(method.getName().startWith("add")){
																				return false;
																			}
																			method.invoke(proxied,args);
																			
																		}
																	 }
																	 
																2 Create the proxy
																	List proxy = (List) Proxy.newProxyInstance(NoOpAddInvocationHandler.class.getClassLoader(),new Class[]{List.class},new NoOpAddInvocationHandler(list));
																	   Args 1 Classloader
																		    2 array of interfaces that will be implemented by the proxy
																			3 invocation handler
																			
														CGLib proxies
															Java proxies are runtime implementations of interfaces.
															Objects do not necessarily implement interfaces , and collections of objects do not necessarily share the same interface.
															Confronted with such needs,Java proxies fail to provide an answer.
															Here begins the realm of CGLib.CGLib is a thirdy part framework,based on bytecode manipulation provided by ASM that can help with the previous limitations.
															  1 We are not required to implement interfaces
															  2 We can extend a class
															  
															  For example,since Hibernate entities are POJO,Java proxies cannot be used in lazy-loading,CGLib proxies can!!!
															  https://dzone.com/articles/power-proxies-java
															  
														ClassLoaders
															When a class is loaded,all classes it references are loaded too.This class loading pattern happens recursively,until all classes are loaded.
															Classloaders are organized into a hierarchy.When we create a new class loader we must provide it with a parent class loader.
															If a ClassLoader is asked to load a class,it will ask its parent first.If the parent class loader can not find the class , the child class loader 
															then tries to load it itself.
															
															Steps:
																 Check if the class was already loaded.
																 If not loaded, ask parent class loader to load the class.
																 If parent class loader cannot load class, attempt to load it in this class loader.
																 
																 Reloading a class
																	Even with a custom subclass of ClassLoader we have a challenge. Every loaded class needs to be linked. 
																	This is done using the ClassLoader.resolve() method. This method is final, and thus cannot be overridden in your ClassLoader subclass. 
																	The resolve() method will not allow any given ClassLoader instance to link the same class twice. 
																	Therefore, every time we want to reload a class we must use a new instance of your ClassLoader subclass.
																	Every class loaded in Java application is identified by its fully qualified name and classloader instance that loaded it.
																	A class MyObject loaded by class loader A is not the same class as the MyObject class loaded by class loader B.
																	
																	MyObject object = (MyObject) myClassReloadingFactory.newInstance("com.jenkov.MyObject");
					
																	Notice how the MyObject class is referenced in the code, as the type of the object variable. 
																	This causes the MyObject class to be loaded by the same class loader that loaded the class this code is residing in.
																	If the myClassReloadingFactory object factory reloads the MyObject class using a different class loader than the class the above code resides in, 
																	you cannot cast the instance of the reloaded MyObject class to the MyObject type of the object variable. 
																	Since the two MyObject classes were loaded with different class loaders, the are regarded as different classes, even if they 
																	have the same fully qualified class name. Trying to cast an object of the one class to a reference of the other will result in a ClassCastException.

																	It is possible to work around this limitation but you will have to change your code in either of two ways:

																		Use an interface as the variable type, and just reload the implementing class.
																		Use a superclass as the variable type, and just reload a subclass.
																	Here are two coresponding code examples:

																	MyObjectInterface object = (MyObjectInterface)myClassReloadingFactory.newInstance("com.jenkov.MyObject");
																	MyObjectSuperclass object = (MyObjectSuperclass)myClassReloadingFactory.newInstance("com.jenkov.MyObject");
																	
																	Either of these two methods will work if the type of the variable, the interface or superclass, is not reloaded when the implementing class or 
																	subclass is reloaded.

																	To make this work you will of course need to implement your class loader to let the interface or superclass be loaded by its parent. 
															  
												Runtime Value Injection
													 Two ways of evaluating values at runtime :
														Property placeholders
														The Spring Expression Language(SPEL)
														
														@Configuration
														@PropertySource("classpath:/com/soundsystem/app.properties")
														public class ExpressiveConfig{
															
															@Autowired
															Environment env;
															
															@Bean
															public BlankDisc disc(){
																return new BlankDisc(
																	env.getProperty("disc.title"),env.getProperty("disc.artist")
																);
															}
														}
														
														Resolving properties placeholders -------> ${}
															XML	
																<bean id="sgtPeppers" class="soundsystem.BlankDisc"
																c:_title="${disc.title}"
																c:_artist="${disc.artist}" />
														
															When relying on component-scanning and autowiring to create and initialize our application components,there is no configurastion file or class
															where we can specify placeholders.Instead we can use the @Value annotation 
															
															public BlankDisc(
																@Value("${disc.title}") String title,
																@Value("${disc.artist}") String artist) {
																this.title = title;
																this.artist = artist;
															}
															
															In order to use placeholder values, you must configure either a PropertyPlaceholder-Configurer bean or a PropertySourcesPlaceholderConfigurer bean!!
															
															@Bean public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {
																return new PropertySourcesPlaceholderConfigurer();
															}
															
														Wiring with Spring Expression Language
															Spel -----------------> #{}
															
															WHEN INJECTING PROPERTIES AND CONSTRUCTOR ARGUMENTS ON BEANS THAT ARE CREATED VIA COMPONENT-SCANNING WE CAN USE THE @VALUE ANNOTATION(PLACEHOLDERS).
															RATHER THAN USE A PLACEHOLDER EXPRESSION WE CAN USE SPEL EXPRESSION.
															
															public BlankDisc(
																@Value(#{systemProperties['disc.title]}) String title,
																@value(#{systemProperties['disc.artist']} String artist	)
															){...}
															
															Working with types in expressions :
															
																T() operator !!!
																T(java.lang.Math)--> Give us access to static methods and constants
																
																Spel selection operators
																
																	#{jukebox.songs.?[artist eq 'Aerosmith']} --> Subset collection of all Aerosmith songs
																	#{jukebox.songs.^[artist eq 'Aerosmith']} --> First Matching
																	#{jukebox.songs.$[artist eq 'Aerosmith']} --> Last Matching
																	#{jukebox.songs.![title]} -> we do not want a collection of song objects but a collection of song titles.
																	
											Aspect Oriented Spring

												In software development,functions that span multiple points of an application are called CROSS-CUTTING CONCERNS.
												Typically,these cross-cutting concerns are conceptually separate from the application business logic.
												Separating these cross-cutting concerns from the business logic is where aspect oriented programming (AOP) goes to work.
												Dependency injection to manage and configure application objects. Whereas DI helps you decouple application objects from each other, AOP helps you decouple 
												cross-cutting concerns from the objects they affect.
												Aspects offer an alternative to inheritance and delegation that can be cleaner in many circumstances.
												
												Spring aspects can work with five kind of advice :
													Before
													After
													After-Returning
													After-throwing
													Around
													
												Join Points
													A join point is a point in the execution of the application where an aspect can be plugged in.
													Select join points with pointcuts.
													Spring advices are implemented as proxies that wrap the target object.
													
													Multiple Joint-Point models are available through various AOP implementations.Because it is based on dynamic proxies , Spring only supports method join points!!!
													This is in contrast to some other AOP frameworks,such as AspectJ and JBoss,which provide field and constructor join points in addition to method pointcuts.
													Spring's lack of field pointcuts prevents us from creating very fine grained advice,such as intercepting updates to an object's field.And without constructor
													pointcuts,there is no way to apply advice when a bean is instantiated.
													
													
													package concert;
													
													public interface Performance{
															public void perform();
													}
													
													execution(* concert.Performance.perform(..))
													
													Aspect
														
														@Aspect
														public class Audience{
														
															@Before(execution(* concert.Performance.perform(..)))
															public void silenceCellPhones(){
																System.out.......
															}
															
														
														}
														
														Refactoring the Audience class to use just one pointcut expression
														
														@Aspect
														public class Audience{
														
															@Pointcut(execution(* concert.Performance.perform(..)))
															public void performance(){}
															
															@Before("performance()")
															public void silenceCellPhones(){}
														}
														
														TO ENABLE THE ASPECTS IS NOT SUFFICIENT TO USE THE @Aspect ANNOTATION , WE MUST TURN ON AUTO PROXING BY APPLYING THE
														@EnbleAspectJAutoProxy in the configuration class.
														This way Spring will create a proxy around any other beans for which the aspect's pointcuts are a match.
														
														We must use the define the Audience class as a bean either!!!
														
														Using the @Around advice
														
														@Around("performance()")
														public void watchPerformance(ProceedingJointPoint jp){
															...
															...
															jp.proceed();
															..
															..
														}
														
														Access method parameters in the advice
															
															@Pointcut("execution(* soundsystem.CompactDisc.playTrack(int)) && args(trackNumber)")
															public void trackPlayed(int trackNumber) {}
															
															@Before("trackPlayed(trackNumber)")
															public void countTrack(int trackNumber)
												
													
												Annotating introductions

													Some languages, such as Ruby and Groovy, have the notion of open classes. They make it possible to add new methods to an object or class without directly
													changing the definition of those objects or classes.But Java is not dynamic.Once a class has been compiled,there is little we can do to append new functionality.
													Through Aspects we can add new methods through the AOP concept known as INTRODUCTION objects.
													When a method on a introduced interface is called,the proxy delegates the call to some other object that provides the implementation of the new interface.
													
													We want to introduce the Encoreable interface to any implementation of Performance :
													
														public interface Encoreable{
															void performEncore();
														}
														
														Now we need to apply this interface to our Performance implementations :
														
														@Aspect
														public class EncoreableIntroducer{
															@DeclareParents(value="concert.Performance+",defaultImpl=DefaultEncoreable.class)
															public static Encoreable encoreable;
														}
														
								SPRING ON THE WEB

									1 Request leaves the browser
									2 DispatcherServlet(Spring MVC funnels requests through a single front controller servlet)
									3 The DispatcherServlet consults one or more HANDLER MAPPINGS to figure out which controller will receive the request
									4 The DispatcherServlet sends the request to the controller
									  The Controller process the information, a well designed controller performs little or no processing itself and itself delegates responsibility for the business
									  logic to one or more service objects.
									  The information created needs to be sent back to the browser.That information is referred to as the MODEL.But sending raw information to the user is not sufficient
									  it needs to be formatted(typically HTML).
									5 Package the Model data and the logical view name and sent to the DispatcherServlet
									6 The DispatcherServlet consults the ViewResolver to map the logical view to the specific view implementation.
									7 The DispatcherServlet sends the data to the View implementation
									8 The View will use the model data to render output that will be carried back to the client by the Response object.
									
										Servlet 3.0 features
											Annotations to declare Servlets Filter Listeners
											Modularization of web.xml
											Dynamic registration of servlets , filters and listeners at context initialization time(Pluggability)
											Asynchronous support
											Programmatic login and logout
											ServletContainerInitializer <-----
												Just one method : onStartUp
												IMPLEMENTATION MUST BE CONFIGURED IN META-INF/services directory!!!
																	   http://piotrnowicki.com/2011/03/using-servlets-3-0-servletcontainerinitializer/
												Based on Service Provider Interface concept !!!
													This pattern allows the creation of EXTENSIBLES applications USING JAVA SERVICE LOADER.
												Very important links : http://www.logicbig.com/tutorials/core-java-tutorial/java-se-api/service-loader/
																	   https://stackoverflow.com/questions/28131102/how-servlet-container-finds-webapplicationinitializer-implementations
																	   
																	   
									Configure DispatcherServlet
				
							------------------------------------------------------------|                              
							|			public class X extends AbstractAnnotationConfigDispatcherServletInitializer{   
							|			
							|				@Override
							|				protected String[] getServletMappings() {
							|					return new String[] { "/" };         ------> 
							|				}
							|				@Override
							|				protected Class<?>[] getRootConfigClasses() {
							|					return new Class<?>[] { RootConfig.class };  ----> Configure application context created by ContextLoaderListener
							|				}
							|				@Override
							|				protected Class<?>[] getServletConfigClasses() {
							|					return new Class<?>[] { WebConfig.class };   -----> Beans for the DispatcherServlet application context
							|				}
							|			
							|			}
							|			
							|
                             ---------->Servlet 3.0 environment, the container looks for any classes in the classpath that implement the javax.servlet.ServletContainerInitializer interface; 
							 if any are found, they’re used to configure the servlet container.
							Spring supplies an implementation of that interface called SpringServletContainerInitializer that, in turn, seeks out any classes that implement WebApplicationInitializer and delegates 
							to them for configuration. Spring 3.2 introduced a convenient base implementation of WebApplicationInitializer called AbstractAnnotationConfigDispatcherServletInitializer. Because
							your SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer (and thus implements WebApplicationInitializer), it will be automatically discovered when deployed 
							in a Servlet 3.0 container and be used to configure the servlet context.


											In Spring Web Applications there is often two contexts.
											When DispatcherServlet start up,it creates a Spring application context and starts loading it with beans declared in configuration classes.
											With the getServletConfigClasses() we have asked that DispatcherServlet load its application context with beans defined in the WebConfig configuration class.
											The other context is created by ContextLoaderListener.
											The DispatcherServlet is expected to load beans containing web components such as controllers,view resolvers and handler mappings.
											ContextLoaderListener is expected to load the other beans(typically middle tier and data tier components)
											
										ENABLE SPRING MVC
										
										@Configuration
										@EnableWebMvc   <--- Enable Spring MVC
										@ComponentScan("spitter.web") <--- Enable Component Scanning
										public class WebConfig extends WebMvcConfigurerAdapter {
										
											@Bean
											public ViewResolver viewResolver() { <----- Configure a JSP View Resolver
												InternalResourceViewResolver resolver = new InternalResourceViewResolver();
												resolver.setPrefix("/WEB-INF/views/");
												resolver.setSuffix(".jsp");
												resolver.setExposeContextBeansAsAttributes(true);
												return resolver;
											}
											
											@Override
											public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { <--- To avoid DispatcherServlet to treat the request for static resources
												configurer.enable();   																	We forward requests for static resources to the servlet container's default
											}																					        servlet!!!
										}
										
										Controller
										
										@Controller <---We could annotated with @Component , but with @Controller it gains a semantically different meaning
										public class HomeController {
										
											@RequestMapping(value="/", method=GET)
											public String home() {
												return "home";
											}
										}
										
										MOCK TESTS :
											SpringJUnit4ClassRunner -> Creates application context automatically when test starts.
											@ContextConfiguration(classes=CDPlayerConfig.class) -> Where load the configuration file
											
										
										@Controller
										@RequestMapping("/spittles")
										public class SpittleController {
										
											private SpittleRepository spittleRepository;
											
											@Autowired
											public SpittleController(SpittleRepository spittleRepository) {
												this.spittleRepository = spittleRepository;
											}
											
											@RequestMapping(method=RequestMethod.GET)
											public String spittles(Model model) {
												model.addAttribute(spittleRepository.findSpittles(Long.MAX_VALUE, 20));
												return "spittles";
											}
										}
										
											Model is essentially a Map that will be handed off to the view so that data can be rendered to the client.
											when addAttribute is called without specifying a key,the key is inferred from the type of object being set as a value.In this case, because it’s a List<Spittle>, 
											the key will be inferred as spittleList.
											We could be explicit about the model key :
												addAttribute("spittleList",...)
												
											We could either work with a non-Spring type
											public String spittles(Map model)
											
											And finally we can rely on defaults , this the method could be implement simply like that :
											@RequestMapping(method=RequestMethod.GET)
											public List<Spittle> spittles() {
												return spittleRepository.findSpittles(Long.MAX_VALUE, 20));
											}
											WHEN A HANDLER METHOD RETURNS AN OBJECT OR A COLLECTION LIKE THIS,THE VALUE RETURNED IS PUT INTO THE MODEL AND THE MODEL KEY IS INFERRED FROM ITS TYPE.
											THE LOGICAL VIEW IS INFERRED FROM THE REQUEST PATH.
											
											
										Three ways Spring MVC allows a client pass data into a controller :
											Query parameters
												@RequestMapping(method=RequestMethod.GET)
												public List<Spittle> spittles(@RequestParam(value="max",defaultValue=MAX_LONG_AS_STRING) long max,
																			  @RequestParam(value="count", defaultValue="20") int count) {
													return spittleRepository.findSpittles(max, count);
												}
												
											Form parameters
												a form without an action parameter set will be POSTED BACK to the same URL path that displayed it.
												
												@RequestMapping(value="/register", method=POST)
												public String processRegistration(Spitter spitter) {
													spitterRepository.save(spitter);
													return "redirect:/spitter/" + spitter.getUsername(); -----> When InternalResourceViewResolver sees the redirect prefix interpret it as redirect specification 
												}   															instead of a view name.
												
													TO VALIDATE THE FORM SPRING SUPPORT FOR THE JAVA VALIDATION API(a.k.a JSR-303).We just need to make sure an implementation of the Java API,such as 
													Hibernate Validator,is in the project classpath.
													
													public class Spitter{
														
														private Long id;
														
														@NotNull
														@Size(min=5,max=16)
														private String username;
														
														...
													
													}
													
													
													@RequestMapping(value="/register", method=POST)
													public String processRegistration(@Valid Spitter spitter,Errors errors) {
														if (errors.hasErrors()) {
															return "registerForm";
														}	
														...
													}
												
											
											Path parameters
											
												If we want to support for instance the display of a single spittle given its ID, one option is to accept the ID as query parameter 
												using @RequestParam
												
												@RequestMapping(value="/show", method=RequestMethod.GET)
												public String showSpittle(
												@RequestParam("spittle_id") long spittle
												
												This handler method would handle requests such as /spittles/show?spittle_id=12345.
												Although this could be made to work, it’s not ideal from a resource-orientation perspective.
												Ideally, the resource being identified (the Spittle) would be identified by
												the URL path, not by query parameters. As a general rule, query parameters should
												not be used to identify a resource. A GET request for /spittles/12345 is better than one
												for /spittles/show?spittle_id=12345. The former identifies a resource to be retrieved.
												The latter describes an operation with a parameter—essentially RPC over HTTP.
												To accommodate these path variables, Spring MVC allows for placeholders in an @RequestMapping path.
												
												@RequestMapping(value="/{spittleId}", method=RequestMethod.GET)
												public String spittle(
												@PathVariable("spittleId") long spittleId,
												
												Sugar syntax
													If no value attribute is given for @PathVariable, it assumes the placeholder’s name is the same as the method parameter name!!!
												
												handle requests for /spittles/12345
												
												Understanding VIEW RESOLUTION
												
													public interface ViewResolver{
														View resolveViewName(String name,Locale locale) throws Exception;
													}
													
														THIS RETURNS A VIEW INSTANCE :
														
														public interface View{
															String getContentType();
															void render(Map<String,?> model,HttpServletRequest request,HttpServletResponse response);
														}
														
													Spring supports JSP views in two ways :

														InternalResourceViewResolver can be used to resolve view names into JSP files.If we are using JSTL tags in our JSP pages,
														InternalResourceViewResolver can resolve view names into JSP files fronted by JstlView to expose JSTL locale and resource bundle
														variables to JSTL formatting and message tags.
														
														Binding forms to model :
															Use the Spring's form-binding tag library
															
																<%@ taglib uri="http://www.springframework.org/tags/form" prefix="sf" %>
																										_____________________________
																<sf:form method="POST" commandName="spitter">						|
																First Name: <sf:input path="firstName" /><br/>						|
																				<sf:errors path="firstName" cssClass="error"/><br/>	|
																...																	|
																																	|
																@RequestMapping(value="/register", method=GET)						|
																public String showRegistrationForm(Model model) {                   |
																	model.addAttribute(new Spitter());-------------------------------
																	return "registerForm";            The model key will be inferred from the object type
																}
																
																Error messages from property files
																	@NotNull
																	@Size(min=5, max=16, message="{username.size}")
																	private String username;
																	
										SPRING MVC IS A REQUEST (ACTION) BASED FRAMEWORK
										JSF IS A COMPONENT BASED FRAMEWORK
										
										Customizing DispatcherServlet :
										
											After AbstractAnnotationConfigDispatcherServletInitializer registers DispatcherServlet with servlet container,it calls the customizeRegistrattion() method,passing in
											the ServletRegistration.Dynamic that resulted from the servlet registration.By overriding customizeRegistrattion() we can apply additional configuration to DispatcherServlet.
											For instance, configure multipart support:
											
												@Override
												protected void customizeRegistration(Dynamic registration) {
													registration.setMultipartConfig(new MultipartConfigElement("/tmp/spittr/uploads"));
												}
												
												Given the way that AbstractAnnotationConfigDispatcherServletInitializer is defined, it will create a DispatcherServlet and a ContextLoaderListener. But what
												if you want to register additional servlets, filters, or listeners?
												
												Therefore, if you need to register any additional components into the web container, you need only create a new initializer class. The easiest way to do this is by 
												implementing Spring’s WebApplicationInitializer interface.
												
											Multipart Resolver
												DispatcherServlet doesn’t implement any logic for parsing the data in a multipart request. Instead, it delegates to an implementation of Spring’s MultipartResolver
												strategy interface to resolve the content in a multipart request. Since Spring 3.1, Spring comes with two out-of-the-box implementations of MultipartResolver to
												choose from:
												 CommonsMultipartResolver — Resolves multipart requests using Jakarta Commons FileUpload
												 StandardServletMultipartResolver — Relies on Servlet 3.0 support for multipart requests (since Spring 3.1)
												 
												 Thymeleaf
												 
													<form method="POST" th:object="${spitter}" enctype="multipart/form-data">
													...
													<label>Profile Picture</label>:
													<input type="file" name="profilePicture" accept="image/jpeg,image/png,image/gif" /><br/>
													...
													</form>
												 
												 In the Controller 
													@RequestMapping(value="/register", method=POST)
													public String processRegistration(@RequestPart("profilePicture") byte[] profilePicture,@Valid Spitter spitter,Errors errors) {
													...
													}
													
											Advisors Controllers

												Certain aspects of controller classes might be handier if they could be applied broadly across all controllers in a given application. @ExceptionHandler methods, for
												instance, could prove useful in handling exceptions across multiple controllers.
												
											Carrying data across redirect requests
												Typically when a handler method completes,any model data specified in the method is copied into the request as request attributes,and the request is forward
												to the view for rendering.Because it is the same request that is handled by both the controller method and the view,the request attributes survive the forward.
												But when a controller method results in a redirect, the original request ends and a new HTTP GET request begins. Any model data carried in
												the original request dies with the request. The new request is devoid of any model data in its attributes and has to figure it out on its own.
												
													return "redirect:/spitter/" + spitter.getUsername();
													The redirect: prefix makes working with redirects plain and simple!!!
													
												In Servlet specification there is two different paths :

													The sendRedirect() method of HttpServletResponse interface
														The sendRedirect() method works at client side.
														It always sends a new request.
													forward() method of RequestDispatcher
														The forward() method works at server side.
														It sends the same request and response objects to another servlet.
														
												In Spring we have two options:
												
													Passing data as path variables and/or query parameters using URL templates
														Model attributes are ultimately copied into the request as request attributes!!!!
													Sending data in flash attributes
														One option regarding the path and query parameters is to put the data into session!!!
														Spring doesn't think you should be responsible for managing that data.
														Spring offers a way to set flash attributes via RedirectAttributes, a sub-interface of Model added in Spring 3.1.
														
								Spring Web Flow
										
										Spring Web Flow is an extension to Spring MVC that enables development of flow based web applications. It does this by separating the definition of an application’s
										flow from the classes and views that implement the flow’s behavior.
										
										Flow Executor
										Flow Register
											<flow:flow-registry id="flowRegistry" base-path="/WEB-INF/flows">
												<flow:flow-location-pattern value="*-flow.xml" />
											</flow:flow-registry>
											
										Handling flow requests
											As we saw in the previous chapter, DispatcherServlet typically dispatches requests to controllers. But for flows, we need a FlowHandlerMapping to help Dispatcher-Servlet 
											know that it should send flow requests to Spring Web Flow. The FlowHandler-Mapping is configured in the Spring application context like this:
											
											<bean class="org.springframework.webflow.mvc.servlet.FlowHandlerMapping">
												<property name="flowRegistry" ref="flowRegistry" />
											</bean>	
											
										Whereas the FlowHandlerMapping’s job is to direct flow requests to Spring Web Flow, it’s the job of a FlowHandlerAdapter to answer that call. A FlowHandlerAdapter
										is equivalent to a Spring MVC controller in that it handles requests coming in for a flow and processes those requests. The FlowHandlerAdapter is wired as a Spring bean
										like this:
											<bean class="org.springframework.webflow.mvc.servlet.FlowHandlerAdapter">
												<property name="flowExecutor" ref="flowExecutor" />
											</bean>	
										
										FLOW COMPONENTS
											States
												Action
												Decision
												End
												Subflow
												View
											Transitions
												Transitions connect the states within a flow.
												Transitions are defined to take place on some event being fired.
													<transition on="phoneEntered" to="lookupCustomer"/>
													
												GLOBAL TRANSITIONS
													<global-transitions>
														<transition on="cancel" to="endState" />
													</global-transitions>
													
											SCOPING FLOW DATA
												Conversation
												Flow
												Request
												Flash
												View
										
										                                   (CustomerReady)           (orderCreated)           (paymentTaked)
											START---------Identify Customer---------------buildOrder---------------takePayment---------------saveOrder----------thank customer--------END
											
											<?xml version="1.0" encoding="UTF-8"?>
											<flow xmlns="http://www.springframework.org/schema/webflow" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
											xsi:schemaLocation="http://www.springframework.org/schema/webflow http://www.springframework.org/schema/webflow/spring-webflow-2.3.xsd">
												<var name="order" class="com.springinaction.pizza.domain.Order"/>
												<subflow-state id="identifyCustomer" subflow="pizza/customer">
													<output name="customer" value="order.customer"/>
													<transition on="customerReady" to="buildOrder" />
												</subflow-state>
												<subflow-state id="buildOrder" subflow="pizza/order">
													<input name="order" value="order"/>
													<transition on="orderCreated" to="takePayment" />
												</subflow-state>
												<subflow-state id="takePayment" subflow="pizza/payment">
													<input name="order" value="order"/>
													<transition on="paymentTaken" to="saveOrder"/>
												</subflow-state>
												<action-state id="saveOrder">
													<evaluate expression="pizzaFlowActions.saveOrder(order)" />
													<transition to="thankCustomer" />
												</action-state>
												<view-state id="thankCustomer">
													<transition to="endState" />
												</view-state>
												<end-state id="endState" />
												<global-transitions>
													<transition on="cancel" to="endState" />
												</global-transitions>
											</flow>
											
											thankCustomer
												...
												<a href='${flowExecutionUrl}&_eventId=finished'>Finish</a>
												
												flowExecutionUrl variable, which contains the URL for the flow, for use in the view. The Finish link attaches an _eventId parameter to the
												URL to fire a finished event back to the web flow.
												
												
												
												SubFlow "identifyCustomer"
												                           (phoneEntered)                        (CustomerNotFoundException)
												START------------welcome--------------------------lookupCustomer-----------------------registrationForm--------------------------------
												                    |                                   |                                    |                                        |
																	|									|									 |										  |
																	|									|									 |                                        |
																	|									|									 |                                        |
																	|									|									 |                                        |
																	|									|								CheckDeliveryArea------------                 |
																	|									|									 |  true                |   false         |Cancel  
																	|									|									 |                      |                 |
																	|									|									 |       (Accept)       |                 |
																	|							CUSTOMERREADY<----------------------- addCustomer<----------deliveryWarning           |
																	|																	     |                                        |
																	|																		 |                                        |
																	|																		 |                                        |
																	|																		 |Cancel                                  |
																	|							Cancel        								 |                                        |
																	|--------------------------------------------------------------------->CANCEL<------------------------------------
													
													<?xml version="1.0" encoding="UTF-8"?>
													<flow xmlns="http://www.springframework.org/schema/webflow" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
													xsi:schemaLocation="http://www.springframework.org/schema/webflow http://www.springframework.org/schema/webflow/spring-webflow-2.3.xsd">
														<var name="customer" class="com.springinaction.pizza.domain.Customer"/>
														<view-state id="welcome">
															<transition on="phoneEntered" to="lookupCustomer"/>
														</view-state>
														<action-state id="lookupCustomer">
															<evaluate result="customer" expression= "pizzaFlowActions.lookupCustomer(requestParameters.phoneNumber)" />
															<transition to="registrationForm" on-exception="com.springinaction.pizza.service.CustomerNotFoundException" />
															<transition to="customerReady" />
														</action-state>
														<view-state id="registrationForm" model="customer">
															<on-entry>
																<evaluate expression="customer.phoneNumber = requestParameters.phoneNumber" />
															</on-entry>
															<transition on="submit" to="checkDeliveryArea" />
														</view-state>
														<decision-state id="checkDeliveryArea">
															<if test="pizzaFlowActions.checkDeliveryArea(customer.zipCode)" then="addCustomer" else="deliveryWarning"/>
														</decision-state>
														<view-state id="deliveryWarning">
															<transition on="accept" to="addCustomer" />
														</view-state>
														<action-state id="addCustomer">
															<evaluate expression="pizzaFlowActions.addCustomer(customer)" />
															<transition to="customerReady" />
														</action-state>
														<end-state id="cancel" />
														<end-state id="customerReady">
															<output name="customer" />
														</end-state>
														<global-transitions>
															<transition on="cancel" to="cancel" />
														</global-transitions>
													</flow>
													
													
									Securing Web Applications

												Spring Security, a security framework implemented with Spring AOP and servlet filters.
												To secure web requests and restrict access at the URL level, Spring Security uses servlet filters. Spring Security can also secure method invocations 
												using Spring AOP, proxying objects and applying advice to ensure that the user has the proper authority to invoke secured methods.
												
												Filtering Web Requests
												
													Configuring in web.xml
														<filter>
															<filter-name>springSecurityFilterChain</filter-name>
															<filter-class>
																org.springframework.web.filter.DelegatingFilterProxy
															</filter-class>
														</filter>
														
														In Java
														
														Create a new class that extends AbstractSecurityWebApplicationInitializer:

															package spitter.config;
															import org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer;
															
															public class SecurityWebInitializer extends AbstractSecurityWebApplicationInitializer {}
															
															AbstractSecurityWebApplicationInitializer implements WebApplicationInitializer, so it will be discovered by Spring 
															and be used to register DelegatingFilterProxy with the web container.
															Although you can override its appendFilters() or insertFilters() methods to register filters of your own choosing, you need not
															override anything to register DelegatingFilterProxy.
															Whether you configure DelegatingFilterProxy in web.xml or by subclassing AbstractSecurityWebApplicationInitializer, it will intercept requests coming
															into the application and delegate them to a bean whose ID is springSecurityFilterChain<---Very important
															
															As for the springSecurityFilterChain bean itself,it is another special filter known as FilterChainProxy,it is a single filter that chains together
															one or more additional filters.
															Spring Security relies on several servlet filters to provide different security features, but you should almost never need to know these details, as you likely
															won't need to explicitly declare the springSecurityFilterChain bean or any of the filters it chains together. 
															Those filters will be created when you enable web security.
															
														Configure Security Configuration

															@Configuration
															@EnableWebSecurity
															public class SecurityConfig extends WebSecurityConfigurerAdapter {
															}
															
														Spring Security must be configured in a bean that implements WebSecurityConfigurer or (for convenience) extends WebSecurityConfigurerAdapter. 
														Any bean in the Spring application context that implements WebSecurityConfigurer can contribute to Spring Security configuration, but it's often most
														convenient for the configuration class to extend WebSecurityConfigurerAdapter.
														@EnableWebSecurity is generally useful for enabling security in any web application.But if we happen to be developing a Spring MVC application, we should consider
														using @EnableWebMvcSecurity.
														Among other things, the @EnableWebMvcSecurity annotation configures a Spring MVC argument resolver so that handler methods can receive the authenticated user’s
														principal (or username) via @AuthenticationPrincipal-annotated parameters. It also configures a bean that automatically adds a hidden cross-site request forgery
														(CSRF) token field on forms using Spring’s form-binding tag library.
														
														Overriding WebSecurityConfigurerAdapter configure methods :
															
																configure(WebSecurity)
																	Override to configure Spring Security’s filter chain.
																configure(HttpSecurity)
																	Override to configure how requests are secured by interceptors.
																configure(AuthenticationManagerBuilder)
																	Override to configure user-details services.
																	
														USER STORE

															In Memory
																@Override
																protected void configure(AuthenticationManagerBuilder auth) throws Exception {
																	auth.inMemoryAuthentication().withUser("user").password("password").roles("USER").and().withUser("admin").password("password").roles("USER", "ADMIN");
																}
															Database
																@Autowired
																DataSource dataSource;
																@Override
																protected void configure(AuthenticationManagerBuilder auth) throws Exception {
																	auth.jdbcAuthentication().dataSource(dataSource);
																}
																
																IT MAKES SOME ASSUMPTIONS ABOUT YOUR DATABASE SCHEMA!!!
																
																Alternative
																	.usersByUsernameQuery("select username, password, true from Spitter where username=?")
																	
																WORKING WITH ENCODED PASSWORDS

																	auth.jdbcAuthentication().dataSource(dataSource).usersByUsernameQuery("select username, password, true from Spitter where username=?")
																	.authoritiesByUsernameQuery("select username, 'ROLE_USER' from Spitter where username=?").passwordEncoder(new StandardPasswordEncoder("53cr3t"));
																	
																	The passwordEncoder method accepts any implementation of Spring Security’s PasswordEncoder interface. Spring Security’s cryptography module includes
																	three such implementations: BCryptPasswordEncoder, NoOpPasswordEncoder, and StandardPasswordEncoder.
																	We can always provide your own custom implementation!!!
																	
																	public interface PasswordEncoder {
																		String encode(CharSequence rawPassword);
																		boolean matches(CharSequence rawPassword, String encodedPassword);
																	}
																	
																	No matter which password encoder you use, it’s important to understand that the password in the database is never decoded. 
																	Instead, the password that the user enters at login is encoded using the same algorithm and is then compared with the encoded
																	password in the database. That comparison is performed in the PasswordEncoder’s matches() method.
																	
																	CUSTOM USER SERVICE
																	
																	public interface UserDetailsService {
																		UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
																	}
																	
																	@Autowired
																    SpitterRepository spitterRepository;

																	@Override
																	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
																		auth.userDetailsService(new SpitterUserService(spitterRepository));
																	}
																	
															Security Requests
																@Override
																protected void configure(HttpSecurity http) throws Exception {
																	http.authorizeRequests().antMatchers("/spitters/me").authenticated().antMatchers(HttpMethod.POST, "/spittles").authenticated().anyRequest().permitAll();
																}
																
																Most methods are one-dimensional,we can use hasRole() to require a certain role,but we can not also use hasIpAddress() to require a specific
																IP address on the same path.
																Using access() method we can also use SPEL as a means for declaring access requirements.
																
																	.antMatchers("/spitter/me").access("hasRole('ROLE_SPITTER')")
																	.antMatchers("/spitter/me").access("hasRole('ROLE_SPITTER') and hasIpAddress('192.168.1.2')")
																	
																In addition to the authorizeRequests() method, the HttpSecurity object passed into configure() has a requiresChannel() method that lets you declare channel
																requirements for various URL patterns.
																
																@Override
																protected void configure(HttpSecurity http) throws Exception {
																	http.authorizeRequests().antMatchers("/spitter/me").hasRole("SPITTER").antMatchers(HttpMethod.POST, "/spittles").hasRole("SPITTER")
																	.anyRequest().permitAll().and().requiresChannel().antMatchers("/spitter/form").requiresSecure();
																}
																
																Spring Security implements CSRF protection with a synchronizer token. State changing requests (for example, any request that is not GET, HEAD, OPTIONS, 
																or TRACE) will be intercepted and checked for a CSRF token. If the request doesn’t carry a CSRF token, or if the token doesn’t match the token on 
																the server, the request will fail with a CsrfException.
																
															Remember me functionality
															
												Spring in the backend
															
															Spring data access

																Service Object ----------------------------->   Repository Interface
																														^
																														|
																														|
																														|
																														|
																														|
																														|
																														|
																												Repository Implementation


															Templating Data Access
															
																Template Method Pattern
																	A template method defines the skeleton of a process.
																	Implements the fixed parts and the variable parts delegates to implementation-specific portions of the process to an interface.
																	Spring separates the fixed and variable parts of the data-access process into two distinct classes: templates and callbacks.
																	Templates manage the fixed part of the process, whereas your custom data-access code is handled in callbacks.
																	
																	
																Defining a datasource
																	Data sources that are defined by a JDBC driver
																	Data sources that are looked up by JNDI
																	Data sources that pool connections
																	
																	
												How JDBC works
													The JDBC specification requires that compliant drivers register themselves with java.sql.DriverManager when they are loaded(using static initializers blocks).
													Starting from JDBC 4.0(JDK6),JDBC drivers are required to specify a services definition declaring all java.sql.Driver implementations provided by 
													the driver (usually one). This is done through a file META-INF/services/java.sql.Driver.
													The DriverManager will query all instances of this file on the classpath (using java.util.ServiceLoader and load all driver implementations contained in these files. 
													As a (compliant) driver is required to register itself, all these implementations are now registered with DriverManager.
													IT USE THE SERVICE PROVIDER INTERFACE!!!!!READ ABOUT IT.
													
													Because of its properties, a DataSource object is a better alternative than the DriverManager class for getting a connection. Programmers no longer have to hard code 
													the driver name or JDBC URL in their applications, which makes them more portable. Also, DataSource properties make maintaining code much simpler. 
													If there is a change, the system administrator can update data source properties and not be concerned about changing every application that makes a connection to 
													the data source. For example, if the data source were moved to a different server, all the system administrator would have to do is set the serverName property 
													to the new server name.
													Aside from portability and ease of maintenance, using a DataSource object to get connections can offer other advantages. When the DataSource interface is 
													implemented to work with a ConnectionPoolDataSource implementation, all of the connections produced by instances of that DataSource class will automatically 
													be pooled connections. Similarly, when the DataSource implementation is implemented to work with an XADataSource class, all of the connections it produces 
													will automatically be connections that can be used in a distributed transaction. The next section shows how to deploy these types of DataSource implementations.
													
													https://docs.oracle.com/javase/tutorial/jdbc/basics/sqldatasources.html
																	
																	JNDI
																		XML
																			<jee:jndi-lookup id="dataSource" jndi-name="/jdbc/SpitterDS" resource-ref="true" />
																				If the application is running in a Java application server, you’ll want to set the resource-ref property to true so that the 
																				value given in jndi-name will be prepended with java:comp/env/.
																		JAVA
																			@Bean
																			public JndiObjectFactoryBean dataSource() {
																				JndiObjectFactoryBean jndiObjectFB = new JndiObjectFactoryBean();
																				jndiObjectFB.setJndiName("jdbc/SpittrDS");
																				jndiObjectFB.setResourceRef(true);
																				jndiObjectFB.setProxyInterface(javax.sql.DataSource.class);
																				return jndiObjectFB;
																			}
																	Pooled Connections		
																			Most of these connection pools can be configured as a data source in Spring in a way that resembles Spring’s own DriverManagerDataSource or 
																			SingleConnectionDataSource
																			
																			XML
																				<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
																				p:driverClassName="org.h2.Driver"
																				p:url="jdbc:h2:tcp://localhost/~/spitter"
																				p:username="sa"
																				p:password=""
																				p:initialSize="5"
																				p:maxActive="10" />
																			JAVA
																				@Bean
																				public BasicDataSource dataSource() {
																					BasicDataSource ds = new BasicDataSource();
																					ds.setDriverClassName("org.h2.Driver");
																					ds.setUrl("jdbc:h2:tcp://localhost/~/spitter");
																					ds.setUsername("sa");
																					ds.setPassword("");
																					ds.setInitialSize(5);
																					ds.setMaxActive(10);
																					return ds;
																				}
																				
																	JDBC driver based data sources

																		DriverManagerDataSource
																			Returns a new connection every time a connection is requested. Unlike DBCP’s BasicDataSource, the connections provided
																			by DriverManagerDataSource aren't pooled.
																		SimpleDriverDataSource
																			Works much the same as DriverManagerDataSource except that it works with the JDBC driver directly to overcome class loading
																			issues that may arise in certain environments, such as in an OSGi container.
																		SingleConnectionDataSource
																			Returns the same connection every time a connection is requested. Although SingleConnectionDataSource isn’t exactly
																			a pooled data source, you can think of it as a data source with a pool of exactly one connection.
																			
																		Example
																			@Bean
																			public DataSource dataSource() {
																				DriverManagerDataSource ds = new DriverManagerDataSource();
																				ds.setDriverClassName("org.h2.Driver");
																				ds.setUrl("jdbc:h2:tcp://localhost/~/spitter");
																				ds.setUsername("sa");
																				ds.setPassword("");
																				return ds;
																			}
																			
																			public Spitter findOne(long id) {
																				return jdbcOperations.queryForObject(SELECT_SPITTER_BY_ID, new SpitterRowMapper(),id);
																			}
																			
																			private static final class SpitterRowMapper implements RowMapper<Spitter> {
																				public Spitter mapRow(ResultSet rs, int rowNum) throws SQLException {
																					return new Spitter(
																									rs.getLong("id"),
																									rs.getString("username"),
																									rs.getString("password"),
																									rs.getString("fullName"),
																									rs.getString("email"),
																									rs.getBoolean("updateByEmail"));
																				}
																			}
																			
																			Because the RowMapper interface only declares the addRow() method, it fits the bill for a functional interface. 
																			This means that if you’re developing your application using Java 8, you can express the RowMapper implementation with a lambda instead of 
																			with a concrete class implementation.
																			The findOne() method can be rewritten using Java 8 lambdas like this:
																			
																				public Spitter findOne(long id) {
																					return jdbcOperations.queryForObject(
																						SELECT_SPITTER_BY_ID,(rs, rowNum) -> {
																							return new Spitter(
																								rs.getLong("id"),
																								rs.getString("username"),
																								rs.getString("password"),
																								rs.getString("fullName"),
																								rs.getString("email"),
																								rs.getBoolean("updateByEmail"));
																							},
																						id);
																				}
																				
																				Method references
																					public Spitter findOne(long id) {
																						return jdbcOperations.queryForObject(SELECT_SPITTER_BY_ID, this::mapSpitter, id);
																					}
																					
																					private Spitter mapSpitter(ResultSet rs, int row) throws SQLException {
																					return new Spitter(
																						rs.getLong("id"),
																						rs.getString("username"),
																						rs.getString("password"),
																						rs.getString("fullName"),
																						rs.getString("email"),
																						rs.getBoolean("updateByEmail"));
																					}
																					
																Persisting data with object-relational mapping
																	Lazy Loading
																	Eager Fetching
																	Cascading
																	Caching
																	
																	Hibernate
																		Interface to work with Hibernate is org.hibernate.Session(provides basic data-access functionality like save,update and load.
																		To get a reference to Session is through an implementation of SessionFactory interface.
																		In Spring to get an SessionFactory is through session-factory beans.
																		
																		@Bean
																		public LocalSessionFactoryBean sessionFactory(DataSource dataSource) {
																			LocalSessionFactoryBean sfb = new LocalSessionFactoryBean();
																			sfb.setDataSource(dataSource);
																			sfb.setPackagesToScan(new String[] { "com.habuma.spittr.domain" });
																			Properties props = new Properties();
																			props.setProperty("dialect", "org.hibernate.dialect.H2Dialect");
																			sfb.setHibernateProperties(props);
																			return sfb;
																		}
																		
																		
																		@Repository -->
																			One of Spring’s stereotype annotations that, among other things, are scanned by Spring component-scanning. This means you
																			won't have to explicitly declare a HibernateSpitterRepository bean, as long as the repository class is in a package covered by component-scanning.
																			In addition to helping to reduce explicit configuration, @Repository serves another purpose. Recall that one of the jobs of a template class 
																			is to catch platform specific exceptions and rethrow them as one of Spring’s unified unchecked exceptions.
																			But if you’re using Hibernate contextual sessions and not a Hibernate template, how can the exception translation take place?
																			To add exception translation to a template-less Hibernate repository, you just need
																			to add a PersistenceExceptionTranslationPostProcessor bean to the Spring application context:
																			@Bean
																			public BeanPostProcessor persistenceTranslation() {
																				return new PersistenceExceptionTranslationPostProcessor();
																			}
																			PersistenceExceptionTranslationPostProcessor is a bean post-processor that adds an adviser to any bean that's annotated with @Repository 
																			so that any platform-specific exceptions are caught and then rethrown as one of Spring’s unchecked data-access exceptions.
																		
																		public HibernateSpitterRepository(SessionFactory sessionFactory) {
																			this.sessionFactory = sessionFactory;
																		}
																		
																		private Session currentSession() {
																			return sessionFactory.getCurrentSession();
																		}
																		
																		public long count() {
																			return findAll().size();
																		}
																		
																		public Spitter save(Spitter spitter) {
																			Serializable id = currentSession().save(spitter);
																			return new Spitter((Long) id,
																			spitter.getUsername(),
																			spitter.getPassword(),
																			spitter.getFullName(),
																			spitter.getEmail(),
																			spitter.isUpdateByEmail());
																		}
																		
																		public Spitter findOne(long id) {
																			return (Spitter) currentSession().get(Spitter.class, id);
																		}
																		
																		public Spitter findByUsername(String username) {
																			return (Spitter) currentSession().createCriteria(Spitter.class).add(Restrictions.eq("username", username)).list().get(0);
																		}
																		
																		public List<Spitter> findAll() {
																			return (List<Spitter>) currentSession().createCriteria(Spitter.class).list();
																		}
																		}
																		
															Spring and JPA

																JPA-based applications use an implementation of EntityManagerFactory to get an instance of an EntityManager. The JPA specification defines two
																kinds of entity managers:
																	Application-managed—Entity managers are created when an application directly requests one from an entity manager factory. 
																	With application-managed entity managers, the application is responsible for opening or closing entity managers and involving the entity manager 
																	in transactions. This type of entity manager is most appropriate for use in standalone applications that don’t run in a Java EE container.
														
																	Container-managed—Entity managers are created and managed by a Java EE container. The application doesn't interact with the entity manager factory at
																	all. Instead, entity managers are obtained directly through injection or from JNDI. The container is responsible for configuring the entity manager 
																	factories. This type of entity manager is most appropriate for use by a Java EE container that wants to maintain some control over JPA 
																	configuration beyond what's specified in persistence.xml.
																	
																	LocalEntityManagerFactoryBean produces an application-managed EntityManagerFactory.
																	LocalContainerEntityManagerFactoryBean produces a container-managed EntityManagerFactory.
																	
																	CONFIGURING APPLICATION-MANAGED JPA
																	
																	Application-managed entity-manager factories derive most of their configuration information from a configuration file called persistence.xml. 
																	This file must appear in the META-INF directory in the classpath.
																	The purpose of the persistence.xml file is to define one or more persistence units. A persistence unit is a grouping of one or more persistent 
																	classes that correspond to a single data source.
																	
																	<persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">
																		<persistence-unit name="spitterPU">
																			<class>com.habuma.spittr.domain.Spitter</class>
																			<class>com.habuma.spittr.domain.Spittle</class>
																			<properties>
																				<property name="toplink.jdbc.driver" value="org.hsqldb.jdbcDriver" />
																				<property name="toplink.jdbc.url" value= "jdbc:hsqldb:hsql://localhost/spitter/spitter" />
																				<property name="toplink.jdbc.user"value="sa" />
																				<property name="toplink.jdbc.password" value="" />
																			</properties>
																		</persistence-unit>
																	</persistence>
																	
																	@Bean
																	public LocalEntityManagerFactoryBean entityManagerFactoryBean() {
																		LocalEntityManagerFactoryBean emfb = new LocalEntityManagerFactoryBean();
																		emfb.setPersistenceUnitName("spitterPU");
																		return emfb;
																	}
																	
																	CONFIGURING CONTAINER-MANAGED JPA
																	
																	@Bean
																	public LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource, JpaVendorAdapter jpaVendorAdapter) {
																		LocalContainerEntityManagerFactoryBean emfb =
																		new LocalContainerEntityManagerFactoryBean();
																		emfb.setDataSource(dataSource);
																		emfb.setJpaVendorAdapter(jpaVendorAdapter);
																		return emfb;
																	}
																	
																	You can use the jpaVendorAdapter property to provide specifics about the particular JPA implementation to use. Spring comes with a handful of 
																	JPA vendor adapters to choose from:
																		 EclipseLinkJpaVendorAdapter
																		 HibernateJpaVendorAdapter
																		 OpenJpaVendorAdapter
																		 
																	@Bean
																	public JpaVendorAdapter jpaVendorAdapter() {
																		HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter();
																		adapter.setDatabase("HSQL");
																		adapter.setShowSql(true);
																		adapter.setGenerateDdl(false);
																		adapter.setDatabasePlatform("org.hibernate.dialect.HSQLDialect");
																		return adapter;
																	}
																	
																	Certain dynamic persistence features require that the class of persistent objects be modified with instrumentation to support the feature. 
																	Objects whose properties are lazily loaded (they won’t be retrieved from the database until they’re accessed) must have their class instrumented 
																	with code that knows to retrieve unloaded data on access. Some frameworks use dynamic proxies to implement lazy loading.
																	Others, such as JDO, perform class instrumentation at compile time.
																	
																	@Repository
																	@Transactional
																	public class JpaSpitterRepository implements SpitterRepository {
																	
																		@PersistenceUnit
																		private EntityManagerFactory emf;
																		
																		public void addSpitter(Spitter spitter) {
																			emf.createEntityManager().persist(spitter);
																		}
																		
																		public Spitter getSpitterById(long id) {
																			return emf.createEntityManager().find(Spitter.class, id);
																		}
																		
																		public void saveSpitter(Spitter spitter) {
																			emf.createEntityManager().merge(spitter);
																		}
																		...
																	}
																	
																	Problem -> Each method ends up calling createEntityManager().
																			   The problem is that an EntityManager isn't thread-safe and generally shouldn't be injected into a shared singleton bean like your repository.
																	
																	
																	@Repository
																	@Transactional  --> persistence methods in this repository are involved in a transactional context.
																	public class JpaSpitterRepository implements SpitterRepository {
																		@PersistenceContext
																		private EntityManager em;
																		
																		public void addSpitter(Spitter spitter) {
																			em.persist(spitter);
																		}
																		
																		public Spitter getSpitterById(long id) {
																			return em.find(Spitter.class, id);
																		}
																		
																		public void saveSpitter(Spitter spitter) {
																			em.merge(spitter);
																		}
																		...
																	}
																	
																	@PersistenceContext doesn't inject an EntityManager -at least,not exactly. Instead of giving the repository a real EntityManager, it gives a proxy to a
																	real EntityManager. That real EntityManager either is one associated with the current transaction or, if one doesn’t exist, creates a new one. 
																	Thus, you know that you're always working with an entity manager in a thread-safe way.
																	
																	It's important to understand that @PersistenceUnit and @PersistenceContext aren't Spring annotations; they're provided by the JPA specification. 
																	In order forSpring to understand them and inject an EntityManagerFactory or EntityManager,Spring's PersistenceAnnotationBeanPostProcessor 
																	must be configured.
																	
																	@Bean
																	public PersistenceAnnotationBeanPostProcessor paPostProcessor() {
																		return new PersistenceAnnotationBeanPostProcessor();
																	}
																	
														Automatic JPA repositories with Spring Data
																public interface SpitterRepository extends JpaRepository<Spitter, Long> {
																}
																
																To ask Spring Data to create an implementation of SpitterRepository, you need to add a single element to your Spring configuration.
																
																<?xml version="1.0" encoding="UTF-8"?>
																<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
																	xmlns:jpa="http://www.springframework.org/schema/data/jpa" xsi:schemaLocation="http://www.springframework.org/schema/data/jpa
																	http://www.springframework.org/schema/data/jpa/spring-jpa-1.0.xsd">
																	
																	<jpa:repositories base-package="com.habuma.spittr.db" />
																	...
																</beans>
																
																The <jpa:repositories> element holds all the magic of Spring Data JPA. Much like the <context:component-scan> element, <jpa:repositories> is 
																given a base package to scan. But where <context:component-scan> scans a package (and its subpackages) for classes that are annotated with 
																@Component, <jpa:repositories> scans its base package for any interfaces that extend Spring Data JPA’s Repository interface.
																When it finds any interface extending Repository, it automatically (at application startup time) generates an implementation of that interface.
																Instead of using the <jpa:repositories> element, you can use @EnableJpaRepositories in your Java configuration class.
																
																@Configuration
																@EnableJpaRepositories(basePackages="com.habuma.spittr.db")
																public class JpaConfiguration {
																...
																}
																
																Spring Data JPA provides a few ways to add custom methods to a repository
																
																public interface SpitterRepository extends JpaRepository<Spitter, Long> {
																	Spitter findByUsername(String username);<----------CUSTOM METHOD
																}
																
																When creating the repository implementation, Spring Data will examine any methods in the repository interface, parse the method name, 
																and attempt to understand the method’s purpose in the context of the persisted object. In essence, Spring Data defines a sort of miniature 
																domain-specific language (DSL) where persistence details are expressed in repository method signatures.
																Spring Data knows that this method is intended to find Spitters, because you parameterized JpaRepository with Spitter. The method name, findByUsername,
																makes it clear that this method should find Spitters by matching their username property with the username passed in as a parameter to the method. 
																Moreover, because the signature defines the method as returning a single Spitter and not a collection, it knows that it should look 
																for only one Spitter whose username matches.
																Repository methods are composed of a verb, an optional subject, the word By, and a predicate. In the case of findByUsername(), the verb is 
																find and the predicate is Username; the subject isn't specified and is implied to be a Spitter.
																Spring Data allows for four verbs in the method name: get, read, find, and count. The get, read, and find verbs are synonymous; all three 
																result in repository methods that query for data and return objects. The count verb, on the other hand, returns a count
																of matching objects, rather than the objects themselves.
																The predicate is the most interesting part of the method name. It specifies the properties that will constrain the result set.
																
																Declaring custom queries
																
																@Query("select s from Spitter s where s.email like '%gmail.com'")
																List<Spitter> findAllGmailSpitters();
																
																
																When Spring Data JPA generates the implementation for a repository interface, it also looks for a class whose name is the same as the interface’s 
																name postfixed with Impl. If the class exists, Spring Data JPA merges its methods with those generated by Spring Data JPA.
																For the SpitterRepository interface, the class it looks for is named SpitterRepositoryImpl.
																
																public class SpitterRepositoryImpl implements SpitterSweeper {
																		@PersistenceContext
																		private EntityManager em;
																		
																		public int eliteSweep() {
																		String update = "UPDATE Spitter spitter " +
																			"SET spitter.status = 'Elite' " +
																			"WHERE spitter.status = 'Newbie' " +
																			"AND spitter.id IN (" +
																			"SELECT s FROM Spitter s WHERE (" +
																			" SELECT COUNT(spittles) FROM s.spittles spittles) > 10000" +
																			")";
																			return em.createQuery(update).executeUpdate();
																		}
																}		
																		
																
																
																
																
									GENERICS
										 generics enable types (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar formal parameters used in 
										 method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, 
										 while the inputs to type parameters are types.
										 
											public class Box {
												private Object object;

												public void set(Object object) { this.object = object; }
												public Object get() { return object; }
											}
											
											/**
											 * Generic version of the Box class.
											 * @param <T> the type of the value being boxed
											 */
											public class Box<T> {
												// T stands for "Type"
												private T t;

												public void set(T t) { this.t = t; }
												public T get() { return t; }
											}
											
											Raw Types
											
											To create a parameterized type of Box<T>, you supply an actual type argument for the formal type parameter T:

											Box<Integer> intBox = new Box<>();
											If the actual type argument is omitted, you create a raw type of Box<T>:

											Box rawBox = new Box();
											
											
											Generic Methods

											Generic methods are methods that introduce their own type parameters. This is similar to declaring a generic type, but the type parameter's scope is 
											limited to the method where it is declared. Static and non-static generic methods are allowed, as well as generic class constructors.
											The syntax for a generic method includes a type parameter, inside angle brackets, and appears before the method's return type. 
											For static generic methods, the type parameter section must appear before the method's return type.
											
											public class Util {
											
												public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2) {
													return p1.getKey().equals(p2.getKey()) && p1.getValue().equals(p2.getValue());
												}
												
											}
											
											boolean same = Util.<Integer, String>compare(p1, p2);
											
											The type has been explicitly provided, as shown in bold. Generally, this can be left out and the compiler will infer the type that is needed:

											Pair<Integer, String> p1 = new Pair<>(1, "apple");
											Pair<Integer, String> p2 = new Pair<>(2, "pear");
											boolean same = Util.compare(p1, p2);   --------------------> TYPE INFERENCE
											
											Bounded Type Parameters

											There may be times when you want to restrict the types that can be used as type arguments in a parameterized type. For example, a method that operates 
											on numbers might only want to accept instances of Number or its subclasses.
											
												public class Box<T> {

													private T t;          

													public void set(T t) {
														this.t = t;
													}

													public T get() {
														return t;
													}

													public <U extends Number> void inspect(U u){<-------GENERIC METHOD(Type parameters only matters to the method!!!)
														System.out.println("T: " + t.getClass().getName());
														System.out.println("U: " + u.getClass().getName());
													}

													public static void main(String[] args) {
														Box<Integer> integerBox = new Box<Integer>();
														integerBox.set(new Integer(10));
														integerBox.inspect("some text"); // error: this is still String!
													}
												}
											
																	
																		
																	
							NOSQL DATABASES
							
								Spring Data MongoDB brings MongoDB to Spring applications in three ways:
										Annotations for object-to-document mapping
										Template-based database access with MongoTemplate
										Automatic runtime repository generation
								
												Enable MongoDB
												
													MongoClient bean to be able to access the MongoDB database. 
													We'll also need a MongoTemplate bean to be able to perform template-based data access against the database.

													@Configuration
													@EnableMongoRepositories(basePackages="orders.db")
													public class MongoConfig {
													
														@Bean
														public MongoFactoryBean mongo() {
															MongoFactoryBean mongo = new MongoFactoryBean();
															mongo.setHost("localhost");
															return mongo;
														}
														@Bean
														public MongoOperations mongoTemplate(Mongo mongo) {
															return new MongoTemplate(mongo, "OrdersDB");
														}
													}
													
													
													Enabled Spring Data’s automatic JPA repository generation with the @EnableJpaRepositories annotation. Similarly, the @EnableMongoRepositories 
													annotation does the same thing for MongoDB.
													The first @Bean method uses MongoFactoryBean to declare a Mongo instance.
													This bean will bridge Spring Data MongoDB to the database itself (not unlike what a DataSource does when working with a relational database). 
													Although you could create an instance of Mongo directly with MongoClient, you’d be forced to deal with the UnknownHostException that’s thrown from MongoClient’s 
													constructor. It’s easier to use Spring Data MongoDB’s MongoFactoryBean here. As a factory bean, MongoFactoryBean will construct an instance of Mongo for you, 
													without you needing to worry much about UnknownHostException.
													The other @Bean method declares a MongoTemplate bean. It’s constructed giving it
													a reference to the Mongo instance created by the other bean method and the name of the database. In a moment, you’ll see how to use MongoTemplate to query the database.
													Even if you never use MongoTemplate directly, you’ll need this bean because the automatically generated repositories will use it under the covers.
													Rather than declare those beans directly, the configuration class could extend AbstractMongoConfiguration and override its getDatabaseName() and mongo() methods.
													
													@Configuration
													@EnableMongoRepositories("orders.db")
													public class MongoConfig extends AbstractMongoConfiguration {
														@Override
														protected String getDatabaseName() {
															return "OrdersDB";
														}
														
														@Override
														public Mongo mongo() throws Exception {
															return new MongoClient();
														}
													}
													
													
													When working with JPA, you had to map your Java entity types to relational tables and columns. The JPA specification provides for several annotations to 
													support object-to-relational mapping, and some JPA implementations, such as Hibernate, add their own mapping annotations as well.
													MongoDB, however, doesn’t come with its own object-to-document mapping annotations.
													Spring Data MongoDB seized the opportunity to fill that gap with a handful of
													annotations that you can use to map your Java types to MongoDB documents.
													We've already enabled Spring Data MongoDB repositories with @EnableMongoRepositories, so all that’s left is to create an interface that you can generate the
													repository implementation from. Instead of extending JpaRepository, however, we'll need to extend MongoRepository. The OrderRepository interface in the following
													listing extends MongoRepository to provide basic CRUD operations for Order documents.
													
													public interface OrderRepository extends MongoRepository<Order, String> {
													}
													
													As you’ll recall from our exploration of Spring Data JPA, any interface that extends Repository will have an implementation automatically generated at runtime.
													Spring Data JPA supports a method-naming convention that helps Spring Data to automatically generate implementations for the
													methods that follow that convention. As it turns out, the very same convention works with Spring Data MongoDB.
													
													@Query annotation can be used to specify a custom query for a repository method. @Query works equally well with MongoDB as it does with JPA. 
													The only material difference is that for MongoDB, @Query takes a JSON query string instead of a JPA query.
													
													We learned how to mix fully custom methods into an otherwise automatically generated repository. For JPA, that involved creating an intermediary
													interface that declares the custom method(s), an implementation class for those custo methods, and changing the automatic repository interface to 
													extend the intermediary interface. The steps are the same for a Spring Data MongoDB repository.
													
											Working with graph data in Neo4j

													Whereas document databases store data in coarse-grained documents, graph databases store data in several fine-grained nodes that are connected with each other
													through relationships. A node in a graph database typically represents a concept in the database, having properties that describe the state of the node. 
													Relationships connect two nodes and may carry properties of their own.
													At their simplest, graph databases are more general purpose than document databases, potentially being a schemaless alternative to relational databases. But because
													data is structured as a graph, it’s possible to traverse relationships to discover things about your data that would be difficult or even impossible with other 
													kinds of databases.
													Spring Data Neo4j offers many of the same capabilities as Spring Data JPA and Spring Data MongoDB, albeit targeting the Neo4j graph database.
													
													SPECIFYING CUSTOM QUERIES
														When the naming convention doesn’t meet your needs, you also have the option of annotating a method with @Query to specify your own query. we've seen @Query
														before. With Spring Data JPA, you used it to specify a JPA query for a repository method. With Spring Data MongoDB, you used it to specify a JSON-matching query.
														When using Spring Data Neo4j, however, you must specify a Cypher query:
														
															@Query("match (o:Order)-[:HAS_ITEMS]->(i:Item) " + "where i.product='Spring in Action' return o")
															List<Order> findSiAOrders();
															
														Here, the findSiAOrders() is annotated with @Query and given a Cypher query to find all Order nodes that are related to an Item whose product property is equal to
														"Spring in Action".
														
											Working with Key-Value data in REDIS


										CACHING DATA

												Spring doesn't implement a cache solution, it offers declarative support for caching that integrates with several popular caching implementations.
												Enable annotation-driven caching by adding @EnableCaching to one of your configuration classes :
												
												@Configuration
												@EnableCaching
												public class CachingConfig {
												
													@Bean
													public CacheManager cacheManager() {
														return new ConcurrentMapCacheManager();
													}
												}
												
												They create an aspect with pointcuts that trigger off of Spring’s caching annotations. Depending on the annotation used and the state of the cache, 
												that aspect will fetch a value from the cache, add a value to the cache, or remove a value from the cache.
												
												Annotating methods for caching
												
												@Cacheable("spittleCache")
												public Spittle findOne(long id) {
													try {
														return jdbcTemplate.queryForObject(SELECT_SPITTLE_BY_ID,new SpittleRowMapper(),id);
													} catch (EmptyResultDataAccessException e) {
														return null;
													}
												}
												When findOne() is called, the caching aspect intercepts the call and looks for a previously
												returned value in the cache named spittleCache. The cache key is the id
												parameter passed to the findOne() method.
												
												@CachePut(value="spittleCache", key="#result.id")
												Spittle save(Spittle spittle);
												
												We don’t want to cache any Spittle objects whose message property contains the text "NoCache".
												@Cacheable(value="spittleCache" unless="#result.message.contains('NoCache')")
												Spittle findOne(long id);
												
												@Cacheable(value="spittleCache" unless="#result.message.contains('NoCache')" condition="#id >= 10")
												Spittle findOne(long id);
												
												condition attribute does not use #result because the method was not yet executed and the condition attribute has the goal to prevent to store
												values on the cache!!!
												
												@CacheEvict("spittleCache")
												void remove(long spittleId);
												
										SECURING METHODS

												Spring Security provides three different kinds of security annotations:
														Spring Security’s own @Secured
														JSR-250’s @RolesAllowed
														Expression-driven annotations, with @PreAuthorize, @PostAuthorize,@PreFilter, and @PostFilter
														
														@Configuration
														@EnableGlobalMethodSecurity(securedEnabled=true)
														public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
														}
														
														In addition to being annotated with @EnableGlobalMethodSecurity, you’ll notice that the configuration class extends GlobalMethodSecurityConfiguration. Much
														like the WebSecurityConfigurerAdapter class that your web security configuration class extended in chapter 9, this class offers you the opportunity to configure 
														the finer points of method-level security.
														When securedEnabled is true, a pointcut is created such that the Spring Security aspects will wrap bean methods that are annotated with @Secured.
														
														@Secured({"ROLE_SPITTER", "ROLE_ADMIN"})
														public void addSpittle(Spittle spittle) {
														// ...
														}
														
														The @RolesAllowed annotation is equivalent to @Secured in almost every way. The only substantial difference is that @RolesAllowed is one of Java’s 
														standard annotations as defined in JSR-250.
														
												Using expressions for method-level security
												
													@Configuration
													public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
													}
													
													The key difference between @PreAuthorize and @PostAuthorize is in when their expressions are evaluated. @PreAuthorize is evaluated before the method executes
													and prevents method execution unless the expression evaluates to true. In contrast,@PostAuthorize waits until the method has returned before deciding whether or not
													to raise a security exception.
													
													@PreAuthorize("(hasRole('ROLE_SPITTER') and #spittle.text.length() <= 140)" + "or hasRole('ROLE_PREMIUM')")
													public void addSpittle(Spittle spittle) {
													// ...
													}
													
													Just like @PreAuthorize and @PostAuthorize, @PostFilter takes a SpEL expression as its value parameter. But instead of using that expression to restrict access to a
													method, @PostFilter evaluates that expression against each member of a collection being returned from the method, removing those members for whom the expression
													evaluates to false.
													
													@PreAuthorize("hasAnyRole({'ROLE_SPITTER', 'ROLE_ADMIN'})")
													@PostFilter( "hasRole('ROLE_ADMIN') || " + "filterObject.spitter.username == principal.name")
													public List<Spittle> getOffensiveSpittles() {
													...
													}
													
													In addition to postfiltering a method's return value, you also have the option of prefiltering the values passed into a method.
													
													@PreAuthorize("hasAnyRole({'ROLE_SPITTER', 'ROLE_ADMIN'})")
													@PreFilter( "hasRole('ROLE_ADMIN') || " + "targetObject.spitter.username == principal.name")
													public void deleteSpittles(List<Spittle> spittles) { ... }
													
													DEFINING A PERMISSION EVALUATOR FOR COMPLEX EXPRESSIONS
													
													@PreAuthorize("hasAnyRole({'ROLE_SPITTER', 'ROLE_ADMIN'})")
													@PreFilter("hasPermission(targetObject, 'delete')")
													public void deleteSpittles(List<Spittle> spittles) { ... }
													
													where did hasPermission() come from ?
													
														hasPermission() function is a Spring Security–provided extension to SpEL.
														
														public class SpittlePermissionEvaluator implements PermissionEvaluator {

															private static final GrantedAuthority ADMIN_AUTHORITY = new GrantedAuthorityImpl("ROLE_ADMIN");
															
															public boolean hasPermission(Authentication authentication, Object target, Object permission) {
																if (target instanceof Spittle) {
																	Spittle spittle = (Spittle) target;
																	String username = spittle.getSpitter().getUsername();
																	if ("delete".equals(permission)) {
																		return isAdmin(authentication) || username.equals(authentication.getName());
																	}
																}
															throw new UnsupportedOperationException("hasPermission not supported for object <" + target + "> and permission <" + permission + ">");
															}
															
															public boolean hasPermission(Authentication authentication,Serializable targetId, String targetType, Object permission) {
																throw new UnsupportedOperationException();
															}
															
															private boolean isAdmin(Authentication authentication) {
																return authentication.getAuthorities().contains(ADMIN_AUTHORITY);
															}
														}
														
														Once the permission evaluator is ready, you need to register it with Spring Security for it to back the hasPermission() operation in the 
														expression given to @PostFilter. To do that, you’ll need to replace the expression handler with one that’s configured to use your custom permission evaluator.
														
														overriding the createExpressionHandler method from GlobalMethodSecurityConfiguration:

														@Override
														protected MethodSecurityExpressionHandler createExpressionHandler() {
														DefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler();
														expressionHandler.setPermissionEvaluator(new SpittlePermissionEvaluator());
														return expressionHandler;
														}
														
								INTEGRATING SPRING

									Several remoting technologies are available to you as a Java developer, including these:
										Remote Method Invocation (RMI)
										Caucho’s Hessian and Burlap
										Spring’s own HTTP-based remoting
										Web services with JAX-RPC and JAX-WS
															
										Spring supports RPC via several remoting technologies.
										
										Remote Method Invocation(RMI)
														Accessing/exposing Java-based services when network constraints such as firewalls aren’t a factor.

										Hessian or Burlap 
														Accessing/exposing Java-based services over HTTP when network constraints are a factor. Hessian is a binary protocol, whereas Burlap is XML-based.
										HTTP invoker 
														Accessing/exposing Spring-based services when network constraints are a factor and you desire Java serialization over XML or proprietary serialization.
										JAX-RPC and JAX-WS 
														Accessing/exposing platform-neutral, SOAP-based web services
														
											Services can be configured into your application as Spring-managed beans. This is accomplished using a proxy factory bean that enables you to wire
											remote services into properties of your other beans as if they were local objects.


											RMI
												RMI—first introduced into the Java platform in JDK 1.1—gives Java programmers a powerful way to communicate between Java programs. Before RMI, the only remoting options 
												available to Java programmers were CORBA (which at the time required the purchase of a third-party object request broker [ORB]) and handwritten socket programming.
												Spring simplifies the RMI model by providing a proxy factory bean that enables you to wire RMI services into your Spring application as if
												they were local JavaBeans. Spring also provides a remote exporter that makes short work of converting your Spring-managed beans into RMI services.
												
												To create an RMI service, it involves the following steps:
													1 Write the service implementation class with methods that throw java.rmi.RemoteException.
													2 Create the service interface to extend java.rmi.Remote.
													3 Run the RMI compiler (rmic) to produce client stub and server skeleton classes.
													4 Start an RMI registry to host the services.
													5 Register the service in the RMI registry.
													
												RmiServiceExporter exports any Spring-managed bean as an RMI service.RmiServiceExporter works by wrapping the bean in an adapter class. The adapter class is 
												then bound to the RMI registry and proxies requests to the service class—SpitterServiceImpl.
												
												@Bean
												public RmiServiceExporter rmiExporter(SpitterService spitterService) {
													RmiServiceExporter rmiExporter = new RmiServiceExporter();
													rmiExporter.setService(spitterService);
													rmiExporter.setServiceName("SpitterService");
													rmiExporter.setServiceInterface(SpitterService.class);
													return rmiExporter;
												}
												
											Hessian and Burlap	
												
												Hessian, like RMI, uses binary messages to communicate between client and service.
												But unlike other binary remoting technologies (such as RMI), the binary message is portable to languages other than Java, including PHP, Python, C++, and C#.
												Burlap is an XML-based remoting technology, which automatically makes it portable to any language that can parse XML.
												Unlike other XML-based remoting technologies (such as SOAP and XML-RPC), Burlap’s message structure is as simple as possible and doesn’t require 
												an external definition language (such as WSDL or IDL).
												HessianServiceExporter performs the same function for a Hessian service as RmiServiceExporter does for an RMI service: it exposes the public methods of a POJO
												as methods of a Hessian service. How it pulls off this feat is different from how RmiServiceExporter exports POJOs as RMI services.
												HessianServiceExporter is a Spring MVC controller (more on that in a moment) that receives Hessian requests and translates them into method calls on the exported
												POJO.
												
												@Bean
												public HessianServiceExporter hessianExportedSpitterService(SpitterService service) {
													HessianServiceExporter exporter = new HessianServiceExporter();
													exporter.setService(service);
													exporter.setServiceInterface(SpitterService.class);
													return exporter;
												}
													
										
												Hessian is HTTP-based, HessianServiceExporter is implemented as a Spring MVC controller. This means that in order to use exported Hessian services.
												
													Configure a Spring DispatcherServlet in web.xml, and deploy your application as a web application.
													Configure a URL handler in your Spring configuration to dispatch Hessian service URLs to the appropriate Hessian service bean.
													
														In web.xml
															<servlet-mapping>
																<servlet-name>spitter</servlet-name>
																<url-pattern>*.service</url-pattern>
															</servlet-mapping>
														
														Java WebApplicationInitializer
															ServletRegistration.Dynamic dispatcher = container.addServlet("appServlet", new DispatcherServlet(dispatcherServletContext));
															dispatcher.setLoadOnStartup(1);
															dispatcher.addMapping("/");
															dispatcher.addMapping("*.service");
															
															
															DispatcherServlet by extending AbstractDispatcherServletInitializer or AbstractAnnotationConfigDispatcherServletInitializer
															
															@Override
															protected String[] getServletMappings() {
															return new String[] { "/", "*.service" };
															}
															
															@Bean
															public HandlerMapping hessianMapping() {
																SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
																Properties mappings = new Properties();
																mappings.setProperty("/spitter.service","hessianExportedSpitterService");
																mapping.setMappings(mappings);
																return mapping;
															}
															
												Spring's HttpInvoker
													The Spring team recognized a void between RMI services and HTTP-based services such as Hessian and Burlap. On the one side, RMI uses Java’s standard object serialization
													but is difficult to use across firewalls. On the other side, Hessian and Burlap work well across firewalls but use a proprietary object-serialization mechanism.
													Thus Spring’s HTTP invoker was born. The HTTP invoker is a new remoting model created as part of the Spring Framework to perform remoting across 
													HTTP (to make the firewalls happy) and using Java’s serialization (to make programmers happy).
													
													@Bean
													public HttpInvokerServiceExporter httpExportedSpitterService(SpitterService service) {
														HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter();
														exporter.setService(service);
														exporter.setServiceInterface(SpitterService.class);
														return exporter;
													}
													
													HttpInvokerServiceExporter works much like HessianServiceExporter and BurlapServiceExporter. It’s a Spring MVC controller that receives requests from a client through 
													DispatcherServlet and translates those requests into method calls on the service implementation POJO.
													
													Because HttpInvokerServiceExporter is a Spring MVC controller, you need to set up a URL handler to map an HTTP URL to the service.
													
													@Bean
													public HandlerMapping httpInvokerMapping() {
														SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
														Properties mappings = new Properties();
														mappings.setProperty("/spitter.service","httpExportedSpitterService");
														mapping.setMappings(mappings);
														return mapping;
													}
												
												Publishing and consuming web services
												
													You saw how to create RMI services using RmiServiceExporter, Hessian services using HessianServiceExporter, Burlap services using BurlapServiceExporter, and HTTP
													invoker services using HttpInvokerServiceExporter.
													Spring does provide a JAX-WS service exporter, SimpleJaxWsServiceExporter, but we should know that it may not be the best choice in all situations. 
													SimpleJaxWsServiceExporter requires that the JAX-WS runtime support publishing of endpoints to a specified address!!!
													If we'll be deploying to a JAX-WS runtime that doesn’t support publishing to a specified address, we'll have write your JAX-WS endpoints in a more conventional way.
													That means the lifecycle of the endpoints will be managed by the JAX-WS runtime and not by Spring.
													Just as with any other object in a sizable application, a JAX-WS endpoint will likely depend on other objects to do its work. That means JAX-WS endpoints could benefit
													from dependency injection. But if the endpoint’s lifecycle is managed by the JAX-WS runtime and not by Spring, it would seem to be impossible to wire Spring-managed
													beans into a JAX-WS–managed endpoint instance.
													The secret to wiring JAX-WS endpoints is to extend SpringBeanAutowiringSupport!!!
													By extending SpringBeanAutowiringSupport, you can annotate an endpoint’s properties with @Autowired, and its dependencies will be met.
													
														@WebService(serviceName="SpitterService")
														public class SpitterServiceEndpoint extends SpringBeanAutowiringSupport {
															@Autowired
															SpitterService spitterService;
															
															@WebMethod
															public void addSpittle(Spittle spittle) {
																spitterService.saveSpittle(spittle);
															}
															...
															
													Spring’s SimpleJaxWsServiceExporter works much like the other service exporters that you saw earlier in this chapter, in that it publishes Spring-managed beans as
													service endpoints in a JAX-WS runtime. Unlike those other service exporters, SimpleJaxWsServiceExporter doesn’t need to be given a reference to the bean 
													it’s supposed to export. Instead, it publishes all beans that are annotated with JAX-WS annotations as JAX-WS services.
													
													@Bean
													public SimpleJaxWsServiceExporter jaxWsExporter() {
														return new SimpleJaxWsServiceExporter();
													}
												
												Proxying JAX-WS services on the client side
												
													@Bean
													public JaxWsPortProxyFactoryBean spitterService() {
														JaxWsPortProxyFactoryBean proxy = new JaxWsPortProxyFactoryBean();
														proxy.setWsdlDocument("http://localhost:8080/services/SpitterService?wsdl");
														proxy.setServiceName("spitterService");
														proxy.setPortName("spitterServiceHttpPort");
														proxy.setServiceInterface(SpitterService.class);
														proxy.setNamespaceUri("http://spitter.com");
														return proxy;
													}
													
										REST

													A mistake that's often made when approaching REST is to think of it as "web services with URLs"—to think of REST as another remote procedure call (RPC) mechanism,
													like SOAP, but invoked through plain HTTP URLs and without SOAP’s hefty XML namespaces.
													On the contrary, REST has little to do with RPC. Whereas RPC is service oriented and focused on actions and verbs, REST is resource oriented, emphasizing the things
													and nouns that comprise an application.
													Resources in REST are identified and located with URLs. There are no strict rules regarding RESTful URL structure, but the URL should identify a resource, not bark a
													command to the server. Again, the focus is on things, not actions.
														There are actions in REST, and they're defined by HTTP methods.
														Resources can be represented in a variety of ways using Spring views and view resolvers, including View implementations for rendering model data as XML,
														JSON, Atom, and RSS. The representation best suited for the client can be chosen using ContentNegotiatingViewResolver.
														
														Spring offers two options to transform a resource's Java representation into the representation that's shipped to the client:
															Content negotiation
																A view is selected that can render the model into a representation to be served to the client.
															Message conversion
																A message converter transforms an object returned from the controller into a representation to be served to the client.
																
														When a controller's handler method finishes, a logical view name is usually returned. If the method doesn't directly return a logical view name 
														(if the method returns void, for example), the logical view name is derived from the request’s URL. DispatcherServlet then passes the view name to a 
														view resolver, asking it to help determine which view should render the results of the request.
														In a human-facing web application, the view chosen is almost always rendered as HTML; view resolution is a one-dimensional activity. 
														If the view name matches a view, then that's the view you go with.
														When it comes to resolving view names into views that can produce resource representations, there's an additional dimension to consider. Not only does the view need
														to match the view name, but the view also needs to be chosen to suit the client. If the client wants JSON data, then an HTML-rendering 
														view won't do—even if the view name matches.
														Spring's ContentNegotiatingViewResolver is a special view resolver that takes the content type that the client wants into consideration.
														
														@Bean
														public ViewResolver cnViewResolver() {
															return new ContentNegotiatingViewResolver();
														}
														
														Understanding how ContentNegotiatingViewResolver works involves getting to know the content-negotiation two-step:
															1 Determine the requested media type(s).
															2 Find the best view for the requested media type(s).
															
															The first step in the content-negotiation two-step is determining what kind of resource representation the client wants.
															Shouldn't the request’s Accept header give a clear indication of what representation should be sent to the client?
															Unfortunately, the Accept header can't always be deemed reliable. If the client in question is a web browser, there's no guarantee that what the client 
															wants is what the browser sends in the Accept header. Web browsers typically only accept human friendly content types (such as text/html), 
															and there's no way to specify a different content type. ContentNegotiatingViewResolver considers the Accept header and uses whatever media types it asks for,
															but only after it first looks at the URL’s file extension!!!
															
															The media-type selection process, as described so far, outlines the default strategy for determining the requested media types. 
															But you can change how it behaves by giving it a ContentNegotiationManager. A few of the things you can do via a ContentNegotiationManager
															
															There are three ways to configure a ContentNegotiationManager:
																Directly declare a bean whose type is ContentNegotiationManager.
																Create the bean indirectly via ContentNegotiationManagerFactoryBean.
															|	Override the configureContentNegotiation() method of WebMvcConfigurerAdapter.
															|
															|---->For Java configuration,the easiest way to get a ContentNegotiationManager is to extend WebMvcConfigurerAdapter and override 
																  configureContentNegotiation() method.
																  
																	@Override
																	public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
																		configurer.defaultContentType(MediaType.APPLICATION_JSON);
																	}
																	
																	Now that you have a ContentNegotiationManager bean, all you need to do is inject it into the contentNegotiationManager 
																	property of ContentNegotiatingViewResolver.
																	
																	@Bean
																	public ViewResolver cnViewResolver(ContentNegotiationManager cnm) {
																		ContentNegotiatingViewResolver cnvr = new ContentNegotiatingViewResolver();
																		cnvr.setContentNegotiationManager(cnm);
																		return cnvr;
																	}
																	
																	@Bean
																	public ViewResolver beanNameViewResolver() {
																		return new BeanNameViewResolver();
																	}

																	@Bean
																	public View spittles() {
																		return new MappingJackson2JsonView();
																	}
																	
																	Unlike Spring's other view resolvers, ContentNegotiatingViewResolver doesn’t resolve views on its own. Instead, it delegates to other view resolvers, 
																	asking them to resolve the view.
																	ContentNegotiatingViewResolver asks the other view resolvers to resolve the logical view name into a view. Every view that's resolved is added to a 
																	list of candidate views. With the candidate view list assembled, ContentNegotiatingViewResolver cycles through all the requested media types, 
																	trying to find a view from among the candidate views that produces a matching content type. The first match found is the one that's used to 
																	render the model.
																	If the logical view name is "spittles", then the configured BeanNameViewResolver resolves the View declared in the spittles() method.
																	That's because the bean name matches the logical view name.
																	
																	
																	The key benefit of using ContentNegotiatingViewResolver is that it layers REST resource representation on top of the Spring MVC with no change 
																	in controller code.
																	The same controller method that serves human-facing HTML content can also serve JSON or XML to a non-human client.
																	Content negotiation is a convenient option when there’s a great deal of overlap between your human and non-human interfaces.
																	
														Working with HTTP message converters

																When using message conversion, DispatcherServlet doesn’t bother with ferrying model data to a view. In fact, there is no model, and there is no view. 
																There is only data produced by the controller and a resource representation produced when a message converter transforms that data.
																Normally, when a handler method returns a Java object (anything other than String or an implementation of View), that object ends up in the model for 
																rendering in the view. But if you’re going to employ message conversion, you need to tell Spring to skip the normal model/view flow and use a message 
																converter instead.
																
																@RequestMapping(method=RequestMethod.GET,produces="application/json")
																public @ResponseBody List<Spittle> spittles(@RequestParam(value="max",defaultValue=MAX_LONG_AS_STRING) long max,
																@RequestParam(value="count", defaultValue="20") int count) {
																	return spittleRepository.findSpittles(max, count);
																}
																	
																	DispatcherServlet considers the request’s Accept header and looks for a message converter that can give the client the representation it wants.
																	This method will only handle requests whose Accept header includes application/json. Any other kind of request, even if it’s a GET
																	request whose URL matches the path specified, won’t be handled by this method.
																	
																	Just as @ResponseBody tells Spring to employ a message converter when sending data to a client, the @RequestBody tells Spring to find a message 
																	converter to convert a resource representation coming from a client into an object.
																	
																	@RequestMapping(method=RequestMethod.POST,consumes="application/json")
																	public @ResponseBody Spittle saveSpittle(@RequestBody Spittle spittle) {
																		return spittleRepository.save(spittle);
																	}
																	
																	
																	If we annotate our controller class with @RestController instead of @Controller, Spring applies message conversion to all handler methods in the 
																	controller. We don't need to annotate each method with @ResponseBody.
																	
															Communicating errors to the client

																Spring offers a few options for dealing with such scenarios:
																	Status codes can be specified with the @ResponseStatus annotation.
																	Controller methods can return a ResponseEntity that carries more metadata concerning the response.
																	An exception handler can deal with the error cases, leaving the handler methods to focus on the happy path.
																	
																		
																	@RequestMapping(value="/{id}", method=RequestMethod.GET)
																	public ResponseEntity<Spittle> spittleById(@PathVariable long id) {
																		Spittle spittle = spittleRepository.findOne(id);
																		HttpStatus status = spittle != null ? HttpStatus.OK : HttpStatus.NOT_FOUND;
																		return new ResponseEntity<Spittle>(spittle, status);
																	}
																	
																	@ExceptionHandler(SpittleNotFoundException.class)
																	public ResponseEntity<Error> spittleNotFound(SpittleNotFoundException e) {
																		long spittleId = e.getSpittleId();
																		Error error = new Error(4, "Spittle [" + spittleId + "] not found");
																		return new ResponseEntity<Error>(error, HttpStatus.NOT_FOUND);
																	}
																	
																	The @ExceptionHandler annotation can be applied to controller methods to handle specific exceptions. Here, it’s indicating that if a 
																	SpittleNotFoundException is thrown from any of the handler methods in the same controller, the spittleNotFound() method should be called to 
																	handle that exception.
																	
																	Now we can remove most of the error handling from the spittleById() method:
																	@RequestMapping(value="/{id}", method=RequestMethod.GET)
																	public ResponseEntity<Spittle> spittleById(@PathVariable long id) {
																		Spittle spittle = spittleRepository.findOne(id);
																		if (spittle == null) { throw new SpittleNotFoundException(id); }
																		return new ResponseEntity<Spittle>(spittle, HttpStatus.OK);
																	}
																	
																	@RequestMapping(method=RequestMethod.POST,consumes="application/json")
																	public ResponseEntity<Spittle> saveSpittle(@RequestBody Spittle spittle,UriComponentsBuilder ucb) {
																		Spittle spittle = spittleRepository.save(spittle);
																		HttpHeaders headers = new HttpHeaders();
																		URI locationUri = ucb.path("/spittles/").path(String.valueOf(spittle.getId())).build().toUri();
																		headers.setLocation(locationUri);
																		ResponseEntity<Spittle> responseEntity = new ResponseEntity<Spittle>(spittle, headers, HttpStatus.CREATED)
																		return responseEntity;
																	}
																	
															Exploring RestTemplate's operations

																public Profile fetchFacebookProfile(String id) {
																	RestTemplate rest = new RestTemplate();
																	return rest.getForObject("http://graph.facebook.com/{spitter}",Profile.class, id);
																}
																
																Alternatively
																
																public Spittle[] fetchFacebookProfile(String id) {
																	Map<String, String> urlVariables = new HashMap<String, String();
																	urlVariables.put("id", id);
																	RestTemplate rest = new RestTemplate();
																	return rest.getForObject("http://graph.facebook.com/{spitter}",Profile.class, urlVariables);
																}
																
													Messaging in Spring

															Two main actors in asynchronous messaging: message brokers and destinations.
															There are two common types of destinations: queues and topics.
															Each of these is associated with a specific messaging model: either point-to-point (for queues) or publish/subscribe (for topics).
															In the point-to-point model, each message has exactly one sender and one receiver although each message in a message queue is delivered to only one receiver, 
															this doesn't imply that only one receiver is pulling messages from the queue. It’s likely that several receivers are processing messages from the queue.
															
															In the publish/subscribe messaging model, messages are sent to a topic. As with queues, many receivers may be listening to a topic. But unlike with queues, 
															where a message is delivered to exactly one receiver, all subscribers to a topic receive a copy of the message.
															
															Synchronous communications limitations
															
																Waiting
																Coupled through service interface
																Coupled to the service location
																Coupled to the service availability
																
														Sending messages with JMS
															The Java Message Service (JMS) is a Java standard that defines a common API for working with message brokers. Before JMS, each message broker 
															had a proprietary API, making an application’s messaging code less portable between brokers. But with JMS, all compliant implementations can be worked with 
															via a common interface in much the same way that JDBC has given database operations a common interface.
															
															
															Creating message-driven POJOs
															
															IN EJB3 
																@MessageDriven(mappedName="jms/spittle.alert.queue")
																public class SpittleAlertHandler implements MessageListener {
																	@Resource
																	private MessageDrivenContext mdc;
																	public void onMessage(Message message) {
																	...
																	}
																}
																
															In Spring 
																public class SpittleAlertHandler {
																	public void handleSpittleAlert(Spittle spittle) {
																	// ... implementation goes here...
																	}
																}
																
																<bean id="spittleHandler" class="com.habuma.spittr.alerts.SpittleAlertHandler" />
																<jms:listener-container connection-factory="connectionFactory">
																	<jms:listener destination="spitter.alert.queue" ref="spittleHandler" method="handleSpittleAlert" />
																</jms:listener-container>
																
																Here you have a message listener that’s contained in a message-listener container. A message-listener container is a special bean that watches a JMS 
																destination, waiting for a message to arrive. Once a message arrives, the bean retrieves the message and passes it on to any message listeners that are 
																interested.
																
															Using message-based RPC
																How to make remote calls that use JMS as a transport?
																
																EXPORTING JMS-BASED SERVICES
																
																	Spring provides several options for exporting beans as remote services. You used RmiServiceExporter to export beans as RMI services,
																	HessianExporter and BurlapExporter for Hessian and Burlap services over HTTP, and HttpInvokerServiceExporter to create HTTP invoker services over HTTP.
																	JmsInvokerServiceExporter is much like those other service exporters.
																	If HttpInvokerServiceExporter exports services that communicate over HTTP, then JmsInvokerServiceExporter must export services that converse over JMS.
															
														Messaging with AMQP
															You may be wondering why you need another messaging specification. Isn’t JMS good enough? What does AMQP bring to the table that is missing from JMS?
															AMQP offers several advantages over JMS. First, AMQP defines a wire-level protocol for messaging, whereas JMS defines an API specification. JMS’s API
															specification ensures that all JMS implementations can be used through a common API but doesn’t mandate that messages sent by one JMS implementation 
															can be consumed by a different JMS implementation. AMQP’s wire-level protocol, on the other hand, specifies the format that messages will take when en route 
															between the producer and consumer. Consequently, AMQP is more interoperable than JMS—not only across different AMQP implementations, but also across 
															languages and platforms.Another significant advantage of AMQP over JMS is that AMQP has a much more flexible and transparent messaging model. 
															With JMS, there are only two messaging models to choose from: point-to-point and publish/subscribe. Both of those models are certainly possible with AMQP, 
															but AMQP enables you to route messages in a number of ways, and it does this by decoupling the message producer from the queue(s) in which the messages will 
															be placed.
															AMQP producers don’t publish directly to a queue. Instead, AMQP introduces a new level of indirection between the producer and any queues that will
															carry the message: the exchange.
															                                Binding
															PRODUCER ----------> EXCHANGE -----------> Queue-------------> Consumer
															
															Exchange isn't a pass-through mechanism to a queue. AMQP defines four different types of exchanges, each with a different
															routing algorithm that decides whether to place a message in a queue.AMQP defines four different types of exchanges, each with a different
															routing algorithm that decides whether to place a message in a queue.
															
															The four standard types of AMQP exchanges are as follows:
																Direct
																	A message will be routed to a queue if its routing key is a direct match for the routing key of the binding.
																Topic
																	A message will be routed to a queue if its routing key is a wildcard match for the routing key of the binding.
																Headers
																	A message will be routed to a queue if the headers and values in its table of arguments match those in the binding's table of arguments. A special
																	header named x-match can specify whether all values must match or if any can match.
																Fanout 
																    A message will be routed to all queues that are bound to the exchange, regardless of the routing key or headers/values in the table of arguments.
															
																
																<admin connection-factory="connectionFactory"/> 
																<queue id="spittleAlertQueue" name="spittle.alerts" />
		
															For simple messaging, this may be all you need. That's because there's a default direct exchange with no name, and all queues are bound to that exchange 
															with a routing key that's the same as the queue’s name. With this simple configuration, you could send messages to the no-name exchange and specify a routing 
															key of spittle.alert.queue to have messages routed to the queue. Essentially, this re-creates a JMSstyle point-to-point model.
															
															To have a message routed to multiple queues with no regard for the routing key, you can configure a fanout exchange and several queues like this:

															<admin connection-factory="connectionFactory" /> 
																<queue name="spittle.alert.queue.1" > 
																<queue name="spittle.alert.queue.2" > 
																<queue name="spittle.alert.queue.3" > 
																<fanoutexchange name="spittle.fanout">
																	<bindings> 
																		<binding queue="spittle.alert.queue.1" /> 
																		<binding queue="spittle.alert.queue.2" /> 
																		<binding queue="spittle.alert.queue.3" /> 
																	</bindings> 
																</fanoutexchange>
																
															Spring’s JMS support offers two ways to fetch a message from a queue: 
																synchronously via JmsTemplate and asynchronously with message-driven POJOs.	
																																	
												Messaging with WebSockets and Stomp
												
													In its simplest form, a WebSocket is just a communication channel between two applications.
													An application on one end of the WebSocket sends a message, and the other end handles that message. Because it's full-duplex, either end can send messages and
													either end can handle messages.
													
													To handle messages in Spring with low-level WebSocket support, you must write a class that implements WebSocketHandler:
													
														public interface WebSocketHandler {
															void afterConnectionEstablished(WebSocketSession session) throws Exception;
															void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception;
															void handleTransportError(WebSocketSession session, Throwable exception) throws Exception;
															void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception;
															boolean supportsPartialMessages();
														}

														Rather than implement WebSocketHandler directly, it's easier to extend AbstractWebSocketHandler, an abstract implementation of WebSocketHandler.
														
														public class MarcoHandler extends AbstractWebSocketHandler {
															private static final Logger logger = LoggerFactory.getLogger(MarcoHandler.class);
															protected void handleTextMessage( WebSocketSession session, TextMessage message) throws Exception {
																logger.info("Received message: " + message.getPayload());
																Thread.sleep(2000);
																session.sendMessage(new TextMessage("Polo!"));
															}
														}
														
													TextWebSocketHandler is a subclass of AbstractWebSocketHandler that refuses to handle binary messages. It overrides handleBinaryMessage() to close the WebSocket
													connection if a binary connection is received. In a similar way, Spring also offers BinaryWebSocketHandler, a subclass of AbstractWebSocketHandler that overrides
													handleTextMessage() to close the connection if a text message is received.
													
													@EnableWebSocket
													public class WebSocketConfig implements WebSocketConfigurer {
														@Override
														public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
															registry.addHandler(marcoHandler(), "/marco");
														}
														@Bean
														public MarcoHandler marcoHandler() {
															return new MarcoHandler();
														}
													}
													
												When WebSockets are not supported :

													WebSocket fallback is the specialty of SockJS.
													SockJS is a WebSocket emulator that mirrors the WebSocket API as closely as possible on the surface, but under the covers is clever enough to choose another 
													form of communication when WebSocket isn't available. SockJS will always favor WebSocket first, but if WebSocket isn't an option, it will determine the best available 
													option from the following:
													
														XHR streaming
														XDR streaming
														iFrame event source
														iFrame HTML file
														XHR polling
														XDR polling
														iFrame XHR polling
														JSONP polling
														
														@Override
														public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
															registry.addHandler(marcoHandler(), "/marco").withSockJS();
														}
														
												Working with STOMP messaging
													
													Working directly with WebSocket (or SockJS) is a lot like developing a web application using only TCP sockets. Without a higher-level wire protocol, it's up to you to
													define the semantics of the messages being sent between applications. And you'd need to be sure that both ends of the connection agreed on those semantics.
													Fortunately, you don’t have to work with raw WebSocket connections. Just as HTTP layers a request-response model on top of TCP sockets,
													STOMP layers a frame-based wire format to define messaging semantics on top of WebSocket.
													At a quick glance, STOMP message frames look very similar in structure to HTTP requests. Much like HTTP requests and responses, STOMP frames are comprised of a
													command, one or more headers, and a payload.
													
													SEND
													destination:/app/marco
													content-length:20
													
													{\"message\":\"Marco!\"}
													
													
													The destination header is probably the most interesting thing about the STOMP frame. It's a clue that STOMP is a messaging protocol, very much like JMS or AMQP.
													Messages are published to destinations that may, in fact, be backed by real message brokers. On the other end, message handlers can listen to those destinations to
													receive the messages sent.
													Spring's web messaging is built around a message broker, so there’s more to configure than just telling Spring that you'd like to handle messages.
													You must also configure a message broker and some basic destination details.
													
													@Configuration
													@EnableWebSocketMessageBroker
													public class WebSocketStompConfig extends AbstractWebSocketMessageBrokerConfigurer {
														@Override
														public void registerStompEndpoints(StompEndpointRegistry registry) {
															registry.addEndpoint("/marcopolo").withSockJS();
														}
														
														@Override
														public void configureMessageBroker(MessageBrokerRegistry registry) {
															registry.enableSimpleBroker("/queue", "/topic");
															registry.setApplicationDestinationPrefixes("/app");
														}
													}
													
													This configuration class is not only configuring WebSocket, but it's configuring broker-based STOMP messaging.
													When a message arrives, the destination prefix will determine how the message is handled. Application destinations are prefixed with /app and the
													broker destinations are prefixed with either /topic or /queue. A message headed for an application destination(/app) is routed directly to an 
													@MessageMapping-annotated controller method. Messages destined for the broker, including any messages resulting from values returned by @MessageMapping-annotated methods,
													are routed to the broker and are ultimately sent out to clients subscribed to those destinations.
													
													
								Managing Spring beans with JMX
									
									Spring's support for DI is a great way to configure bean properties in an application.
									But once the application has been deployed and is running, DI alone can't do much to help you change that configuration. Suppose you want to dig into a running
									application and change its configuration on the fly. That's where Java Management Extensions (JMX) comes in.
									JMX is a technology that enables you to instrument applications for management, monitoring, and configuration. Originally available as a separate extension
									to Java, JMX is now a standard part of the Java 5 distribution. The key component of an application that’s instrumented for management with
									JMX is the managed bean (MBean). An MBean is a JavaBean that exposes certain methods that define the management interface. The JMX specification defines four types of MBeans:
									
								

								Spring Boot
								
								
								Maven
									CONVENTION OVER CONFIGURATION !!!!
									Without customization, source code is assumed to be in ${basedir}/src/main/java and resources are assumed to be in ${basedir}/src/main/resources. Tests are assumed to be in
									${basedir}/src/test, and a project is assumed to produce a JAR file. Maven assumes that you want the compile byte code to ${basedir}/target/classes and
									then create a distributable JAR file in ${basedir}/target.
									Most of the action in Maven happens in plugin goals which take care of things like compiling source, packaging bytecode, publishing sites, and any other task which need to happen in a
									build. The Maven you download from Apache doesn't know much about packaging a WAR file or running JUnit tests; most of the intelligence of Maven is implemented in the plugins and 
									the plugins are retrieved from the Maven Repository.
									
									Dependency Management
										Because a project is defined a unique coordinate which consists of a group identifier, artifact identifier, and version, projects can 
										now use these coordinates to declare dependencies.
										
									Remote Repositories
										Related to dependency management, we can use the coordinates defined in the Maven Project Object Model (POM) to create repositories of Maven artifacts.

									Universal Reuse of Build Logic
										Plugins are coded to work with the Project Object Model (POM); they are not designed to operate upon specific files in known locations. Everything is
										abstracted into the Model, plugin configuration and customization happens in the model.	
										
									Tool Portability / Integration
										Tools like Eclipse, NetBeans, and IntelliJ now have a common place to find information about a project. Before the advent of Maven, every IDE had a
										different way to store what was essentially a custom Project Object Model (POM). Maven has standardized this description, and while each IDE continues
										to maintain custom project files, they can be easily generated from the model.

									Easy Searching and Filtering of Project Artifacts
										Tools like Nexus allow you to index and search the contents of a repository using the information stored in the POM.
										
									Installation details
										bin contains scripts that executes Maven
										boot contains JAR file that is responsible for creating the classloader in which Maven executes
										conf contains a global "settings.xml" that could be used to customize the behaviour of our Maven installation.
										USUALLY WE SHOULD AVOID CUSTOMIZING THE settings.xml in M2_HOME/conf , usually we customize settings.xml in ~/.m2/settings.xml!!!
										
										
									Once you start using Maven extensively, you'll notice that Maven has created some local user-specific configuration files and a local repository in your home
									directory. In ~/.m2 there will be:
											~/.m2/settings.xml
											A file containing user-specific configuration for authentication, repositories, and other information to customize the behavior of Maven.
											~/.m2/repository/
											This directory contains your local Maven repository. When you download a dependency from a remote Maven repository, Maven stores a copy of the
											dependency in your local repository.
											
										Help Plugin
											mvn help:describe -Dplugin=help -Dmojo=compile -Dfull
											
									Maven always execute against an effective POM,a combination of settings from this project's pom.xml,all parents POMs,a super POM defined within Maven,user defined 
									settings and active profiles.
									Maven plugin is a collection of one or more goals.
										pluginId:goalId
											Goals define parameters that can define sensible default values.
											
									The core of Maven has little to do with the specific tasks involved in your project’s build. By itself, Maven doesn’t know how to compile your code or even how to
									make a JAR file. It delegates all of this work to Maven plugins like the Compiler plugin and the Jar plugin, which are downloaded on an as-needed basis and
									periodically updated from the central Maven repository.
									Plugin goals can be attached to a lifecycle phase. As Maven moves through the phases in a lifecycle, it will execute the goals attached to each particular phase.
									Each phase may have zero or more goals bound to it.
										PHASES
											process-resources
											compile
											process-classes
											process-test-resources
											test-compile
											test
											prepare-package
											package
											
											
										Instead of executing a Maven lifecycle goal we could achieve the same results by specifying a sequence of plugins goals
											mvn resources:resources \
												compiler:compile \
												resources:testResources \
												compiler:testCompile \
												surefire:test \
												jar:jar \
												install:install
												
										Maven archetype is a Maven project templating toolkit
										An archetype is defined as an original pattern or model from which all other things of the same kind are made!!!
										https://maven.apache.org/guides/introduction/introduction-to-archetypes.html		
												
										We've highlighted the Maven coordinates for this project: the groupId, artifactId, version and packaging. These combined identifiers make up a
										project's coordinates.2Just like in any other coordinate system, a Maven coordinate is an address for a specific point in "space": from general to specific. Maven
										pinpoints a project via its coordinates when one project relates to another, either as a dependency, a plugin, or a parent project reference.
										We can't have a project with the same three groupId, artifactId, and version identifiers.
										Maven Space is a coordinate system of projects!!!
										What makes a Maven repository a Maven repository? The Maven repository is defined by structure, a repository is a collection of project artifacts stored in a
										structure and format which can be easily understood by Maven. In a Maven repository everything is stored in a directory structure that closely matches a project's Maven coordinates.
										You will see that an artifact with the coordinates org.apache.commons:commons-email:1.1 is available under the directory /org/apache/commons/commons-email/1.1/ in a file named
										commons-email-1.1.jar. The standard for a Maven repository is to store an artifact in the following directory relative to the root of the repository:
													/<groupId>/<artifactId>/<version>/<artifactId>-<version>.<packaging>
										Maven downloads artifacts and plugins from a remote repository to your local machine and stores these artifacts in your local Maven repository. Once Maven has
										downloaded an artifact from the remote Maven repository it never needs to download that artifact again as Maven will always look for the artifact in the local
										repository before looking else where.
										Support for transitive dependencies is one of Maven’s most powerful features!!!!
										
										Difference between "install" and "package" phases
											package -> just create the artifact and install it in the target directory
											install -> execute the "package" phase and install the artifact in the repository
											
										Difference between <plugins> and <pluginManagement>	
										
											pluginManagement is only a way to share the same configuration across all our project modules
											is an element that is seen along side plugins.However this only configures plugins that are actually referenced within the plugins element in the children.
											The children have the every right to override pluginManagement definitions.
											
											
											
											
										
											
									
										
															
															
														
														
												
													

																
																	
																	
																
																
															
															
													
													
													
												
												
														
															
														
														
														
															
											
										
										
											
									
									
														
														
																	
																	
															
														
														
														
														
															  
															  
												
											
											

															 
																		
																																										
																																								
																			
																	
												
																											
													
												
								
							
							