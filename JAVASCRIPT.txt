	ARCHITECTURE
	
		WEB.XML
			contains 
				Filter
				Listeners
				Modularization
				Asynchronous Responses
				
		In SweetDev there is a file called Services.xml where is defined all the "services" which include the DB_SERVICE
			In Cerise , this specific service use JNDI in Short it is defined in it the database information
				
		TOMCAT CONTAINS A FILE CALLED CONTEXT.XML
			This is where the resources are defined , JNDI names 
	
*************************************************************************************************/*JAVASCRIPT SUPER SUMMARY*/************************************************************************************
	PRIMITIVE VALUES : null undefined boolean string number
	REFERENCE TYPES  : object
	
	typeof      verify which type : primitive or reference
	instanceof  type of the object, if the instance is on the PROTOTYPE CHAIN
	
	EXECUTION CONTEXT
		Each Execution Context has an VARIABLE OBJECT associated with it.
		The Global execution is the outermost one, in the web browser is the WINDOW object.
		Each function call has its own execution context.
		Whenever code execution flows into a function,the function context is pushed onto a CONTEXT STACK!!!
		When code is executed in a context,a SCOPE CHAIN of variable objects is created!!!!
		
		Identifier LOOKUP !!!!
			Search through the SCOPE CHAIN
			OBJECTS IN THE SCOPE CHAIN ALSO HAVE A PROTOTYPE CHAIN, SO SEARCHING MAY INCLUDE EACH OBJECT PROTOTYPE CHAIN
	
	OBJECTS ARE CONSIDERED TO BE INSTANCES OF A PARTICULAR REFERENCE TYPE!!!NEW OBJECTS ARE CREATED BY USING THE NEW OPERATOR FOLLOWED BY A CONSTRUCTOR!!!
	A CONSTRUCTOR IS SIMPLY A FUNCTION!!!
			
				var person = new Object();
			This code creates a new instance of the Object reference type!!!
			
		Functions are OBJECTS !!!!Each Function is an instance of the Function type that has properties and methods.
			
			function sum(num1,num2){
				return num1 + num2;
			}
			
			var sum = function(num1,num2){
				return num1 + num2;
			}
			
			var sum = new Function("num1","num2","return num1+num2");
			
			Because function names are simply pointers to functions!!!
			Function internals :
				two properties :
					arguments , an array like object that has a property named CALLEE.
					this : REFERENCE TO THE CONTEXT OBJECT THAT THE FUNCTION IS OPERATING ON
					prototype : IS AN OBJECT!!!
					
			Every object has an internal pointer to the constructor prototype.

			Example :
				function Person(){
					this.obja = "ObjA";
					this.objb = "ObjB";
					this.getValuesInstance = function(){
						console.log("Values "+this.obja+" "+this.objb);
						}
				}

				Person.prototype.obja="ProtoA";
				Person.prototype.objb="ProtoB";
				Person.prototype.getValues = function(){
				   console.log("Values "+this.obja+" "+this.objb);
				}

				var p = new Person();  -> As an intenal pointer to Person.prototype
				p.getValues();		   -> Evidence of the above phrase
				Person.prototype.getValues(); -> The this is set to point to the prototype object
										THIS IS WHY THE LINE p.getValues() log ObjA ObjB AND THE LINE Person.prototype.getValues(); log ProtoA and ProtoB
										THE THIS VALUE IS SET WITH DIFFERENT CONTEXTS
				IF WE CALL Person.getValues one error  is thrown. The Person object does not look into the prototype property , it will use is internal pointer that points to the Object.prototype.
				
		Returning to the execution context and scope chain !!!
			Every time a function is executed , one execution context is created , within each execution context is a object called SCOPE CHAIN which is used to resolve variables.
			A scope chain is essentially a stack of currently accessible scopes.
			
			function(){
				var a = new Person();
				a.getValues();
			}
			
			
			function Person(){
				this.a = "a";
				var b = "b";
				this.getValues = function(){
					console.log(a);
					console.log(b);
					console.log(this.a);
				}
			}
			
			When getValues function is called a new execution context is created , within this execution context one scope chain is created , the first object in the scope chain is 
			the activation object which contains the following variables :
				this  -> Points to the a object , so it is through "this" that is possible to access properties from the object.
						In the above example the "console.log(a)" will throws an error because it is not in the scope chain
						It only works with the code "console.log(this.a)"
				arguments
				local variables
				
			Function object behind the length , arguments and this .
			Has the apply , call and bind methods -> All of them set the THIS properties form the function object!!!!
			
			Patterns 
				Factory Pattern
					function Person(){
						var o = new Object();
						o.a = "test";
						o.getValues = function(){}
						return o;
					}
					
				Constructor Pattern
					function Person(name,job){
						this.name = name;
						this.getValues = function(){}
					}
					
						Creates a new object
						Assign THIS value of the constructor to the new object
						Returns the new object.
						
				Prototype Patterns
					function Person(){}
					Person.prototype.name = "";
					Person.prototype.getValues = function(){}
					
					-------------------------------------------------
				   \/                                               |
					Person                       Person Prototype   |
						prototype -------------> constructor -------|
						                             ^      ^
							|------------------------|      |
						    |                               ------------|
					person1<|>	                                      person2
				
				Constructor / Prototype
				Parasitic Constructor Pattern
					Adding a return statement at the end of a constructor allows you to override the value that is returned when the constructor is called!!!
					This is usually apply when creating constructors for objects that may not be possible otherwise.
					For instance, create a special array.
				Durable Constructor Pattern
					Douglas Crockford coined the term durable objects in JavaScript to refer to objects that have no public properties and whose methods don't reference the this object.
					
						function Person(name, age, job){
							//create the object to return
							var o = new Object();
							//optional: define private variables/functions here
							//attach methods
							o.sayName = function(){
								alert(name);
							};
							//return the object
							return o;
						}
						
					Inheritance , execution context and scope chain
					
						function Father(){
							this.property;
						}
						
						Father.prototype.getValue = function(){
								return this.property;
						}
						
						function Son(){
							this.subProperty;
						}
						
						Son.prototype = new Father();
						Son.prototype.getSubValue = function(){ return this.subProperty;}
						
						var instance = new Son();
						instance.getValue();
						
						In this case :
							First we gonna look for the getValue function, start to look in the instance object , next we goona look in the Son.prototype , next we goona look in the Father prototyoe and
							found it
							A new execution context is created and scope chain associated with it
							The activation object contains the THIS property, this is set with the instance object!!!
							Because the next activation object in the scope chain will be the Global Context , the "property" value is not find.
							So it start looking in the "THIS" , next it will look in the THIS._proto_ , next THIS._proto_ and will find it !!!
							THE DEFAULT PROTOTYPE FOR ANY FUNCTION IS AN INSTANCE OF OBJECT.
							
							There is a problem with reference values on prototypes :
								function SuperType(){
									this.colors = ["red", "blue", "green"];
								}
								
								function SubType(){
								}
								//inherit from SuperType
								SubType.prototype = new SuperType();
								var instance1 = new SubType();
								instance1.colors.push("black");
								alert(instance1.colors); //"red,blue,green,black"
								var instance2 = new SubType();
								alert(instance2.colors); //"red,blue,green,black"
								
							Constructor Stealing
								
									function SuperType(name){
										this.name = name;
									}
									function SubType(){
										//inherit from SuperType passing in an argument
										SuperType.call(this, "Nicholas");
										//instance property
										this.age = 29;
									}
									var instance = new SubType();
									alert(instance.name); //"Nicholas"
									alert(instance.age); //29
									
							Combination Inheritance
								function SuperType(name){
									this.name = name;
									this.colors = ["red", "blue", "green"];
								}
								SuperType.prototype.sayName = function(){
									alert(this.name);
								};
								function SubType(name, age){
									//inherit properties
									SuperType.call(this, name);
									this.age = age;
								}
								//inherit methods
								SubType.prototype = new SuperType();
								SubType.prototype.sayAge = function(){
									alert(this.age);
								};
								var instance1 = new SubType("Nicholas", 29);
								instance1.colors.push("black");
								alert(instance1.colors); //"red,blue,green,black"
								instance1.sayName(); //"Nicholas";
								instance1.sayAge(); //29
								
							Prototypal Inheritance
								function object(o){
									function F(){}
									F.prototype = o;
									return new F();
								}
								Essentially, object() performs a shadow copy of any object that is passed into it.
								ECMAScript 5 formalized the concept of prototypal inheritance by adding the Object.create() method.
								This method accepts two arguments, an object to use as the prototype for a new object and an optional object defi ning additional properties to apply to the new object.
									The second argument for Object.create() is in the same format as the second argument for Object.defineProperties(): each additional property to define is specified 
									along with its descriptor. Any properties specified in this manner will shadow properties of the same name on the prototype object.
									
							Parasitic Combination Inheritance
									
					
							CLOSURES
								function expressions
								function declarations -> function declaration HOISTING
									named function expressions
										var factorial = (function f(num){
											if(num < 1){
												return 1;
											}else{
												return num * f(num -1);
											}
										});
										
									Immediatelly-Invoked Function Expression(IIFE)
										(function(){...}) ----> Turn the code within the parentheses into an expression.
										(function(){...})() --> Calls the function that results from that evaluated expression.
											This pattern is used when tryng to avoid polluting the global namespace.
											
										function(){...}() -> SyntaxError
											When the parser encounters the function keyword in the global scope or inside a function, it treats it as a function declaration (statement), and not as a function expression, 
											by default. If you don't explicitly tell the parser to expect an expression, it sees what it thinks to be a function declaration without a name and 
											hrows a SyntaxError exception because function declarations require a name.
											
										MIMIC BLOCK SCOPE
											function(){
												//block code here
											}(); //error!
											This code causes a syntax error,because Javascript sees the function keyword as the beginning of a function declaration,and function declarations cannot be
											followed by parentheses!!!!FUNCTION EXPRESSIONS,HOWEVER,CAN BE FOLLOWED BY PARENTHESES.TO TURN THE FUNCTION DECLARATION INTO A FUNCTION EXPRESSION,WE NEED 
											ONLY TO SURROUND IT WITH PARENTHESES :
												(function(){
													//block code here
												})();
												
												
												function outputNumbers(count){
													(function () {
														for (var i=0; i < count; i++){
														alert(i);
														}
													})();
													alert(i); //causes an error
												}
												
												This technique is often used in the global scope outside of functions to limit the number of variables
												and functions added to the global scope. Typically you want to avoid adding variables and functions
												to the global scope, especially in large applications with multiple developers, to avoid naming
												collisions. Private scopes allow every developer to use his or her own variables without worrying about polluting the global scope.
												
											
									THIS INSIDE CLOSURES
										When used inside global functions,THIS is equal to WINDOW in nonstrict mode and undefined in strict mode.
										THIS is equal to the object when called as an object method.
										Anonymous function are not bound to an object in this context,meaning the THIS object points to WINDOW unless executing in strict mode
										
											var name = "The Window";
											var object = {
												name : "My Object",
												getNameFunc : function(){
													return function(){
													return this.name;
													};
												}
											};
											alert(object.getNameFunc()()); //"The Window" (in non-strict mode)
											
											var name = "The Window";
											var object = {
												name : "My Object",
												getNameFunc : function(){
												var that = this;
												return function(){
													return that.name;
													};
												}
											};
											alert(object.getNameFunc()()); //"My Object"
											
											There are two ways to create privileged methods on objects:
											
											function MyObject(){
												//private variables and functions
												var privateVariable = 10;
												function privateFunction(){
													return false;
												}
												//privileged methods
												this.publicMethod = function (){
													privateVariable++;
													return privateFunction();
												};
											}
											
											function Person(name){
												this.getName = function(){
													return name;
												};
												this.setName = function (value) {
													name = value;
												};
											}
											
											VERY IMPORTANT CONCEPT : Since both methods are defined inside the constructor, they are closures and have access to name through the scope chain.
											
											Static Private Variables
												(function(){
													//private variables and functions
													var privateVariable = 10;
													function privateFunction(){
														return false;
													}
													//constructor
													MyObject = function(){
													};
													//public and privileged methods
													MyObject.prototype.publicMethod = function(){
														privateVariable++;
														return privateFunction();
													};
												})();
												
												Public methods are defined on the prototype, as in the typical prototype pattern. Note that this
												pattern defines the constructor not by using a function declaration but instead by using a function expression. 
												Function declarations always create local functions, which is undesirable in this case.
												For this same reason, the var keyword is not used with MyObject. Remember: initializing an undeclared variable always creates a global variable, 
												so MyObject becomes global and available outside the private scope.
												The main difference between this pattern and the previous one is that private variables and functions are shared among instances.
												
								The Module Pattern
									var singleton = {
										name : value,
										method : function () {
											//method code here
										}
									};
									
									The module pattern augments the basic singleton to allow for private variables and privileged methods, taking the following format:
									var singleton = function(){
										//private variables and functions
										var privateVariable = 10;
										function privateFunction(){
											return false;
										}
										//privileged/public methods and properties
										return {
											publicProperty: true,
											publicMethod : function(){
												privateVariable++;
												return privateFunction();
											}
										};
									}();
											
								
							
				Important functions
					Object.hasOwnProperty
					Object.isPrototypeOf
					Object.getPrototypeOf
					Object.keys -> Enumerable properties
					Object.getOwnPropertyNames -> All properties (enumerable or not)
					instanceof
					typeOf
					
				in OPERATOR
					Used on its own : Returns true when a property of a given name is accessible by the object(instance or prototype)
					Used in for-in loop : All properties that are accessible by the object and can be enumerated.

		Types of properties on objects :
			Data properties
				[[Configurable]] [[Enumerable]] [[Writable]] [[Value]]
				
				Object.defineProperty
				
			Accessor Properties(combination of a getter function and a setter function)
				[[Configurable]] [[Enumerable]] [[Get]] [[Set]]
				
				Object.defineProperties()
				Object.getOwnPropertyDescriptor()
			
			Scope-safe Constructors
			Lazy Loading Functions
			Tamper-Proof Objects
				Once an object has been made tamper-proof, the operation cannot be undone.
				By default, all objects in JavaScript are extensible, meaning that we can add additional properties and methods to the object at any time.
					NonExtensible
						Object.preventExtensions(person);
						After the call to Object.preventExtensions(), the person object can no longer have new properties or methods added.
						We can still modify and delete already-existing members.
						Object.isExtensible(person)
					Sealed
						The next level of protection for objects in ECMAScript 5 is a sealed object. Sealed objects aren’t extensible and existing object members have their [[Configurable]] attribute set to false. 
						This means properties and methods can’t be deleted as data properties cannot be changed to accessor properties or vice versa using Object.defineProperty(). Property values can still be changed.
					Frozen
						The strictest type of tamper-proof object is a frozen object. Frozen objects aren’t extensible and are sealed, and also data properties have their [[Writable]] attribute set to false. 
						Accessor properties may still be written to but only if a [[Set]] function has been defined.
				
			Cookies
			Web Storage
			IndexedDB
			Function Binding
			Function Currying
			Page Visibility	
				
			Web Timing
				Page performance is always an area of concern for web developers.
				The center of Web Timing is the window.performance object.
				All metrics related to the page, both those already defined and those in the future, exist on this object.
			GeoLocation API	
				
			Web Workers
				Browsers may choose to implement Web Workers in any number of ways, including threads, background processes, and processes run on other processor cores.
					var worker = new Worker("stufftodo.js";
					Page communicates with the Worker similar to the XDM API:
						worker.postMessage("start!"	);
					The worker communicates back to the page through two events: message and error.	
						self.onmessage = function(event){
							var data = event.data;
							//remember, by default sort() does a string comparison
							data.sort(function(a, b){
							return a – b;
							});
							self.postMessage(data);
						};
						
					worker.terminate(); //stop the worker immediately
						The most important thing to understand about a Web Worker is that its JavaScript is executed in a completely different scope than code in the web page. 
						There is a different global object and different objects and methods available inside of a Web Worker.
						Inside of a Web Worker, there is no access to the DOM and, indeed, no way to affect the appearance of a page in any way.
						The global object inside of a Web Worker is the worker object itself.
						
    /*******************************************************************************************************************************************************************/	
													        JAVASCRIPT					
												ECMASCRIPT(The Core)  DOM   BOM
												
										An host environment provides the base implementation of ECMAScript and implementation EXTENSIONS(like DOM and BOM) designed 
                                        to interface with the environment itself.Extensions,such as the DOM,use ECMAScript core types and syntax to provide additional 
										functionality that is more specific to the environment.		

			DOM Levels
				DOM 1 : DOM Core (Map the structure of an XML-based document to allow for easy access to and manipulation of any part of a document)
						DOM HTML : Extended the Core by adding HTML specific objects and methods
						
				DOM 2 : Support for mouse and user interface events,ranges,traversals(iterate over a DOM document) and support for CSS through object interfaces.
						Support for XML Namespaces.
						Introduces the following new modules of the DOM to deal with the new types of interfaces:
							DOM VIEWS : Describe interfaces to keep track of the various views of a document(the document before and after CSS)
							DOM EVENTS
							DOM STYLE
							DOM TRAVERSAL AND RANGE
				DOM 3 : Methods to Load and Save an document in a uniform way and methods to validate a document
						The Core is extended to support all of XML1.0,including XML Infoset,XPath and XML Base.
						
			
			BOM Deals with browser window and frames but generally any browser-specific extension to Javascript is considered to be part of the BOM.
				Pop up new Browsers Windows
				Move , resize and close browser windows
				Navigator object
				Location object
				Screen object
				Support for cookies
				Custom objects such as XMLHttpRequest or ActiveXObject
				
					NO STANDARD EXISTED FOR THE BOM FOR A LONG TIME,EACH BROWSER HAS ITS OWN IMPLEMENTATION.
					HTML5 TRY TO FIX THAT ISSUE!!!
					
		<script> element
				attributes 
					async   : 
					language
					type
					src
					charset
					defer
				ONE OF THE MOST POWERFUL AND MOST CONTROVERSIAL PARTS OF THE <SCRIPT> ELEMENT IS ITS ABILITY TO INCLUDE JAVASCRIPT FILES FROM OUTSIDE DOMAINS!!!!MUCH LIKE THE IMG ELEMENT.
				INCLUDING ALL JAVASCRIPT FILES IN THE <HEAD> OF A DOCUMENT MEANS THAT ALL OF THE JAVASCRIPT CODE MUST BE DOWNLOADED,PARSED AND INTERPRETED BEFORE THE PAGE BEGINS RENDERING
				(RENDERING BEGINS WHEN THE BROWSER RECEIVES THE OPENING <BODY> TAG).FOR PAGES THAT REQUIRED A LOT OF JAVASCRIPT CODE,THIS CAN CAUSE A NOTICEABLE DELAY IN PAGE RENDERING!!!
				MODERN PAGES TYPICALLY INCLUDE ALL JAVASCRIPT REFERENCES IN THE <BODY> ELEMENT,AFTER THE PAGE CONTENT 
				
					<body>
						<!-- content here -->
						<script type="text/javascript" src="example1.js" />
						<script type="text/javascript" src="example2.js" />
					</body>

					defer : Indicates the script will not be changing the structure of the page as it executes.As such,the script can be run safely after the page the entire page has been parsed.
					        THE DOWNLOAD SHOULD BEGIN IMMEDIATELY BUT EXECUTION SHOULD BE DEFERRED!!!
						     THE SCRIPTS JUST BEGIN TO EXECUTE AFTER THE BROWSER HAS RECEIVED THE CLOSING <HTML> ELEMENT!!!
							NORMALLY THE DEFER SCRIPTS EXECUTE BEFORE THE DOMContentLoaded event has occur but IS NOT GUARANTEED!!!
							
					asyn : Similar to "defer" attribute , only applies to external scripts and signal the browser to begin downloading the file immediately.
						   UNLIKE "defer" scripts marked as async are not guaranteed to execute in the order in which they are specified.
						   SO IT IS IMPORTANT THAT THERE ARE NO DEPENDENCIES BETWEEN THE TWO!!!The purpose of the attribute is to indicate that the page need not wait 
						   for the script to be downloaded and executed before continuing to load and it also need not wait for another script to load and execute before it can do the same.
						   Becauseof this is, it is not recommended that asynchronous scripts not modify the DOM as they are loading.
						   ASYNCHRONOUS SCRIPTS ARE GUARANTEED TO EXECUTE BEFORE THE PAGE LOAD EVENT AND MAY EXECUTE BEFORE OR AFTER DOMContentLoaded
						   
						   PAGE LIFECYCLE :
							DOMContentLoaded    : the browser fully loaded HTML,and the DOM tree is built , but external resources like pictures <img> and stylesheets may be not yet loaded.
							Load                : The browser loaded all resources (images,styles ...)
							beforeunload/unload : When the user leaves the page
							
				DOCUMENT NODES
					Quirks mode   : Omit the doctype at the beginning of the document.Poor practice , quirks mode is very different across all browsers.
					Standard mode : 
									<!--HTML 4.01 Strict-->
									<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
									
									<!-- XHTML 1.0 Strict -->
									<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
									
									<!-- HTML5 -->
									<!DOCTYPE html>
					Almost Standard mode
										Triggered by transitional and frameset doctypes !!!
									<!-- HTML 4.01 Transitional -->
									<!DOCTYPE HTML PUBLIC"-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
									<!-- HTML 4.01 Frameset -->
									<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">
									<!-- XHTML 1.0 Transitional -->
									<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
									<!-- XHTML 1.0 Frameset -->
									<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
									
				Javascript Strict Mode
					To enable strict mode for an entire script 
							"use strict";
					Just a function to execute in strict mode
							function doSomething(){
								"use strict";
								...
							}
							
				The VAR operator makes a variable local to the scope in which was defined !!!!
				OMITING THE VAR OPERATOR TURNS A VARIABLE GLOBAL!!!!
				
		DATA TYPES
				5 simple datatypes : UNDEFINED , NULL , STRING , NUMBER , BOOLEAN [Primitive datatypes]
				[Complex datatype] : Object
				There is no way to define our own data types in ECMAScript.
				Typeof null returns "Object" because the special value NULL is considered to be an empty object reference.
				Typeof returns UNDEFINED in NON DECLARED VARIABLE AND IN VARIABLE NOT INITIALIZE !!!!
				
				Using equality operador (==) between NULL and UNDEFINED always return true!!!This operand converts its operands for comparison purposes.
				Undefined is a derivative of null!!!
				
				Boolean 
					All types of values have booleans equivalents in ECMAScript.To convert a value into its Boolean equivalent,the special Boolean()  casting function is called :
						String 
							  Any non empty string  -> True  Empty string -> False
						Number 
							Any nonzero number(including infinity) -> True 0,NaN -> False
						Object
							Any object -> True Null -> false
						Undefined 
                             None
				Number
					Uses IEEE-754 format to represent both integers and floating-point values.
					Octal
						Leading zero
					Hexadecimal
						0x
					Floating points can be represented using e-notation !!!
						Used to indicate a number that should be multiplied by 10 raised to a given power.
						Floating-point values are accurate up to 17 decimal places but are far less accurate in arithmetic computations than whole numbers.
						We should never test for specific floating point values!!!
					NaN
						Indicate when an operation intended to return a number has failed , for example , dividing any number by 0.
						Any operation involving NaN always returns NaN.
						NaN is not equal to any value, including NaN!!!!
						We should use isNaN function !!!!
					Numbers conversions:
						3 functions
							Number() casting function -> Applied to any object
								Booleans return 1 or 0.
								NULL returns 0.
								Undefined returns NaN
								String
									Strings contain only numbers are converted to decimal values
									String contains floating point converts to floating points
									String contains hexadecimal value converts to an integer that matches the hexadecimal value.
									String empty converts to 0.
									String contains anything other that these previous formats, it is converted into NaN.
								Objects
									valueOf is called and the returned value is converted based on the previous described rules.
									if the conversion results in NaN the toString() method is called and the rules for converting String are applied.
							parseInt()   -> Only applied to Strings
								It is better when converting numbers!!!!
								   parseInt("1234Blue") ---> 1234
								   parseInt("10",2) ---> 2
							parseFloat() -> Only applied to String much more closely to see if it matches a number pattern.
								   Only parses decimal values,there is no radix mode.
								   parseFloat("1234Blue")----> 1234
								   parseFloat("22.5");-------> 22.5
								   parseFloat("22.34.25")----> 22.34
								   parseFloat("0908.5")------> 908.5
				String data type
					REPRESENTS A SEQUENCE OF ZERO OR MORE 16 BIT UNICODE!!!!
					Strings are immutables !!!!
		
		OBJECT IS THE BASE FOR ALL OBJECTS IN ECMASCRIPT!!!
			each object instance has the following properties and methods:
				constructor
				hasOwnProperty
				isPrototypeOf
				prototypeIsEnumerable
				toLocaleString
				toString
				valueOf
				
		Bitwise Operators
			All numbers in ECMAScript are stored in IEEE-754 64 bit-format but the bitwise operators convert the value into a 32 bit integer!!!
				Left Shift preserves the sign number!!
				Signed Right Shift preserves the sign number.
		Boolean Operators
			Logical Not
				May be applied to any value in ECMAScript.Always return a Boolean value.
						If operand is an object,FALSE is returned.
						if operand is an empty String , true is returned.
						non empty String , true is returned
						number 0 -> true
						Any number other than 0 -> False is returned
						null -> true
						NaN -> true
						undefined -> true
						
				Using two NOT operators we get the same result has using Boolean() casting function!!!
			Logical AND
				If the first operand is an object ,then the second operand is always returned.
				If the second operand is an object,then the object is returned only if the first operand evaluates to true.
				IF BOTH OPERANDS ARE OBJECTS,THEN THE SECOND OPERAND IS RETURNED!!!!!
				If either operand is null,then null is returned
				If either operand is NaN, then NaN is returned
				If either operand is undefined,then undefined is returned.
			Logical OR	
				If the first operand is an object ,then the FIRST operand is always returned.
				If the first operand evaluates to false,then the second operand is returned.
				IF BOTH OPERANDS ARE OBJECTS,THEN THE FIRST OPERAND IS RETURNED!!!!!
				If BOTH operand is null,then null is returned
				If BOTH operand is NaN, then NaN is returned
				If BOTH operand is undefined,then undefined is returned.
				
				WE CAN ALSO USE THE OR OPERATOR TO AVOID ASSIGNING A NULL OR UNDEFINED VALUE TO A VARIABLE.
					var myObject = preferredObject || backupObject
					
			Multiplicative Operators 
				Automatic type conversion, use the Number() casting function
			Additive Operators
				Automatic type conversion, use the Number() casting function
				If one operand is a String the other is converted to a String and the result is the concatenation of the two Strings.
		
		Relational Operators
			Both Numbers -> numeric conversion
			Both Strings -> Compare the character codes 
			One operand is Number - > Convert the other operand to a number and perform a numeric comparison.
			One operand is an object -> call valueOf() and use its results to perform the comparison according to the previous rules.If valueOf() is not available,call toString() and use that
			value according to the previous rules.
			Boolean -> convert to Number 
		Equality Operators
			== && !==
				Do conversions before comparison
					If an operand is a boolean -> convert it into a numeric value
					If an operand is a String and the other is a number , attempt to convert the string into a number 
					If one of the operands is an object and the other is not,the valueOf method is called 
					If both are objects , compare the reference !!!
					null and undefined are equal
					NaN is never equal to NaN
					
			=== && !===
				DO NOT DO CONVERSIONS!!!
		Switch Statement
			Has some unique characteristics in ECMAScripts :
				Works with all data types 
				USES THE IDENTICALLY EQUAL OPERATORS!!!!
				Case values need not be constants , can be variables and even expressions
				
					switch("hello world"){
						case "hello" + "world" : ...;break;
						...
					}
					
					var num = 25;
					switch(true){
						case num < 0 : ...;break;
						case num > 0 && num <= 10 ; ...
						....
					}
					
		Function Arguments	
			An ECMAScript function does not care how many arguments are passed in, JUST BECAUSE WE DEFINE A FUNCTION TO ACCEPT TWO ARGUMENTS DOES NOT MEAN WE CAN PASS IN ONLY TWO ARGUMENTS.
			This happens because arguments in ECMAScript are represented as an array internally!!!!
			
			function sayHi(){
				alert(arguments[0]+' '+arguments[1]);
			}
			
			arguments object acts like an array , THOUGH IT IS NOT AN INSTANCE OF ARRAY !!!!!
			arguments values always stay in SYNC with the values of the corresponding NAMED parameters.This effect goes only one way!!!!:changing the named argument does not result in a change to the 
			corresponding value in arguments!!!
			
			Two types of data :
				PRIMITIVE -> null,undefined,Number,String,Boolean
				REFERENCE -> Objects
				
			All function arguments are passed by VALUE !!!!!!	
			
				function setName(obj){
					obj.name = "Nicholas";
					obj = new Object();
					obj.name = "Greg";
				}
				
				var person = new Object();
				setName(person);
				alert(person.name); -> //Nicholas
				
				If the arguments were passed by reference , the person variable will be set with the object containing the "Greg" name;
				
				typeof operator -> determine the object type -> string/boolean/number/undefined/object
				instanceof operator -> Type of Object
				
				typeof is a construct that "returns" the primitive type of whatever you pass it.
				instanceof tests to see if the right operand appears anywhere in the prototype chain of the left.

				It is important to note that there is a huge difference between the string literal "abc", and the string object new String("abc"). 
				In the latter case, typeof will return "object" instead of "string".
				
			EXECUTION CONTEXT
				When code is executed in a context,a scope chain of variable objects is create.The front of the scope chain is always the variable object of the context whose code is executing.
				if the context is a function,then the activation object is used as the variable object!!!An activation object starts with as single defined variable called ARGUMENTS!!!
				THERE ARE ONLY TWO TYPES OF EXECUTION CONTEXTS -> GLOBAL AND FUNCTION
				(The third exists inside of a call to eval())
				When a variable is declared using VAR it is automatically added to the most immediate context available.
				If the VAR keyword is ommitted it becomes accessible in the global context.
				
			GARBAGE COLLECTOR
				Mark and Sweep
				Reference Counting 
					Every value keeps track of how many references are made to it.
					When a variable is declared and a reference value is assigned , the reference count is one.If another variable is assigned the same value,the reference count is incremented.
					When the reference count of a value reaches zero,there is no way to reach that value and it is safe to reclaim the associated memory.
						function problem(){
							var oA = new Object(); // This object has reference count equal to one
							var oB = new Object(); // This object has reference count equal to one
							
							oA.someOther = oB;  //Reference count equal to two
							oB.another = oA;   //Reference count equal to two
						}
					Problem with Circular References 
						In the Mark and Sweep system,this would not be a problem because both objects go out of scope after the function has completed!!!
						
					Not all objects in Internet Explorer are native Javascript objects.Objects in the BOM and DOM are implemented as COM objects in C++, and COM objects use reference counting for garbage collection.
					So even though the IE Javascript engine uses a Mark and Sweep implementation, any COM object that are accessed in Javascript still use reference counting, meaning circular references are still
					a problem when COM objects are involved.
					
				Using OBJECT LITERAL NOTATION property names can be specified as Strings or Numbers

					var person = {
						"name" : "Nicholas",
						"age" : 29,
						5 : true
					};

				 We can access object properties through dot notation or through brackets
					alert(person.name);
					alert(person["name"]); -> The main adaventage is the ability to use variables for property access or when the property name contains characters that would be either a syntax error or a reserved keyword
					person["first name"] = "Nicholas";
						
			ARRAY TYPE
				The length property is not READ ONLY, change it will augment or reduce the array.
				There is no array out of bond exception !!!Adding a value to an index bigger the length will augment the array with length equal to the index value!!!
				DETECTING AN ARRAY !!!!
					If there is only one GLOBAL EXECUTION CONTEXT the instanceof operator works well!!!!
					If we are dealing with multiple frames in a web page, we are dealing with two distincts global execution context and therefore two versions of the Array constructor.
					To work around this problem,ECMAScript 5 introduced the Array.isArray() method.
					Iterative methods:
						every()
						filter()
						forEach()
						map()    -----|
						some()        |
									  |->	var numbers = [1,2,3]
											numbers.map(function(item.index.array){return item * 2;}); -> [2,4,6]
					Reduce Methods
						reduce and reduceRight
							Both iterate over all items in the array and build up a value that is ultimately returned.
							var values = [1,2,3];
							var sum = values.reduce(function(prev,cur,index,array){return prev + cur;}); ----> 6
							
			Regular Expressions
				Regular Expressions literals always share the same RegExp instance,while creating a new RegExp via constructor always
				results in a new instance.
					STUDY IN DEPTH!!!!!
					
			FUNCTION TYPE
				Functions are actually objects.Each function is an instance of the Function type that has properties and methods like any other reference type.
					Valid syntax
						var sum = new Function("num1","num2","return num1 + num2");
						
				Function Internals
					Two specials objects exist inside a function : arguments and this!!!
						arguments is an array-like object and has a property named CALLEE,which is a pointer to the function that owns the arguments object.
							function factorial(num){
								if(num <= 1){
									return 1;
								}else{
									return num * arguments.callee(num - 1);
								}	
							}
						
						THIS -> It is a reference to the CONTEXT OBJECT where the function is operating on!!!
						        The value of THIS is not determined until the function is called.
								
					EcmaScript5 also formalizes an additional property on a function object : CALLER !!!
						References the function that called this function or null if the function was called from the global scope.
					
				Functions are objects in ECMAScript , therefore have properties and methods.Each function has two properties :
					LENGTH -> number of named arguments
					PROTOTYPE
					
					Methods
						apply() 
						call()
						bind()
						
						The true power of those methods lies in their ability to augment the THIS value inside of the function:
							
							window.color = "red";
							var o = {color : "blue"}
							
							function sayColor(){
								alert(this.color);
							}
							
							sayColor();  //red
							
							sayColor.call(window);  //red
							sayColor.call(this); //red
							sayColor.call(o); //blue
							
						window.color = "red";
						var o = {color : "blue"};
						
						function sayColor(){
							alert(this.color);
						}
						
						var objectSayColor = sayColor.bind(o);
						objectSayColor(); //blue
						
			PRIMITIVE WRAPPER TYPES
				Every time a primitive value is read, an object of the corresponding primitive wrapper type is created behind the scenes, allowing access to any number of methods for manipulating 
				the data : 
					var s1 = "some text";  ----> PRIMITIVE VALUE!!!!
					var s2 = s1.substring(2);
							 In the second line the substring() method is called, primitive values are not objects , so they should not have methods!!!
							 When s1 is accessed, it is being accessed in READ MODE !!! So the following steps occur :
								1: CREATE AN INSTANCE OF THE STRING TYPE
								2: CALL THE SPECIFIED METHOD ON THE INSTANCE
								3: DESTROY THE INSTANCE
								
						When use the Boolean type in Boolean expressions :
							var falseObject = new Boolean(false);
							var result = falseObject && true; ----> ALL OBJECTS ARE AUTOMATICALLY CONVERTED TO TRUE IN BOOLEAN EXPRESSIONS!!!
							alert(result); //true
							
							var falseValue = false;
							result = falseValue && true;
							alert(result); // false
							
							typeof falseObject -> object
							typeof falseValue  -> boolean
							
							falseObject instanceof Boolean -> true
							falseValue instanceof  Boolean -> false
			
				Types of properties
					Data properties
						[[Configurable]]::Can a property may be redefined by removing the property via delete,changing the property attribute or changing the property into an accessor property
						[[Enumerable]] Returned in the for-in loop
						[[Writable]]::Can a property value be changed
						[[Value]]::The actual value of the property
							Object.defineProperty(person,"name"{
								writable : false,
								value : "Nicholas"
							})
							
							person.name -> "Nicholas"
							person.name = "Greg";
							person.name -> "Nicholas"
							
					Accessor properties
						[[Configurable]]
                        [[Enumerable]]
						[[Get]]
						[[Set]]
							var books = {_year : 2004,
							             edition : 1};
							Object.defineProperty(book,"year",{get : function(){return this._year;},
							                                   set : function(newValue){if(newValue > 2004){this._year = newValue;this.edition += newValue - 2004;}}})

							bok.year  = 2005;
							book.edition -> 2
							
					//Prior to ECMAScript 5, there was two nostandard methods to create accessor properties :
						__defineGetter__() and __defineSetter__()
						
					MULTIPLE PROPERTIES ARE DEFINED THROUGH THE Object.defineProperties()
					READ PROPERY ATTRIBUTES
						Object.getOwnPropertyDescriptor
						
				OBJECT CREATION
					Factory Pattern
						With no way to create classes in ECMAScript,developers created functions to encapsulate the creation of objects with specifics interfaces.
						
							function createPerson(name,age,job){
								var o = new Object();
								o.name = name;
								o.age = age;
								o.job = job;
								o.sayName = function(){alert(this.name);};
								return o;
							}
							PROBLEM ->->->->->-> WHAT TYPE OF OBJECT AN OBJECT IS
					Constructor Pattern
						
						   function Person(name,age,job){
							this.name = name;
							this.age = age;
							this.job = job;
							this.sayName = function(){alert(this.name);};
						   }
						   
						   Calling a constructor in this manner essentially causes the following four steps to be taken :
						   
							1 : Create a new object 
							2 : Assign the THIS value of the constructor to the new object(so THIS points to the new object)
							3 : Execute code inside constructor
							4 : Return the new object
							
							EACH INSTANCE CONTAINS A constructor PROPERTY THAT POINTS BACK TO THE CONSTRUCTOR FUNCTION!!!
							
							DISADVANTAGE : Methods are created once for instance!!!	
							Each instance of Person gets its own instance of Function :
								person1.sayName == person2.sayName -> false
								
								
					Prototype Pattern 
						    
							EACH FUNCTION IS CREATED WITH A PROTOTYPE PROPERTY , WHICH IS AN OBJECT CONTAINING PROPERTIES AND METHODS THAT SHOULD BE AVAILABLE TO INSTANCES OF A PARTICULAR REFERENCE TYPE.
							
							function Person(){}
							
							Person.prototype.name = "Nicholas";
							Person.prototype.age = 29;
							Person.prototype.job = "Software Enginner";
							Person.prototype.sayName = function(){alert(this.name);};
							
							HOW PROTOTYPES WORK
								Whenever a function is created,its PROTOTYPE property  is also created according to a specific set of rules.
								By default,all prototypes automatically get a property called CONSTRUCTOR that points back to the function on which is a property.
								Each time the constructor is called to create a new instance,that instance has an internal pointer to the constructor prototype !!!!
									(There is no standard way to access [[Prototype]] from script,but Firefox, Chrome and Safari support a property on every object called __proto__)
								

							  ----------------------------------------------------------------------------|
							  |->  		PERSON											PERSON PROTOTYPE  |
									prototype ---------------------------------------->constructor -------|
									                                                   name
																					   age            <--------------------------|
																					   job                                       |
																					   ....                                      |
																					                                             |
									person1                                                                                      |
								[[Prototype]]------------------------------------------------------------------------------------|
								
								DISADVANTAGE : All properties are shared among instances!!!
					
					Two methods isPrototypeOf and getPrototypeOf
					
					THE CONSTRUCTOR PROPERTY EXISTS ONLY ON THE PROTOTYPE AND SO IS ACCESSIBLE FROM OBJECT INSTANCES
					
					Once a property is added to the object instance,it shadows any properties of the same name on the prototype.Even setting the property to NULL only sets the property on the instance 
					and does not restore the link to the prototype.The DELETE operator completely removes the instance property and allows prototype property to be accessed again!!!!
					
					The hasOwnProperty method determines if a property exists on the instance or on prototype
					THE OBJECT.GETOWNPROPERTYDESCRIPTOR() METHOD WORKS ONLY ON INSTANCE PROPERTIES, TO RETRIEVE THE DESCRIPTOR OF A PROTOTYPE PROPERTY WE MUST CALL THE METHOD ON THE PROTOTYPE OBEJCT DIRECTLY.
					
					Object.keys() method retrieves a list of all enumerable instance properties on an object.
					Object.getOwnPropertyNames retrieves a list of all instance properties EITHER ENUMERABLE OR NOT !!!!
					
					Combination Contructor/Prototype Pattern
					
						function Person(name,age,job){
							this.name = name;
							this.age = age;
							this.job = job;
							this.friends = ["Shelby","court"];
						}
						
						Person.prototype = {
							constructor : Person,
							sayName : function (){alert(this.name;)};
						}
						
						THIS PATTERN IS THE MOST WIDELY USED AND ACCEPTED PRACTICE FOR DEFINING CUSTOM REFERENCES TYPES IN ECMASCRIPT !!!!
						
					Dynamic Prototype Pattern
						function Person(name,age,job){
							this.name = name;
							this.age = age;
							this.job = job;
							
							if(typeOf this.sayName != "function"){
								Person.prototype.sayName = function (){alert(this.name);};
							}
						}
						
					Parasitic Constructor Pattern
						function Person(name,age,job){
							var o = new Object();
							o.name = name;
							o.age = age;
							o.job = job;
							o.sayName = function (){alert(this.name);};
							return o;
						}
						
						WHEN A CONSTRUCTOR DOES NOT RETURN A VALUE,IT RETURNS THE NEW OBJECT INSTANCE BY DEFAULT , ADDING A RETURN STATEMENT AT THE END OF A CONSTRUCTOR ALLOWS US TO OVERRIDE 
						THE VALUE THAT IS RETURNED WHEN THE CONSTRUCTOR IS CALLED.
						
						This pattern allows to create constructors for objects that may not be possible otherwise. <---- REASON WE USE IT!!!!
						
						function specialArray(){
							var values = new Array();
							....
						}
						
						This is exactly the same as the factory pattern except that the function is called as a constructor, using the new operator!!!!!!!
					
					Durable Constructor Pattern
						Refer to objects that have no public properties and whose methods do not reference the this object.
						
						function Person(name,age,job){
							var o = new Object();
							
							//optional: define private variables/functions here
							
							//attach methods
							o.sayName = function (){alert(name);}
							
							return o;
						}
						
						The name property is ONLY accessed through the method !!!!
						
						INHERITANCE
							Two types of inheritance:
								interface inheritance      :Only the method signatures are inherited (not possible in Javascript , because functions do not have signatures)
								Implementation inheritance : Actual methods are inherited
									PROTOTYPE CHAINING :
										What if the prototype were actually an instance of another type ?
											That would mean the prototype itself would have a pointer to a different prototype that,in turn , would have a pointer to another constructor.
											
								function SuperType(){
									this.property = true;
								}
								
								SuperType.prototype.getSuperValue = function (){return this.property;};
								
								function SubType(){
									this.subproperty = false;
								}
								
								SubType.prototype = new SuperType();
								
								SubType.prototype.getSubValue = function (){return this.subproperty;};
								
								Default prototypes
									In reality, there is another step in the prototype chain.All reference types inherit from Object by default,which is accomplished through prototype chaining.
									The default prototype for any function is an instance of Object,meaning that its internal prototype pointer points to Object.prototype.
									This is how custom types inherit all of the default methods such as toString() and valueOf().
									
						Prototype Chaining has the problem of the prototypes contain references values, they are shared between all instances.

						Combination Inheritance
							Combines prototype chaining and constructor stealing.The basic idea is to use Prototype Chaining to inherit properties and methods on the prototype and to use constructor stealing to
							inherit  instance properties.
							
							function SuperType(name){
								this.name = name;
								this.colors = ["blue","white","black"];
							}
							
							SuperType.prototype.sayName = function (){alert(this.name);};
							
							function SubType(name,age){
								SuperType.call(this,name);
								this.age = age;
							}
							
							SubType.prototype = new SuperType();
							SubType.prototype.sayAge(){alert(this.age);};
							
						PROTOTYPAL INHERITANCE
							Method of inheritance that did not involve the use of strictly defined constructors.
							Prototypes allows us to create new objects based on existing objects without the need for defining custom types!!!
							
							function object(o){
								function F(){};
								F.prototype = o;
								return new F();
							}
							
							ECMAScript5 formalizes the concept of prototypal inheritance by adding the Object.create() method.
							
						CLOSURES

							The terms anonymous functions and closures are often incorrectly used interchangeably!
							Closures are functions that have access to variables from another function's scope.
							When a function is called,an execution context and its scope chain is created.The activation object for the function is initialized with the 
							values for ARGUMENTS any named argument.The outer function activation object is the second object in the scope chain.This process continues for all containing 
							functions until the scope chain terminates with GLOBAL execution context.
							Behind the scenes,an object represents the variables in each execution context.The global context variable object always exists,whereas local context variable exist only
							while the function is being executed.When a function is defined,its scope chain is created,preloaded with global variable object and saved to the internal [[Scope]] property.
							When the function is called,an execution context is created and its scope chain is built up by copying the objects in the functions [[Scope]] property.After that an activation object
							(which also acts as an variable object) is created and pushed to the front of the context scope chain.
							
							Whenever a variable is accessed inside a function,the scope chain is searched for a variable with the given name.
							When an inner function is returned, its scope chain has been initialized to contain the activation object from the outer function and the global variable object.
							Another interesting side effect is that the activation object from the outer function cannot be destroyed once the functions finishes executing,because a reference still exists
							in the innner function scope chain.After the outer function completes,the scope chain for its execution context is destroyed,but its activation object still remain in memory until
							the inner function is destroyed.
							THE CLOSURE ALWAYS GETS THE LAST VALUE OF ANY VARIABLE FROM THE CONTAINING FUNCTION, BECAUSE CLOSURES STORES A REFERENCE TO THE ENTIRE VARIABLE OBJECT!!!
							
								function createFunctions(){
									var result = new Array();
									
									for(var i = 0 ; i < 10 ; i++){
										result[i] = function(){ return i;};
									}
									return result;
								}
								
								EVERY FUNCTION RETURNS 10.Since each function has the createFunctions activation object in its scope chain,they are all referring to the same variable "i".
								
								The THIS object 
									When a function is called automatically gets two special variables : THIS & ARGUMENTS
									
									So an inner function can never access these variables directly from an outer function.Workaround :
									
										var name = "The Window";
										
										var object = {
											name : "My Object";
											
											getNameFunc : function(){
												var that = this;
												return function(){
													return that.name;
												};
											}
										};
										
										alert(object.getNameFunc()()); ----> "My Object"
										
							MIMICKING BLOCK SCOPE
								(function(){
									//block code here
								})();
								
								What looks like a function declaration is enclosed in parentheses to indicate that it is actually a function expression!!!!This function is called via the second set of
								parentheses at the end.
								This is equal to this -> 
									var someFunction = function(){
										//block code here
									};
									someFunction();
									
									function(){
										//block code here
									}(); ----> ERROR -> Javascript sees the function keyword as the beginning of a function declaration and function declarations cannot be followed by parentheses.
									Function expressions,however,can be followed by parentheses.To turn the function declaration into a function expressions, we need only surround it with parentheses :
									
									(function(){
										//block code here
									})();
									
									function outputNumbers(count){
										(function(){
											for(var i=0;i < count;i++){
												alert(i);
											}
										})();
										
										alert(i);  ---> ERROR
									}
									
									Private Variables
										
										function MyObject(){
											//private variables and functions
											var privateVariable = 10;
											
											function privateFunction(){
												return false;
											}
											
											this.publicMethod = function(){
												privateVariable++;
												return privateFunction();
											};
										}
										
									THE MODULE PATTERN
										var singleton = function(){
											var privateVariable = 10;
											
											function privateFunction(){
												return false;
											}
											
											return {
												publicProperty : true,
												publicMethod : function(){
													privateVariable++;
													return privateFunction();
												}
											}
										}();
										
					BOM
						Each frame has its own WINDOW object.
						The top object always point to the very top(outermost) frame,which is the browser window itself.
						Any code written within a frame that references the WINDOW object is pointing to that frame's unique instance rather than the topmost one.
						Whenever frames are used,multiple Global objects exist in the browser.Since each window object contains the native type constructor,each frame has its own version of the constructor,
						which are not equal.For example,top.Object is not equal to top.frames[0].Object, which affects the use of instanceof when objects are passed across frames.
						
						Detecting Plug-ins
							Use the plugins array, each item in the array contains the following properties:
								name
								description
								filename -> The filename for the plug-in
								lenght -> Number of Mime Types handle by this plugin
								
								Detecting plug-ins in IE is more problematic,because it does not support Netscape style plug-ins.
								We have to use the proprietary ActiveXObject type and attempt to instantiate a particular plug-in.Plug-ins are implemented in IE using COM objects,which are 
								identified by unique strings.So to check for a particular plug-in, we must know its COM identifier.
								
									function hasIEPlugin(name){
										try{
											new ActiveXObject(name);
										}catch(ex){
											return false;
										}
									}
									
						Registering Handlers
							registerContentHandler() registerProtocolHandler() in NAVIGATOR object.
							Alows a website to indicate that it can handle specific types of information(online RSS readers and online e-mail applications)
							To register a website as a handler of RSS feeds :
								navigator.registerContentHandler("application/rss+xml","http://www.somereader.com?feed=%s","Some reader");
								
								The %s represents the URL of the RSS feed,which the browser inserts automatically.
								
						DOM
							A Document node represents every document as the root.The only child of the document node is the <html> which is called the document element.
							The document element is the outermost element in the document within which all the other elements exist.There can be only one document element per document.
							DOM level 1 describes an interface called Node that is to be implemented by all node types in the DOM.The Node interface is implemented in Javascript as the Node type.
							All node types inherit from Node in Javascript.
							Each node has a childNodes property containing a NodeList.A NodeList is an array-like object used to store an ordered list of nodes that are accessible by position.
							NodeList objects are unique in that they are actually queries being run against the DOM structure,so changes will be reflected in NodeList objects automatically.
							It is often said that a NodeList is a living object rather than a snapshot of what happened at the time it was first accessed.
							
							Javascript represents document nodes via the Document type.In browsers,the document object is an instance of HTMLDocument(which inherits from Document) and represent 
							the entire HTML page.The document object is a property of window.
							One property of document is the domain property.There are some restrictions as to what the value of domain can be set to because of security issues.
							If the URL contains a subdomain,such as p2p.wrox.com,the domain may be set only to "wrox.com".The property can never be set to a domain that the URL does not contain.
							THE ABILITY TO SET DOCUMENT.DOMAIN IS USEFUL WHEN THERE IS A  FRAME OR IFRAME ON THE PAGE FROM A DIFFERENT SUBDOMAIN.PAGES FROM DIFFERENT SUBDOMAINS CAN NOT COMMUNICATE WITH
							ONE ANOTHER VIA JAVASCRIPT BECAUSE OF CROSS-DOMAIN SECURITY RESTRICTIONS.BY SETTING DOCUMENT.DOMAIN IN EACH PAGE TO THE SAME VALUE,THE PAGES CAN ACCESS JAVASCRIPT OBJECTS FROM EACH
							OTHER.
							
							SPECIAL COLLECTIONS
								document.anchors -> All <a> elements with a name attribute
								document.applets
								document.forms
								document.images
								document.links -> All <a> elements with am href attribute
								
						DOM Extensions
								Selectors API
									One of the most capabilities of Javascript libraries is the ability to retrieve a number of DOM elements matching a pattern specified using CSS selectors.
									Indeed,the library jQuery is built completely around the CSS selector queries of a DOM document in order to retrieve references to elements instead of using
									getElementById() and getElementsByTagName().
									
										document.querySelector("#myDiv") -> id 
										document.querySelector("body") -> element
										document.querySelector(".selected") -> class
										document-querySelector("img.button") -> first image with class of "button"
										
										document.querySelectorAll() -> instead of one it return all matching nodes , so it return a static NodeList,the underlying implementation acts as a snapshot of elements
										rather than a dynamic query!!!
										
										matchesSelector()
										
								Html5
									One of the major changes in web development since the time HTML4 was adopted is the increased usage of the "class" attribute to indicate both stylistic and semantic 
									information about elements.This caused a lot of Javascript interaction with CSS classes,including the dynamic changing of classes and querying the document to find elements
									with a given class or set of classes.
									
										getElementByClassName()
										classList property , className contains a single String with all class names separated by white spaces.
										readyState property : Two possible values ("loading","complete")
										Custom Data attributes
											HTML5 allows elements to be specified with nostandard attributes prefixed with "data-" in order to provide information that is not necessary to the 
											rendering or semantic value of the element.
												
													<div id="myDiv" data-appId="12345" data-myname="Nicholas"></div>
													
											Those custom attributes can be accessed via the dataset property of the element.

												var div = document.getElementById("myDiv");
												
												var appId = div.dataset.appId;
												var myName = div.dataset.myname;
												
												Markup Insertion
													innerHTML property
													outerHTML property
													insertAdjacentHTML()
													
														Memory and Performance issues 
															Problem occurs when event handlers or other Javascripts objects are assigned to subtree elements that are removed.
															. If an element has an event handler (or a JavaScript object as a property), and one of these properties is used in such a way that the element 
															is removed from the document tree, the binding between the element and the event handler remains in memory.
															When using innerHTML, outerHTML, and insertAdjacentHTML(), it’s best to manually remove all event handlers and JavaScript object properties 
															on elements that are going to be removed.
															Using these properties does have an upside, especially when using innerHTML. Generally speaking,inserting a large amount of new HTML is more efficient through 
															innerHTML than through multiple DOM operations to create nodes and assign relationships between them. This is because an HTML
															parser is created whenever a value is set to innerHTML (or outerHTML). This parser runs in browser
															level code (often written in C++), which is must faster than JavaScript. That being said, the creation and destruction of the HTML parser does have 
															some overhead, so it’s best to limit the number of times you set innerHTML or outerHTML. For example, the following creates a number of list items
															using innerHTML:
															
																		for (var i=0, len=values.length; i < len; i++){
																				ul.innerHTML += ”<li>” + values[i] + ”</li>”; //avoid!!
																		}
							DOM Level 2 and 3
									XMLNamespace
										XML namespaces allow elements from different XML based languages to be mixed together in a single,well-formed document without fear of element name clashes.
										Technically,XML namespaces are not supported by HTML but supported in XHTML.
											<html xmlns="http://www.w3.org/1999/xhtml">
												<head>
													<title>Example XHTML</title>
												</head>
												<body>
													Hello World!
												</body>
											</html>
										
									For this example,all elements are considered to be part of the XHTML namespace by default.
									We can explicitly create a prefix for an XML namespace using xmlns,followed by a colon :
									
									<xhtml:html xmlns:xhtml="http://www.w3.org/19999/xhtml"> ...
									
									Attributes may also be namespaced to avoid confusion between languages 
									
									<xhtml:body xhtml:class="home">...
									
									Changes to Node 
										Node type evolves in DOM 2 to include the following namespace-specific properties :
										
											localName
											namespaceURI
											prefix
										DOM Level 3
											isDefaultNamespace
											lookupNamespaceURI
											lookupPrefix
									Changes to Document
										createElementNS
										createAttributeNS
										getElementsByTagNameNS
									Changes to Element
										getAttributeNS
										getAttributeNodeNS
										getElementsByTagNameNS
										hasAttributeNS
										removeAttributeNS
										setAttributeNS
										setAttributeNodeNS
										
									Computed Styles
										The style object offers information about the style attribute on any element that supports it but contains no information about the styles that have cascaded from
										style sheets and affect the element.DOM Level 2 Style augments document.defaultView to provide a method called getComputedStyle().
											Accept two arguments :
													element 
													pseudo-element string such (":after")
													
													<style type="text/css">
														#myDiv{
															background-color : blue;
															width : 100px;
															height : 200px;
														}
													</style>
											...
											<body>
												<div id="myDiv" style="background-color:red;border: 1px solid black"
									
									Traversals
									Ranges
									
								EVENTS
									Use the Observer pattern in traditional software engineering,allows a louse coupling between the behaviour of a page(defined in Javascript) and the appearance
									of the page(defined in HTML and CSS).
									
									Event Flow
										Bubbling
											More Specific to the least specific
										Capturing
											Least specific to the more specific,designed to capture the event before it reaches the target!!!
											
										DOM Event Flow specified by DOM Level 2
											Three Phases
												1 Capturing 
												2 Target receives the event
												3 Bubbling
												
										Event Handlers
											HTML Event Handlers
												<input type="button" value="Click Me" onclick="alert('Clicked')"/>
												<input type="button" value="Click Me" onclick="showMessage()"/>
												
												A function is created that wraps the attribute value.That function has a special local variable called event,which is the event object
												
												<input type="button" value="Click Me" onclick="alert(event.type)"/>
												
												The THIS value inside of the function is equivalent to the event's target element 
												
												<input type="button" value="Click Me" onclick="alert(this.value)"/>
												
												Another interesting aspect of this dynamically created function is how it augments the scope chain.Within the function,members of both document and the
												element itself can be accessed as if they were local variables.The function accomplishes this via scope augmentation using WITH:
												
												function(){
													with(document){
														with(this){
															attribute
														}
													}
												}
												
												<input type="button" value="Click Me" onclick="alert(value)"/>
												
												If the element is a form input element,then the scope chain also contains an entry for the parent form element :
												
												function(){
													with(document){
														with(this.form){
															with(this){
																
															}
														}
													}
												}
												
												<input type="button" value="Click Me" onclick="alert(username.value)"/>
												
											DOM Level 0 Event Handlers

												Assigning event handlers using the DOM Level 0 method,the event is considered to be a method of the element.The event is run within the scope of the element,
												meaning that this is equivalent to the element
												
													var btn = document.getElementById("myBtn");
													btn.onclick = function(){alert(this.id);};
													
													EVENT HANDLERS ADDED IN THIS WAY ARE INTENDED FOR THE BUBBLING PHASE OF THE EVENT FLOW!!!
													
											DOM Level 2 Event Handlers
											
													var btn = document.getElementById("myBtn");
													btn.addEventListener("click",function(){alert(this.id);},false); Third argument indicated if is the bubbling phase or the capturing phase
													
													Multiple event can be added :
													
														var btn = document.getElementById("myBtn");
														btn.addEventListener("click", function(){alert(this.id);}, false);
														btn.addEventListener("click", function(){alert("Hello world!");}, false);
														
													Event handlers added via addEventListener() can be removed only by using removeEventListener() and passing in the same arguments as were used when the handler
													was added.	
											
											Internet Explorer Event Handlers

													Internet Explorer implements methods similar to the DOM called attachEvent() and detachEvent().
													These methods accept the same two arguments: the event handler name and the event handler function. Since Internet Explorer 8 and earlier support only 
													event bubbling, event handlers added using attachEvent() are attached on the bubbling phase.
													A major difference between using attachEvent() and using the DOM Level 0 approach in Internet Explorer is the scope of the event handler. 
													When using DOM Level 0, the event handler runs with a this value equal to the element on which it is attached; when using attachEvent(), the event
													handler runs in the global context, so this is equivalent to window.
													Unlike the DOM method, though, the event handlers fire in reverse of the order they were added.
													
											The event object 

												In DOM-compliant browsers, the event object is passed in as the sole argument to an event handler. Regardless of the method used to assign the event handler, 
												DOM Level 0 or DOM Level 2,the event object is passed in. Here is an example:
													
													var btn = document.getElementById("myBtn");
													btn.onclick = function(event){alert(event.type); //"click"};
													btn.addEventListener("click", function(event){alert(event.type); //"click"}, false);
													
												When an event handler is assigned using HTML attributes, the event object is available as a variable called event. Here’s an example:
												
												<input type="button" value="Click Me" onclick="alert(event.type)">
												Providing the event object in this way allows HTML attribute event handlers to perform the same as JavaScript functions.
												
												document.body.onclick = function(event){
													alert(event.currentTarget == document.body);
													alert(this == document.body);
													alert(event.target === document.getElementById("myBtn"));
												}
												
												When the button is clicked,both THIS and currenTarget are equal to document.body because that is where the event handler was registered.The target property 
												is equal to the button element itself,because that is the true target of the click event.
												
												ViewPorts
												
													Device Pixels
														The real pixels.
															Element with 128px:width
															Monitor 1024px wide.
															If we maximize our browser screen,the element will fit on our monitor eigth times.
													Css Pixels
															If the user zooms , the above calculation will change.If the user zooms to 200%, our element 
															will fit only four times on his 1024px wide monitor.
															ZOOMING as implemented in modern browsers consists of nothing more than STRETCHING UP PIXELS!!
															That is, the width of the element is not changed from 128 to 246 pixels,instead the actual pixels are double
															in size.Formally,the element still has a width of 128 CSS pixels,even though it happens to take the space of 256 device pixels.
															Zooming to 200% makes one CSS pixel grow to four times the size of one device pixels(Two times the width, two times the height)!!!
															
														Screen size
															Total width and height of the user's screen,in device pixels because they never change.
														Window size
															Inner dimensions of the browser window(including scroll bars).CSS pixels.
															
													Client Coordinates
														Location of the mouse cursor within the viewport at the time of the event.
													Page Coordinates
														Location of the mouse cursor on the page,so the coordinates are from left and top of the page itself rather than the viewport.
													Screen Coordinates
														Location of the mouse in relation to the entire screen!!!
														
												HTML5 Events
													Pageshow and pagehide events
														Backward-forward cache(bfcache) designed to speed up page transitions when using the browser Back and Forward buttons.The cache stores not only
														page data but also the DOM and Javascript state,effectively keeping the entire page in memory.
													hashchange event
														Notify developers when the URL hash changed.
												Devices Events
													orientationchange event
														 Use the window.orientation
														 The developers could determine when the user switched the device from landscape to portrait mode.
													MozOrientation
														The firefox introduced a this new event	to detect device orientation.
														This event fires periodically as the device accelerometer detects changes in how the device is oriented.
														THIS IS DIFFERENT FROM ORIENTATIONCHANGE IN IOS,WHICH PROVIDES ONLY ONE DIMENSION OF MOVEMENT.
													deviceorientation event
														A device exist in three dimensional space along an x-axis a y-axis and a z-axis.
													devicemotion event 
														Inform us when the device is actually moving,not just when it has changed orientation.
														
													Touch events
													Gesture events
														A gesture occurs when two fingers are touching the screen and typically causes a change in the scale of the displayed item or the rotation.
														
												Memory and performance
													Each function is an object and takes up memory,the more objects in memory,the slower the performance.
														Event delegation
															Takes advantage of event bubbling to assign a single event handler to manage all events of a particular type.
															The click event, for example, bubbles all the way up to the document level.
															
												SIMULATING EVENTS
														Create the event object
														Fire the event through dispachEvent() method.
														
												HTML5 Scripting
													Cross Document Messaging(XDM)
													
														Is the ability to pass information between pages from different origins.For example, a page on www.wrox.com wants to communicate with a page 
														from p2p.wrox.com that is contained in an iframe. Prior to XDM, achieving this communication in a secure manner took a lot of work. XDM formalizes this
														functionality in a way that is both secure and easy to use.
														
														postMessage() -> Pass data into another location
															Accepts two arguments : The data
																					Intended recipient origin VERY IMPORTANT FOR SECURITY REASONS AND RESTRICTS WHERE THE BROWSER WILL 
																					DELIVER THE MESSAGE
																					THIS RESTRICTION PROTECTS OUR INFORMATION SHOULD THE LOCATION OF THE WINDOW CHANGE WITHOUT OUR KNOWLEDGE!!!
														a message event is fired on a window when an XDM message is received.
													
													http://blog.teamtreehouse.com/cross-domain-messaging-with-postmessage
												
													XDM is extremely useful when trying to sandbox content using an iframe to a different domain.
													The containing page is able to keep itself secure against malicious content by only communicating into an embedded iframe 
													via XDM.In an iframe , the iframe code do not have access to the parent code!!!
														
													Log errors on servers
														
														function logError(sev, msg){
															var img = new Image();
															img.src = "log.php?sev=" + encodeURIComponent(sev) + "&msg=" +
															encodeURIComponent(msg);
														}
														
														The Image object is available in all browsers,even those that do not support the XMLHttpRequest object.
														Cross Domain restrictions do not apply.Often there is one server responsible for handling error logging from multiple servers,
														and XMLHtmlRequest would not work in that situation.
														There is less chance that an error will occur in the process of logging the error.Most Ajax communications is handled through 
														functionality wrappers provided by Javascript libraries.If that library code fails, the message will never get logged.
													
										AJAX and Comet
											Prior to the introduction of XHR(XMLHttpRequest),Ajax-style communication had to be accomplished through a number of hacks, mostly using 
											hidden frames or iframes.
											
											var xhr = createXHR();
											xhr.onreadystatechange = function(){
													if (xhr.readyState == 4){
														if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
															alert(xhr.responseText);
														} else {
															alert("Request was unsuccessful: " + xhr.status);
														}
													}
											};
											xhr.open("get", "example.txt", true);
											xhr.send(null);
											
											One of the major limitations of Ajax communications via XHR is the cross-origin security policy.
											By default,XHR objects can access resources only on the domain from which the containing web page originates!!!!
											Cross Origin Resource Sharing (CORS) is a W3C Working Draft that defines how the browser and server must communicate when accessing sources across origins.
											The basic idea behind CORS is to use custom HTTP headers to allow both the browser and the server to know enough about each other to determine 
											if the request or response should succeed or fail.
											For a simple request, one that uses either GET or POST with no custom headers and whose body is text/plain, the request is sent with an extra header called Origin. 
											The Origin header contains the origin (protocol, domain name, and port) of the requesting page so that the server can easily determine
											whether or not it should serve a response. An example Origin header might look like this:
												Origin: http://www.nczonline.net
											If the server decides that the request should be allowed, it sends an Access-Control-Allow-Origin header echoing back the same origin that was sent 
											or "*" if it’s a public resource. For example:
												Access-Control-Allow-Origin: http://www.nczonline.net
											If this header is missing, or the origins don’t match, then the browser disallows the request. If all is well, then the browser processes the request. 
											Note that neither the requests nor the responses include cookie information.
											
											https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
											Content Type MIMES TYPES
												https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
											
										Preflighted Requests
												CORS allows the use of custom headers, methods other than GET or POST, and different body content types through a transparent mechanism of 
												server verification called preflighted requests.
												When you try to make a request with one of the advanced options, a "preflight" request is made to the server. 
												This request uses the OPTIONS method and sends the following headers:
															Origin — Same as in simple requests.
															Access-Control-Request-Method — The method that the request wants to use.
															Access-Control-Request-Headers — (Optional) A comma-separated list of the custom headers being used.
															
												Here’s an example assuming a POST request with a custom header called NCZ:
												Origin: http://www.nczonline.net
												Access-Control-Request-Method: POST
												Access-Control-Request-Headers: NCZ
												
												During this request, the server can determine whether or not it will allow requests of this type. The server communicates this to the browser by sending 
												the following headers in the response:
													Access-Control-Allow-Origin — Same as in simple requests.
													Access-Control-Allow-Methods — A comma-separated list of allowed methods.
													Access-Control-Allow-Headers — A comma-separated list of headers that the server will allow.
													Access-Control-Max-Age — The amount of time in seconds that this preflight request should be cached for.
															For example:
															Access-Control-Allow-Origin: http://www.nczonline.net
															Access-Control-Allow-Methods: POST, GET
															Access-Control-Allow-Headers: NCZ
															Access-Control-Max-Age: 1728000
															Once a preflight request has been made, the result is cached for the period of time specified in the
															response; you’ll only incur the cost of an extra HTTP request the fi rst time a request of this type is made.
												Credentialed Requests
													By default, cross-origin requests do not provide credentials (cookies, HTTP authentication, and client-side SSL certificates). 
													You can specify that a request should send credentials by setting the withCredentials property to true. If the server allows credentialed requests, 
													then it responds with the following HTTP header:
														Access-Control-Allow-Credentials: true
													If a credentialed request is sent and this header is not sent as part of the response, then the browser doesn’t pass the response to JavaScript 
													(responseText is an empty string, status is 0, and onerror() is invoked). 
													Note that the server can also send this HTTP header as part of the preflight response to indicate that the origin is allowed to send credentialed requests.	

											ALTERNATE CROSS-DOMAIN TECHNIQUES
												Image Pings
													One of the first techniques for cross-domain communication was through the use of the <img> tag. Images can be loaded cross-domain by any page 
													without worrying about restrictions.This is the main way that online advertisements track views.
													var img = new Image();
													img.onload = img.onerror = function(){
														alert("Done!");
													};
													img.src = "http://www.example.com/test?name=Nicholas";
												
													The two main downsides to image pings are that you can only send GET requests and you cannot access the response text from the server. 
													This is why image pings are best used for one-way communication between the browser and the server.
												JSONP
													https://www.w3schools.com/js/js_json_jsonp.asp
													callback({"name": "Nicholas" });
													The JSONP format is made up of two parts: the callback and the data. The callback is the function that should be called on the page when the response 
													has been received. Typically the name of the callback is specified as part of the request.
														http://freegeoip.net/json/?callback=handleResponse
														
													JSONP is used through dynamic <script> elements, assigning the src to a cross-domain URL. The <script> element, similar to <img>, is capable of loading resources
													from other domains without restriction. Because JSONP is valid JavaScript, the JSONP response gets pulled into the page and executed immediately upon completion. 
													
												Comet
													Describe a more advanced Ajax technique sometimes referred to as server push.Whereas Ajax is described as the page requesting data from the server,
													Comet is described as the server pushing data to the page.
														Two popular approaches to Comet :
														
															Long Polling:
																Browser sends a request to the server in regular intervals to see if there is any data.(Short Polling)
																A page initiates a request to the server and the server holds the connection open until it has data to send.
																Once the data is sent,the connection is closed by the browser and a new connection is immediately opened up to the server.(Long Polling)
																
																The advantage of polling techniques is that all browsers support this through the XHR object and using setTimeout(). 
																You just need to manage when the requests are sent.
																
															HTTP Streaming
																It uses a single HTTP connection for the entire lifetime of the page.The browser sends a request to the server and the server holds 
																that connection open, periodically sending data through the connection to the server.
																All server-side languages support the notion of printing to the output buffer and then flushing
																(sending the contents of the output buffer to the client). This is the core of HTTP streaming.
																The XHR object can be used to achieve HTTP streaming in Firefox, Safari, Opera, and Chrome
																by listening for the readystatechange event and focusing on readyState 3. A readyState of 3
																will fire periodically in all of these browsers as data is being received from the server. At that point,
																the responseText property contains all of the data received, which means you need to slice off the newest piece by keeping track of what was sent previously.
																
															Server Side Events API	
																
															WebSockets
															
																The goal of Web Sockets is to provide full duplex bi directional communication with the server over a single , long lasting connection.
																When a Web Socket is created in JS , an HTTP request is sent to the server to initiate a connection.When a the server responds,the connection
																uses HTTP upgrade to switch from HTTP to the Web Socket protocol.This means that Web Sockets cannot be implemented with a standard HTTP server and must
																use a specialized server supporting the protocol to work properly.
																Since Web Sockets uses a custom protocol,the URL schema is slightly different.Instead of using the http:// or https;// schemas,there are ws:// for 
																an unsecured connection and wss:// for a secured connection.
																The advantage of using a custom protocol over HTTP is that very small amounts of data,unencumbered by the byte overhead of HTTP,can be sent between
																the client and the server.Using smaller data packets makes Web Sockets ideal for mobile applications where bandwidth and latency are a problem.
																The same origin policy does not apply to Web Sockets!!!
																Once opened, we can both send data over and receive data from the connection.
																Web Sockets can only send plain text over the connection, so we will need to serialize more complex data structures before sending them over the connection.
																
																var socket = new WebSocket("ws://...");
																socket.send("Hello World");
																
											Scope Safe Constructors
											Lazy Loading Functions
											Function Binding
											Function Currying
											Tamper prof objects
													Nonextensible objects
														Object.preventExtensions()
														Object.isExtensible()
													Sealed Object
														Object.seal()
														Object.isSealed()
													Frozen Object
														[[Writable]] attribute set to false
														Object.freeze()
														Object.isFrozen()
														
											JAVASCRIPT RUNS IN A SINGLE THREAD ENVIRONEMNT.THE TIMING OF TIMERS EXECUTION IS NOT GUARANTEED~,BECAUSE OTHER CODE MAY CONTROL THE JAVASCRIPT PROCESS AT DIFFERENT 
										    TIMES DURING THE PAGE LIFE CYCLE.CODE RUNNIG WHEN THE PAGE IS DOWNLOADED,EVENT HANDLERS AND AJAX CALLBACKS ALL MUST USE THE SAME THREAD FOR EXECUTION!!!
											ALONG SIDE THE MAIN JAVASCRIPT EXECUTION PROCESS,THERE IS A QUEUE OF CODE THAT SHOULD BE EXECUTED THE NEXT TIME THE PROCESS IS IDLE!!!AS THE PAGE GOES THROUGH ITS 
											LIFE CYCLE,CODE IS ADDED TO THE QUEUE IN THE ORDER IN WHICH IT SHOULD BE EXECUTED.WHEN AN AJAX RESPONSE IS RECEIVED,THE CALLBACK FUNCTION CODE IS ADDED TO THE QUEUE.
											NO CODE IS EXECUTED IMMEDIATELY IN JAVASCRIPT,IT IS EXECUTED AS SOON AS THE PROCESS IS IDLE.
											TIMERS WORK WITH THIS QUEUE BY INSERTING CODE WHEN A PARTICULAR AMOUNT OF TIME HAS PASSED.SETTING A TIMER FOR EXECUTION IN 150 MILLISECONDS DOES NOT MEAN THAT THE 
											CODE WILL BE EXECUTED IN 150 MILLISECONDS,IT MEANS THAT THE CODE WILL BE ADDED TO THE QUEUE IN 150 MILLISECONDS.
											
											REPEATING TIMER
										
											SSO
												Non SSO scenario
													1 User browses to domain1.com
													2 Ask for login info,authenticates user
													3 Stores Cookie
													4 Browses to domain2.com
													5 Ask for login info,authenticates user
													6 Stores Cookie
													
													The obvious solution to this problem is to share session information across different domains.
													For security reasons,browsers enforce a policy known as the same origin policy.This policy dictates that cookies can only be accessed by its creator,
													the domain that originally requested the data to be stored.
													
													Different SSO protocols share session information in different ways,but the  essential concept is the same : there is a central domain!!!,through which
													authentication is performed,and then the session is shared with other domains in some way.
													For instance,the central domain may generate a signed JSON Web Token.
													Whenever the user goes to a domain that requires authentication, it is redirect to the authentication domain.As the user is already logged-in at that domain,
													it can be immediately redirected to the original domain with the necessary authentication token.

													1 User browses to domain1.com
													2 Redirects to Auth0
													3 Either user logs in or cookie is available
													4 Stores cookie if in the previous step user had logged in
													5 Send token and redirects
													6 Uses token to authenticate
													7 Stores domain1.com cookie
													
											Docker
												Basic idea of a Java Application Server is its a JVM process we deploy & undeploy our java code to as a deployment unit(jar/war/ear/bundle).
												So a JVM mutates the code it runs over time.Often Java Application Servers have directories we drop files into or REST/JMX APIs to modify
												the runnig deployments units(Java codes).
												
												It is been common practice for many years in the Java ecosystem that in production we never really un-deploy Java code in a runnig JVM,since is far 
												to easy to leak resources(threads,memory,database connections,sockets...).So to upgrade the version of an application in production its better to 
												spin up a new Application Server process with the new code inside in parallel;move traffic to the new Application server instance and drain traffic 
												from the old instance.
												
												Docker containers are an ideal way to package up applications for easy deployment on linux machine,they use immutable container images for all
												operating system and code they need to use,they are isolated from each other and can have cgroups limits on IO/memory/CPU usage.
												Docker containers can spin up as many instances of a container we like on any machine and they work in a repeatable way since they are based 
												on the same reusable immutable image.A container instance can have its own persistent state mounted on a volume but the code(and possibly configuration)
												comes from an immutable image.
												SO THE DOCKER WAY TO WORK WITH JAVA APPLICATION SERVERS IS TO MAKE AN IMMUTABLE IMAGE FOR THE APPLICATION SERVER AND THE DEPLOYMENTS UNITS WE WHISH 
												TO RUN IN PRODUCTION.
												To upgrade the Java code of a service,rather than dropping a WAR in the webapps/deploy folder or calling a REST/JMX API in the application server or
												whatever,we just make a new image with the new deployment unit inside and run it.
												
												Configuration
													One thing the Java ecosystem has done well since adopting Application Servers is creating immutable binary deployments units(jar/war/ear/bundle),
													releasing them once and moving them between environments.To do that we often delegate to the application server to find resources(e.g lookup in JNDI for JEE)
													for things like discovering where the database is or message broker.Then there would be separate clusters of independently configured application servers 
													which we deployed our artifacts to.
													So it is surprisingly easy to mess up and for different environments to be running different operating systems,Java versions,application server versions or
													mismatched configurations;things may work in our staging environment but if we are not very careful they may fail in production.
													INSTEAD THE DOCKER APPROACH IS TO EXTEND THE IDEA OF IMMUTABLE IMAGES TO THE OPERATING SYSTEM AND APPLICATION SERVER TOO,SO THE EXACT SAME BINARY IMAGE OF THE 
													OPERATING SYSTEM,JAVA RUNTIME,APPLICATION SERVER AND DEPLOYMENT UNITS WOULD BE RUN IN EACH ENVIRONMENT.SO THERE IS NO CHANCE OF HITTING AN ISSUE WITH A 
													MIS-CONFIGURED APPLICATION SERVER IN A CERTAIN ENVIRONEMNT SINCE IT IS THE SAME BINARY IMAGE THAT RUNS EVERYWHERE!!!!
													TO BE ABLE TO DO THIS WELL;HAVING SERVICE DISCOVERY IN EACH ENVIRONMENT IS EXTREMELY USEFUL AS IT MAKES IT REALLY EASY TO RUN THE SAME IMAGE IN EVERY 
													ENVIRONMENT WITHOUT MESSING WITH CONFIGURATION.
													e.g : Things like kubernetes service discovery can make it trivial to run the same binary image in all environments and for services discovery of things
													like databases and message brokers to just work!!!
													
											Rest
												@Path Relative URI Path
													   @Path("/helloworld") -> Static URI  VARIABLES CAN BE EMBEDDED IN THE URIs.URI Path template are URIs variables embedded within the URI syntax.
														public class HelloWorldResource{
															....
															
											MICROSERVICES(CLOUD COMPUTING)
												Before Microservices evolved,most web-based applications were built using monolithic architectural style(Single deployable software artifact).
												A microservice is a small, loosely coupled, distributed service!!!!
												Microservices are the gateway drug for building cloud applications. You start building microservices because they give you a high degree of flexibility and autonomy 
												with your development teams, but you and your team quickly find that the small, independent nature of microservices makes them easily deployable to the cloud. 
												Once the services are in the cloud, their small size makes it easy to start up large numbers of instances of the same service, 
												and suddenly your applications become more scalable and, with forethought, more resilient.
													
												What is exactly the CLOUD ?
													THREE BASIC MODELS EXIST IN CLOUD-BASED COMPUTING :
													
														IaaS(Infrastructure as a Service)
														PaaS(Plataform as a Service)
														SaaS(Software as a Service)
														
														The different cloud computing models come down to who's responsible for what:The cloud vendor or us.
														New cloud platform types are emerging:
															FaaS 
															CaaS(Container as a Services)
																Build and deploy microservices as portable virtual containers(such as Docker) to a cloud provider.
																
																UNLIKE AS IAAS MODEL,WHERE THE DEVELOPER HAVE TO MANAGE THE VIRTUAL MACHINE THE SERVICE IS DEPLOYED TO,WITH CAAS WE ARE 
																DEPLOYING OUR SERVICE IN A LIGHTWEIGHT VIRTUAL CONTAINER.
																THE CLOUD PROVIDER RUNS THE VIRTUAL SERVER THE CONTAINER IS RUNNIG ON AS WELL AS THE PROVIDER'S COMPREHENSIVE TOOLS FOR BUILDING,DEPLOYING,
																MONITORING AND SCALING CONTAINERS.AMAZON ELASTIC CONTAINER SERVICE(ECS) IS AN EXAMPLE OF A CAAS-BASED PLATAFORM.
																
														The advantage of cloud-based microservices centers around the concept of elasticity.
														Cloud service providers allow you to quickly spin up new virtual machines and containers in a matter of minutes!!!!	
														For instance, Amazon, Cloud Foundry, and Heroku give you the ability to deploy your services without having to know about the underlying application container. 
														They provide a web interface and APIs to allow you to deploy your application as a WAR or JAR file. Setting up and tuning the application server and 
														the corresponding Java container are abstracted away from you. While this is convenient, each cloud provider’s platform 
														has different idiosyncrasies related to its individual PaaS solution.
														An IaaS approach, while more work, is portable across multiple cloud providers and allows us to reach a wider audience with our material. 
														Personally, I’ve found that PaaS-based cloud solutions can allow you to quickly jump start your development effort, but once your application 
														reaches enough microservices, you start to need the flexibility the IaaS style of cloud development provides.
														Earlier in the chapter, I mentioned new cloud computing platforms such as Function as a Service (FaaS) and Container as a Service (CaaS). 
														If you’re not careful, FaaS-based platforms can lock your code into a cloud vendor platform because your code is deployed to a vendor-specific 
														runtime engine. With a FaaS-based model, you might be writing your service using a general programming language (Java, Python, JavaScript, and so on), 
														but you’re still tying yourself heavily to the underlying vendor APIs and runtime engine that your function will be deployed to.
														
														Microservices patterns :
														
															Core development patterns
																		Service granularity
																		Communication Protocols
																		Interface Design
																		Configuration management service
																		Event processing between services
															Routing Patterns 
																		The microservice routing patterns deal with how a client application that wants to consume a microservice discovers the location of the service 
																		and is routed over to it. In a cloud-based application, you might have hundreds of microservice instances running. You’ll need to 
																		abstract away the physical IP address of these services and have a single point of entry for service calls so that you can consistently 
																		enforce security and content policies for all service calls.
																			Service discovery
																			Service routing
																				How do you provide a single entry point for all of your services so that security policies and routing rules are applied uniformly 
																				to multiple services and service instances in your microservice applications? 
																				
															Client Resilience Patterns
																Client Side Load Balancing
																Circuit Breakers Pattern 
																	How do we prevent a client from continuing to call a service that is falling or suffering performance problems ?
																Fallback pattern
																	When a service call fails, how do you provide a “plug-in” mechanism that will allow the service client to try to carry out its work through alternative means other than the 
																	microservice being called?
																Bulkhead pattern
																	Microservice applications use multiple distributed resources to carry out their work. How do you compartmentalize these calls so that the misbehavior of one service 
																	call doesn’t negatively impact the rest of the application?
																
															Security Patterns
																Authentication
																Authorization
																Credential Management and propagation
																	Token Based security standards (OAuth2 / JWT)
																
															Logging and tracing patterns
																Log correlation
																Log aggregation
																Microservice tracing
															
															Build/Deployment patterns
																We want the deployment of the microservice and the server it is running on to be one atomic artifact that is deployed as a whole
																between environments
																
																Implementing all these patterns from scratch would be a tremendous amount of work.
																Spring has integrated a wide number of battle-tested open source projects into a Spring subproject collectively known 
																as SPRING CLOUD.
																Spring Cloud wraps the work of open source companies such as Pivotal,HashiCorp and Netflix in delivering patterns.
																Spring Cloud simplifies setting up and configuring of these projects into our Spring Application.
																
																
																Spring Boot is the core technology used in our microservice implementation!!!Greatly simplifies microservice development by simplifying 
																the core tasks of building REST-based microservices.Also simplifies mapping HTTP style verbs to URLs and the serialization of the JSON
																protocol to and from Java objects
																
																Spring Cloud Config
																	Handles the management of application configuration data through a centralized service so our application configuration data is cleanly
																	separated from our deployed microservice.This ensures that no matter how many microservices instances we bring up.they will always have the 
																	same configuration.
																	Spring Cloud Config has its own property management repository,but also integrates with open source projects such as :
																		GIT
																		CONSUL
																		EUREKA
																Spring Cloud Service Discovering
																	CONSUL
																	EUREKA
																For Client Resiliency patterns 
																	Netflix Hystrix
																	Ribbon
																Spring Cloud/Netflix Zuul
																	Provide service Routing capabilities
																	Zuul is a service gateway that proxies service requests and makes sure that all calls to our microservices go through a single "front door"
																	before the targeted service is invoked.With this centralization of service calls, you can enforce standard service policies such as a 
																	security authorization authentication, content filtering, and routing rules.
																Spring Cloud Stream
																	Allows us to easily integrate lightweight message processing into our microservice.
																	With Spring Cloud Stream, you can quickly integrate your microservices with message brokers such as RabbitMQ and Kafka.
																Spring Cloud Sleuth
																	Spring Cloud Sleuth
																	Alows you to integrate unique tracking identifiers into the HTTP calls and message channels (RabbitMQ, Apache Kafka) being used 
																	within your application.
																	
																	
													SPRING 
														Primary features
															Dependency Injection(DI) and Aspect Oriented Programming(AOP)
															Four Strategies:
																POJO Oriented development
																Loose coupling through DI and interface orientation
																Declarative programming through aspects and common convention
																Eliminating boilerplate code with aspect and templates
																
															There are frameworks that lock us in by forcing us to extend one of their classes or implement one of their interfaces.
															(EJB2,Struts)
															Spring avoids littering our application code with its API.
															
															In a Spring-based application,our application objects live in the Spring container.
															Container creates the objects,wires them together,configures them, and manages their complete lifecycle from cradle to grave
															(or new to finalize() as the case may be).There is no single container.Spring comes with several container implementations that can be 
															categorized into two distinct types : 
																1 Bean factories
																2 Application Contexts
																	Build on the notion of a bean factory by providing application-framework services,such as the ability to resolve textual messages from
																	a properties files and the ability to publish application events to interested event listeners.
																	
																Working with Application Context
																	Several Application Context :
																		AnnotationConfigApplicationContext
																		ClassPathXmlApplicationContext
																		FileSystemXmlApplicationContext
																		
																	Load FileSystemXmlApplicationContext
																		ApplicationContext context = FileSystemXmlApplicationContext("C:/knight.xml");
																		
																The difference between using FileSystemXmlApplicationContext and ClassPathXmlApplicationContext is that FileSystemXmlApplicationContext 
																looks for knight.xml in a specific location within the filesystem, whereas ClassPathXmlApplicationContext
																looks for knight.xml anywhere in the classpath (including JAR files).		
																
																Lifecycle of a bean in the bean container
																
																1:Instantiate
																2:Inject values and beans references  into the bean's properties
																3:If the bean implements BeanNameAware,Spring passes the bean's ID to the setBeanName()
																4:                       BeanFactoryAware,Spring calls the setBeanFactory() method , passing in the bean factory itself.
																5:                       ApplicationContextAware setApplicationContext
																6:                       BeanPostProcessor,Spring calls its postProcessorBeforeInitialization() method
																7:                       InitializingBean , afterPropertiesSet
																	if declared with an init-method,then the specified initialization method is called
																8:                       BeanPostProcessor postProcessorAfterInitialization
																9: READY TO BE USED
															   10:                       DisposableBean calls destroys method()
																If declared with a destroy-method the specified method is called.
																
														Spring Configuration Options
															Explicit configuration in XML
															Explicit configuration in Java
															Implicit bean discovery and automatic wiring
															
															
															
																Automatic
																	@Component
																	public claxx X implements I{...
																	
																	@ComponentScan -> DEFAULT TO SCANNING THE SAME PACKAGE AS THE CONFIGURATION CLASS.
																	public class CDPlayerConfig{...
																	The default package is because that way we can keep all of our configuration code in a package of its own,separate from the rest of our application
																	code
																	To specify a different package or more than one we use
																	@ComponentScan("xxxxxx")
																	@ComponentScan(basePackages="xxxx")
																	@ComponentScan(basePackages={"xxxx","ttttt"})
																	USING TYPE-SAFE 
																	@ComponentScan(basePackagesClasses={xxxx.class,yyyy.class})
																		|--->Whatever packages those classes are in will be used as the base package for component scanning.Passw01#
																	
																	alternative we can turn on component scanning through XML
																	<beans>
																		<context:component-scan base-package="x"/>
																	</beans>	
											
												
																	All beans in a Spring application context are given an ID, by default the iID is the name of the .class
																	To explicit give an ID
																	@Component("xxxx")
																	
																	Alternatively we can use the @Named annotation, this annotation is from the JSR-330!!
																	
																	Automatically wired
																		@Autowired
																		public CDPlayer(CompactDisk cd){ //Constructor
																		
																		@Autowired  (required=false) -> If there are no matching beans it will leave the bean unwired.
																		public void setCompactDisc(CompactDisc cd) //Setter method
																		
																	Alternatively we can use the @Inject annotation, this annotation is from the JSR-330!!	
																
																
																Java Configuration
																
																	@Configuration
																	public class CDPlayerConfig {
																		@Bean
																		public CompactDisc sgtPeppers() {
																			return new SgtPeppers();
																		}
																		
																					//By default, the bean will be given an ID that is the same as the @Bean-annotated
																					//method’s name. In this case, the bean will be named compactDisc.
																					//@Bean(name="lonelyHeartsClubBand") -> Different ID
																	
																	
																		@Bean
																		public CDPlayer cdPlayer() {
																			return new CDPlayer(sgtPeppers());
																		}
																					//It appears that the CompactDisc is provided by calling sgtPeppers,but that is not exactly true!!!
																					//Because sgtPeppers() is annotated with @Bean,Spring will intercept any calls to it and ensure that the bean 
																					//produced by that method is returned rather than allowing it to be invoked again!!!
																	}                |
																					 |
																					 |
																					 |
																					 |
																					 |---> For instance
																							@Bean
																							public CDPlayer cdPlayer() {
																								return new CDPlayer(sgtPeppers());
																							}
																							@Bean
																							public CDPlayer anotherCDPlayer() {
																								return new CDPlayer(sgtPeppers());
																							}
																							If the call to sgtPeppers() was treated like any other call to a Java method, then each
																							CDPlayer would be given its own instance of SgtPeppers!!!!
																							By default, all beans in Spring are
																							singletons, and there’s no reason you need to create a duplicate instance for the second
																							CDPlayer bean. So Spring intercepts the call to sgtPeppers() and makes sure
																							that what is returned is the Spring bean that was created when Spring itself called
																							sgtPeppers() to create the CompactDisc bean. Therefore, both CDPlayer beans will
																							be given the same instance of SgtPeppers.
																							
																							Another way that might be easier to digest:
																							@Bean
																							public CDPlayer cdPlayer(CompactDisc compactDisc) {
																								return new CDPlayer(compactDisc);
																							}
																							
																							Here, the cdPlayer() method asks for a CompactDisc as a parameter. When Spring
																							calls cdPlayer() to create the CDPlayer bean, it autowires a CompactDisc into the
																							configuration method. Then the body of the method can use it however it sees fit.
																							With this technique, the cdPlayer() method can still inject the CompactDisc into the
																							CDPlayer’s constructor without explicitly referring to the CompactDisc’s @Bean
																							method.
																							This approach to referring to other beans is usually the best choice because it
																							doesn’t depend on the CompactDisc bean being declared in the same configuration
																							class. In fact, there’s nothing that says the CompactDisc bean even needs to be
																							declared in JavaConfig; it could have been discovered by component scanning or
																							declared in XML. You could break up your configuration into a healthy mix of configuration
																							classes, XML files, and automatically scanned and wired beans.
																	
																	
																XML Configuration
																	<?xml version="1.0" encoding="UTF-8"?>
																	<beans xmlns="http://www.springframework.org/schema/beans"
																	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
																	xsi:schemaLocation="http://www.springframework.org/schema/beans
																	http://www.springframework.org/schema/beans/spring-beans.xsd
																	http://www.springframework.org/schema/context">
																	<!-- configuration details go here -->
																		<bean id="compactDisc" class="soundsystem.SgtPeppers" />
																		
																		<bean id="cdPlayer" class="soundsystem.CDPlayer">
																			<constructor-arg ref="compactDisc" />
																		</bean>   <-------------------------------------------------------------------------
																------>	<bean id="cdPlayer" class="soundsystem.CDPlayer"c:cd-ref="compactDisc" />		    |
																|                                                        ___________________________________|
																|														 |
																|	</beans>											 |
																|														 |
																|		Initializing a bean with constructor injection   |
																|			1 : <constructor-arg> element ----------------
																------------2 : C-namespace
																
																				c:cd-ref  -> named argument (cd)
																				c:_0-ref  -> index argument (0)
																				c:_-ref   -> Only works with one argument
																					THE REF INDICATES THAT IT WILL BE REFERENCING AN BEAN
																					
																				To inject literal values
																					<bean id="compactDisc" class="soundsystem.BlankDisc">
																						<constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" />
																						<constructor-arg value="The Beatles" />
																					</bean>
																					
																					GET ATTENTION THAT WE HAVE REPLACED THE "REF" WORD BY "VALUE"
																					
																					<bean id="compactDisc" class="soundsystem.BlankDisc" c:_title="Sgt. Pepper's Lonely Hearts Club Band"
																					c:_artist="The Beatles" />

																					<bean id="compactDisc" class="soundsystem.BlankDisc" c:_0="Sgt. Pepper's Lonely Hearts Club Band"
																					c:_1="The Beatles" />
																					
																				Wiring Collections
																					<bean id="compactDisc" class="soundsystem.BlankDisc">
																						<constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" />
																						<constructor-arg value="The Beatles" />
																						<constructor-arg>
																						<list>
																							<value>Sgt. Pepper's Lonely Hearts Club Band</value>
																							<value>With a Little Help from My Friends</value>
																							<value>Lucy in the Sky with Diamonds</value>
																							<value>Getting Better</value>
																							<value>Fixing a Hole</value>
																							<!-- ...other tracks omitted for brevity... -->
																						</list>
																						</constructor-arg>
																					</bean>
																					
																					Bean References
																					
																					<bean id="beatlesDiscography" class="soundsystem.Discography">
																						<constructor-arg value="The Beatles" />
																						<constructor-arg>
																						<list>
																							<ref bean="sgtPeppers" />
																							<ref bean="whiteAlbum" />
																							<ref bean="hardDaysNight" />
																							<ref bean="revolver" />
																							...
																						</list>
																						</constructor-arg>
																					</bean>
																					
																						WE COULD USE <SET> INSTEAD OF <LIST>
																						
																				Setting properties in XML instead of Constructor injection
																				
																					public class CDPlayer implements MediaPlayer {
																						private CompactDisc compactDisc;
																						@Autowired
																						public void setCompactDisc(CompactDisc compactDisc) {
																							this.compactDisc = compactDisc;
																						}
																						public void play() {
																							compactDisc.play();
																						}
																					}

																					<bean id="cdPlayer" class="soundsystem.CDPlayer">
																						<property name="compactDisc" ref="compactDisc" />
																					</bean>
																					
																					Like c-namespace to constructor injection there is the p-namespace to
																					method injection
																					
																					<bean id="cdPlayer" class="soundsystem.CDPlayer" p:compactDisc-ref="compactDisc" />
																					
																						util-namespace offers <util:list> to wiring collections in XML
																						
																		IMPORTING AND MIXING CONFIGURATIONS
																		
																			@Configuration
																			public class CDConfig {
																				@Bean
																				public CompactDisc compactDisc() {
																					return new SgtPeppers();
																				}
																			}
																			
																			@Configuration
																			@Import(CDConfig.class)
																			public class CDPlayerConfig {
																				@Bean
																				public CDPlayer cdPlayer(CompactDisc compactDisc) {
																					return new CDPlayer(compactDisc);
																				}
																			}
																			
																			Create a higher-level SoundSystemConfig that uses @Import to bring both configurations together
																			@Configuration
																			@Import({CDPlayerConfig.class, CDConfig.class})
																			public class SoundSystemConfig {
																			}
																			
																			Import beans configured in XML file 
																			@ImportResource("classpath:cd-config.xml")
																			
																			Split XML files and import
																				<import resource="cd-config.xml" />
																			
																			Import 	JavaConfig Class into XML
																			<bean class="soundsystem.CDConfig" />
																			
										PROFILES

											In JavaConfig
													@Profile("prod") at class level
													@Profile("prod") at method level
											In XML
												Define all files
													<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
														   xmlns:jdbc="http://www.springframework.org/schema/jdbc"
														   xsi:schemaLocation="http://www.springframework.org/schema/jdbc
														   http://www.springframework.org/schema/jdbc/spring-jdbc.xsd
														   http://www.springframework.org/schema/beans
														   http://www.springframework.org/schema/beans/spring-beans.xsd"
														   profile="dev">
													At method level
														<beans profile="dev">
															<jdbc:embedded-database id="dataSource">
															<jdbc:script location="classpath:schema.sql" />
															<jdbc:script location="classpath:test-data.sql" />
															</jdbc:embedded-database>
														</beans>
														
												Activating Profiles
													Two separate properties:
														spring.profiles.active
														spring.profiles.default
														
														If neither are set, then there are no active profiles, and only those beans that aren’t defined as being in a profile are created!!!!!!!
														There are several ways to set these properties:
															 As initialization parameters on DispatcherServlet
															 As context parameters of a web application
															 As JNDI entries
															 As environment variables
															 As JVM system properties
															 Using the @ActiveProfiles annotation on an integration test class
										
										Conditional Beans
											@Conditional(MagicExistsCondition.class)
											
											This class must implement the Condition interface
												public interface Condition {
													boolean matches(ConditionContext ctxt,AnnotatedTypeMetadata metadata);
												}
												
												
																public interface ConditionContext {
																	BeanDefinitionRegistry getRegistry();
																		//Check for bean definitions returned from getRegistry()
																	ConfigurableListableBeanFactory getBeanFactory();
																		//Check for the presence of beans,and even dig into beans properties
																	Environment getEnvironment();
																	ResourceLoader getResourceLoader();
																	ClassLoader getClassLoader();
																}
																//Inspect annotations that may also be placed on the @Bean method
																public interface AnnotatedTypeMetadata {
																	boolean isAnnotated(String annotationType);
																	Map<String, Object> getAnnotationAttributes(String annotationType);
																	Map<String, Object> getAnnotationAttributes(
																	String annotationType, boolean classValuesAsString);
																	MultiValueMap<String, Object> getAllAnnotationAttributes(
																	String annotationType);
																	MultiValueMap<String, Object> getAllAnnotationAttributes(
																	String annotationType, boolean classValuesAsString);
																}
																
									Addressing ambiguity
										Designating a primary bean
											@Primary
											In XML
												<bean id="iceCream" class="com.desserteater.IceCream" primary="true" />
												
												This annotation can be applied to more than one bean so could be ambiguous again.
												
										Qualifying
											@Qualifier("iceCream")
											
											This is a prime example of qualifiers in their simplest form. The parameter given to @Qualifier is the ID of the bean that you want to inject.
											All beans are given a default qualifier that’s the same as their bean ID.
											CREATING CUSTOM QUALIFIERS
											Instead of relying on the bean ID as the qualifier, you can assign your own qualifier to a bean. All you need to do is place the @Qualifier annotation on the bean declaration.
											For example, it can be applied alongside @Component like this:
											@Component
											@Qualifier("cold")
											public class IceCream implements Dessert { ... }
											In this case, a qualifier of cold is assigned to the IceCream bean. Because it’s not coupled to the class name, you can refactor the name of the IceCream class all you want
											without worrying about breaking autowiring. It will work as long as you refer to the cold qualifier at the injection point:
											@Autowired
											@Qualifier("cold")
											public void setDessert(Dessert dessert) {
												this.dessert = dessert;
											}
											
											In last case we can create CUSTOM ANNOTATIONS!!!!
											
									Scoping beans
										By default, all beans created in the Spring application context are created as singletons.
										That is to say, no matter how many times a given bean is injected into other beans, it’s always the same instance that is injected each time.
										Spring defines several scopes under which a bean can be created, including the following:
										  Singleton — One instance of the bean is created for the entire application.
										  Prototype — One instance of the bean is created every time the bean is injected into or retrieved from the Spring application context.
										  Session — In a web application, one instance of the bean is created for each session.
										  Request —In a web application, one instance of the bean is created for each request.
										  
										  @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
										  In XML
											<bean id="notepad" class="com.myapp.Notepad" scope="prototype" />
											
										PROBLEM : Inject a Session or Request scoped bean into a Singleton bean 
										
											@Component
											public class StoreService {
											@Autowired
												public void setShoppingCart(ShoppingCart shoppingCart) {
													this.shoppingCart = shoppingCart;
												}
												...
											}
										
											Because StoreService is a singleton bean, it will be created as the Spring application context is loaded. As it’s created, Spring will attempt to inject ShoppingCart into the
											setShoppingCart() method. But the ShoppingCart bean, being session scoped, doesn’t exist yet. There won’t be an instance of ShoppingCart until a user comes
											along and a session is created.Moreover, there will be many instances of ShoppingCart: one per user. You don’t want Spring to inject just any single instance of ShoppingCart 
											into StoreService. You want StoreService to work with the ShoppingCart instance for whichever session happens to be in play when StoreService needs to work with the shopping cart.
											Instead of injecting the actual ShoppingCart bean into StoreService, Spring should inject a proxy to the ShoppingCart bean.
											This proxy will expose the same methods as ShoppingCart so that for all StoreService knows, it is the shopping cart. But when StoreService calls methods on ShoppingCart, the
											proxy will lazily resolve it and delegate the call to the actual session-scoped Shopping-Cart bean.
											As configured, proxyMode is set to ScopedProxyMode.INTERFACES, indicating that the proxy should implement the ShoppingCart interface and delegate to the implementation bean.
											This is fine (and the most ideal proxy mode) as long as ShoppingCart is an interface and not a class. But if ShoppingCart is a concrete class, there’s no way Spring can
											create an interface-based proxy. Instead, it must use CGLib to generate a class-based proxy. So, if the bean type is a concrete class, you must set proxyMode to 
											ScopedProxy-Mode.TARGET_CLASS to indicate that the proxy should be generated as an extension of the target class.
											
											In XML
												<bean id="cart" class="com.myapp.ShoppingCart" scope="session">
													<aop:scoped-proxy />
												</bean>
												
												It tells Spring to create a scoped proxy for the bean.
												By default, it uses CGLib to create a target class proxy. But you can ask it to generate an interface-based proxy by setting the proxy-target-class attribute to false:
												<bean id="cart" class="com.myapp.ShoppingCart" scope="session">
													<aop:scoped-proxy proxy-target-class="false" />
												</bean>
												
												*Proxy (Java)
												
													Two types :
														Pure Java Proxies
															Based on runtime implementations of interfaces
															public final and not abstract
															extend java.lang.reflect.Proxy
															
															Example:
																Suppose we want a List that can not be added elements to it.
																 1 : Create invocation handler
																	 public class NoOpAddInvocationHandler implements InvocationHandler{
																		private final List proxied;
																		
																		public NoOpAddInvocationHandler(List list){
																		  this.proxied = list;
																		}
																		
																		public Object invoke(Object proxy,Method method,Object[] args){
																			if(method.getName().startWith("add")){
																				return false;
																			}
																			method.invoke(proxied,args);
																			
																		}
																	 }
																	 
																2 Create the proxy
																	List proxy = (List) Proxy.newProxyInstance(NoOpAddInvocationHandler.class.getClassLoader(),new Class[]{List.class},new NoOpAddInvocationHandler(list));
																	   Args 1 Classloader
																		    2 array of interfaces that will be implemented by the proxy
																			3 invocation handler
																			
														CGLib proxies
															Java proxies are runtime implementations of interfaces.
															Objects do not necessarily implement interfaces , and collections of objects do not necessarily share the same interface.
															Confronted with such needs,Java proxies fail to provide an answer.
															Here begins the realm of CGLib.CGLib is a thirdy part framework,based on bytecode manipulation provided by ASM that can help with the previous limitations.
															  1 We are not required to implement interfaces
															  2 We can extend a class
															  
															  For example,since Hibernate entities are POJO,Java proxies cannot be used in lazy-loading,CGLib proxies can!!!
															  https://dzone.com/articles/power-proxies-java
															  
														ClassLoaders
															When a class is loaded,all classes it references are loaded too.This class loading pattern happens recursively,until all classes are loaded.
															Classloaders are organized into a hierarchy.When we create a new class loader we must provide it with a parent class loader.
															If a ClassLoader is asked to load a class,it will ask its parent first.If the parent class loader can not find the class , the child class loader 
															then tries to load it itself.
															
															Steps:
																 Check if the class was already loaded.
																 If not loaded, ask parent class loader to load the class.
																 If parent class loader cannot load class, attempt to load it in this class loader.
																 
																 Reloading a class
																	Even with a custom subclass of ClassLoader we have a challenge. Every loaded class needs to be linked. 
																	This is done using the ClassLoader.resolve() method. This method is final, and thus cannot be overridden in your ClassLoader subclass. 
																	The resolve() method will not allow any given ClassLoader instance to link the same class twice. 
																	Therefore, every time we want to reload a class we must use a new instance of your ClassLoader subclass.
																	Every class loaded in Java application is identified by its fully qualified name and classloader instance that loaded it.
																	A class MyObject loaded by class loader A is not the same class as the MyObject class loaded by class loader B.
																	
																	MyObject object = (MyObject) myClassReloadingFactory.newInstance("com.jenkov.MyObject");
					
																	Notice how the MyObject class is referenced in the code, as the type of the object variable. 
																	This causes the MyObject class to be loaded by the same class loader that loaded the class this code is residing in.
																	If the myClassReloadingFactory object factory reloads the MyObject class using a different class loader than the class the above code resides in, 
																	you cannot cast the instance of the reloaded MyObject class to the MyObject type of the object variable. 
																	Since the two MyObject classes were loaded with different class loaders, the are regarded as different classes, even if they 
																	have the same fully qualified class name. Trying to cast an object of the one class to a reference of the other will result in a ClassCastException.

																	It is possible to work around this limitation but you will have to change your code in either of two ways:

																		Use an interface as the variable type, and just reload the implementing class.
																		Use a superclass as the variable type, and just reload a subclass.
																	Here are two coresponding code examples:

																	MyObjectInterface object = (MyObjectInterface)myClassReloadingFactory.newInstance("com.jenkov.MyObject");
																	MyObjectSuperclass object = (MyObjectSuperclass)myClassReloadingFactory.newInstance("com.jenkov.MyObject");
																	
																	Either of these two methods will work if the type of the variable, the interface or superclass, is not reloaded when the implementing class or 
																	subclass is reloaded.

																	To make this work you will of course need to implement your class loader to let the interface or superclass be loaded by its parent. 
															  
												Runtime Value Injection
													 Two ways of evaluating values at runtime :
														Property placeholders
														The Spring Expression Language(SPEL)
														
														@Configuration
														@PropertySource("classpath:/com/soundsystem/app.properties")
														public class ExpressiveConfig{
															
															@Autowired
															Environment env;
															
															@Bean
															public BlankDisc disc(){
																return new BlankDisc(
																	env.getProperty("disc.title"),env.getProperty("disc.artist")
																);
															}
														}
														
														Resolving properties placeholders -------> ${}
															XML	
																<bean id="sgtPeppers" class="soundsystem.BlankDisc"
																c:_title="${disc.title}"
																c:_artist="${disc.artist}" />
														
															When relying on component-scanning and autowiring to create and initialize our application components,there is no configurastion file or class
															where we can specify placeholders.Instead we can use the @Value annotation 
															
															public BlankDisc(
																@Value("${disc.title}") String title,
																@Value("${disc.artist}") String artist) {
																this.title = title;
																this.artist = artist;
															}
															
															In order to use placeholder values, you must configure either a PropertyPlaceholder-Configurer bean or a PropertySourcesPlaceholderConfigurer bean!!
															
															@Bean public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {
																return new PropertySourcesPlaceholderConfigurer();
															}
															
														Wiring with Spring Expression Language
															Spel -----------------> #{}
															
															WHEN INJECTING PROPERTIES AND CONSTRUCTOR ARGUMENTS ON BEANS THAT ARE CREATED VIA COMPONENT-SCANNING WE CAN USE THE @VALUE ANNOTATION(PLACEHOLDERS).
															RATHER THAN USE A PLACEHOLDER EXPRESSION WE CAN USE SPEL EXPRESSION.
															
															public BlankDisc(
																@Value(#{systemProperties['disc.title]}) String title,
																@value(#{systemProperties['disc.artist']} String artist	)
															){...}
															
															Working with types in expressions :
															
																T() operator !!!
																T(java.lang.Math)--> Give us access to static methods and constants
																
																Spel selection operators
																
																	#{jukebox.songs.?[artist eq 'Aerosmith']} --> Subset collection of all Aerosmith songs
																	#{jukebox.songs.^[artist eq 'Aerosmith']} --> First Matching
																	#{jukebox.songs.$[artist eq 'Aerosmith']} --> Last Matching
																	#{jukebox.songs.![title]} -> we do not want a collection of song objects but a collection of song titles.
																	
											Aspect Oriented Spring

												In software development,functions that span multiple points of an application are called CROSS-CUTTING CONCERNS.
												Typically,these cross-cutting concerns are conceptually separate from the application business logic.
												Separating these cross-cutting concerns from the business logic is where aspect oriented programming (AOP) goes to work.
												Dependency injection to manage and configure application objects. Whereas DI helps you decouple application objects from each other, AOP helps you decouple 
												cross-cutting concerns from the objects they affect.
												Aspects offer an alternative to inheritance and delegation that can be cleaner in many circumstances.
												
												Spring aspects can work with five kind of advice :
													Before
													After
													After-Returning
													After-throwing
													Around
													
												Join Points
													A join point is a point in the execution of the application where an aspect can be plugged in.
													Select join points with pointcuts.
													Spring advices are implemented as proxies that wrap the target object.
													
													Multiple Joint-Point models are available through various AOP implementations.Because it is based on dynamic proxies , Spring only supports method join points!!!
													This is in contrast to some other AOP frameworks,such as AspectJ and JBoss,which provide field and constructor join points in addition to method pointcuts.
													Spring's lack of field pointcuts prevents us from creating very fine grained advice,such as intercepting updates to an object's field.And without constructor
													pointcuts,there is no way to apply advice when a bean is instantiated.
													
													
													package concert;
													
													public interface Performance{
															public void perform();
													}
													
													execution(* concert.Performance.perform(..))
													
													Aspect
														
														@Aspect
														public class Audience{
														
															@Before(execution(* concert.Performance.perform(..)))
															public void silenceCellPhones(){
																System.out.......
															}
															
														
														}
														
														Refactoring the Audience class to use just one pointcut expression
														
														@Aspect
														public class Audience{
														
															@Pointcut(execution(* concert.Performance.perform(..)))
															public void performance(){}
															
															@Before("performance()")
															public void silenceCellPhones(){}
														}
														
														TO ENABLE THE ASPECTS IS NOT SUFFICIENT TO USE THE @Aspect ANNOTATION , WE MUST TURN ON AUTO PROXING BY APPLYING THE
														@EnbleAspectJAutoProxy in the configuration class.
														This way Spring will create a proxy around any other beans for which the aspect's pointcuts are a match.
														
														We must use the define the Audience class as a bean either!!!
														
														Using the @Around advice
														
														@Around("performance()")
														public void watchPerformance(ProceedingJointPoint jp){
															...
															...
															jp.proceed();
															..
															..
														}
														
														Access method parameters in the advice
															
															@Pointcut("execution(* soundsystem.CompactDisc.playTrack(int)) && args(trackNumber)")
															public void trackPlayed(int trackNumber) {}
															
															@Before("trackPlayed(trackNumber)")
															public void countTrack(int trackNumber)
												
													
												Annotating introductions

													Some languages, such as Ruby and Groovy, have the notion of open classes. They make it possible to add new methods to an object or class without directly
													changing the definition of those objects or classes.But Java is not dynamic.Once a class has been compiled,there is little we can do to append new functionality.
													Through Aspects we can add new methods through the AOP concept known as INTRODUCTION objects.
													When a method on a introduced interface is called,the proxy delegates the call to some other object that provides the implementation of the new interface.
													
													We want to introduce the Encoreable interface to any implementation of Performance :
													
														public interface Encoreable{
															void performEncore();
														}
														
														Now we need to apply this interface to our Performance implementations :
														
														@Aspect
														public class EncoreableIntroducer{
															@DeclareParents(value="concert.Performance+",defaultImpl=DefaultEncoreable.class)
															public static Encoreable encoreable;
														}
														
								SPRING ON THE WEB

									1 Request leaves the browser
									2 DispatcherServlet(Spring MVC funnels requests through a single front controller servlet)
									3 The DispatcherServlet consults one or more HANDLER MAPPINGS to figure out which controller will receive the request
									4 The DispatcherServlet sends the request to the controller
									  The Controller process the information, a well designed controller performs little or no processing itself and itself delegates responsibility for the business
									  logic to one or more service objects.
									  The information created needs to be sent back to the browser.That information is referred to as the MODEL.But sending raw information to the user is not sufficient
									  it needs to be formatted(typically HTML).
									5 Package the Model data and the logical view name and sent to the DispatcherServlet
									6 The DispatcherServlet consults the ViewResolver to map the logical view to the specific view implementation.
									7 The DispatcherServlet sends the data to the View implementation
									8 The View will use the model data to render output that will be carried back to the client by the Response object.
									
										Servlet 3.0 features
											Annotations to declare Servlets Filter Listeners
											Modularization of web.xml
											Dynamic registration of servlets , filters and listeners at context initialization time(Pluggability)
											Asynchronous support
											Programmatic login and logout
											ServletContainerInitializer <-----
												Just one method : onStartUp
												IMPLEMENTATION MUST BE CONFIGURED IN META-INF/services directory!!!
																	   http://piotrnowicki.com/2011/03/using-servlets-3-0-servletcontainerinitializer/
												Based on Service Provider Interface concept !!!
													This pattern allows the creation of EXTENSIBLES applications USING JAVA SERVICE LOADER.
												Very important links : http://www.logicbig.com/tutorials/core-java-tutorial/java-se-api/service-loader/
																	   https://stackoverflow.com/questions/28131102/how-servlet-container-finds-webapplicationinitializer-implementations
																	   
																	   
									Configure DispatcherServlet
				
							------------------------------------------------------------|                              
							|			public class X extends AbstractAnnotationConfigDispatcherServletInitializer{   
							|			
							|				@Override
							|				protected String[] getServletMappings() {
							|					return new String[] { "/" };         ------> 
							|				}
							|				@Override
							|				protected Class<?>[] getRootConfigClasses() {
							|					return new Class<?>[] { RootConfig.class };  ----> Configure application context created by ContextLoaderListener
							|				}
							|				@Override
							|				protected Class<?>[] getServletConfigClasses() {
							|					return new Class<?>[] { WebConfig.class };   -----> Beans for the DispatcherServlet application context
							|				}
							|			
							|			}
							|			
							|
                             ---------->Servlet 3.0 environment, the container looks for any classes in the classpath that implement the javax.servlet.ServletContainerInitializer interface; 
							 if any are found, they’re used to configure the servlet container.
							Spring supplies an implementation of that interface called SpringServletContainerInitializer that, in turn, seeks out any classes that implement WebApplicationInitializer and delegates 
							to them for configuration. Spring 3.2 introduced a convenient base implementation of WebApplicationInitializer called AbstractAnnotationConfigDispatcherServletInitializer. Because
							your SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer (and thus implements WebApplicationInitializer), it will be automatically discovered when deployed 
							in a Servlet 3.0 container and be used to configure the servlet context.


											In Spring Web Applications there is often two contexts.
											When DispatcherServlet start up,it creates a Spring application context and starts loading it with beans declared in configuration classes.
											With the getServletConfigClasses() we have asked that DispatcherServlet load its application context with beans defined in the WebConfig configuration class.
											The other context is created by ContextLoaderListener.
											The DispatcherServlet is expected to load beans containing web components such as controllers,view resolvers and handler mappings.
											ContextLoaderListener is expected to load the other beans(typically middle tier and data tier components)
											
										ENABLE SPRING MVC
										
										@Configuration
										@EnableWebMvc   <--- Enable Spring MVC
										@ComponentScan("spitter.web") <--- Enable Component Scanning
										public class WebConfig extends WebMvcConfigurerAdapter {
										
											@Bean
											public ViewResolver viewResolver() { <----- Configure a JSP View Resolver
												InternalResourceViewResolver resolver = new InternalResourceViewResolver();
												resolver.setPrefix("/WEB-INF/views/");
												resolver.setSuffix(".jsp");
												resolver.setExposeContextBeansAsAttributes(true);
												return resolver;
											}
											
											@Override
											public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { <--- To avoid DispatcherServlet to treat the request for static resources
												configurer.enable();   																	We forward requests for static resources to the servlet container's default
											}																					        servlet!!!
										}
										
										Controller
										
										@Controller <---We could annotated with @Component , but with @Controller it gains a semantically different meaning
										public class HomeController {
										
											@RequestMapping(value="/", method=GET)
											public String home() {
												return "home";
											}
										}
										
										MOCK TESTS :
											SpringJUnit4ClassRunner -> Creates application context automatically when test starts.
											@ContextConfiguration(classes=CDPlayerConfig.class) -> Where load the configuration file
											
										
										@Controller
										@RequestMapping("/spittles")
										public class SpittleController {
										
											private SpittleRepository spittleRepository;
											
											@Autowired
											public SpittleController(SpittleRepository spittleRepository) {
												this.spittleRepository = spittleRepository;
											}
											
											@RequestMapping(method=RequestMethod.GET)
											public String spittles(Model model) {
												model.addAttribute(spittleRepository.findSpittles(Long.MAX_VALUE, 20));
												return "spittles";
											}
										}
										
											Model is essentially a Map that will be handed off to the view so that data can be rendered to the client.
											when addAttribute is called without specifying a key,the key is inferred from the type of object being set as a value.In this case, because it’s a List<Spittle>, 
											the key will be inferred as spittleList.
											We could be explicit about the model key :
												addAttribute("spittleList",...)
												
											We could either work with a non-Spring type
											public String spittles(Map model)
											
											And finally we can rely on defaults , this the method could be implement simply like that :
											@RequestMapping(method=RequestMethod.GET)
											public List<Spittle> spittles() {
												return spittleRepository.findSpittles(Long.MAX_VALUE, 20));
											}
											WHEN A HANDLER METHOD RETURNS AN OBJECT OR A COLLECTION LIKE THIS,THE VALUE RETURNED IS PUT INTO THE MODEL AND THE MODEL KEY IS INFERRED FROM ITS TYPE.
											THE LOGICAL VIEW IS INFERRED FROM THE REQUEST PATH.
											
											
										Three ways Spring MVC allows a client pass data into a controller :
											Query parameters
												@RequestMapping(method=RequestMethod.GET)
												public List<Spittle> spittles(@RequestParam(value="max",defaultValue=MAX_LONG_AS_STRING) long max,
																			  @RequestParam(value="count", defaultValue="20") int count) {
													return spittleRepository.findSpittles(max, count);
												}
												
											Form parameters
												a form without an action parameter set will be POSTED BACK to the same URL path that displayed it.
												
												@RequestMapping(value="/register", method=POST)
												public String processRegistration(Spitter spitter) {
													spitterRepository.save(spitter);
													return "redirect:/spitter/" + spitter.getUsername(); -----> When InternalResourceViewResolver sees the redirect prefix interpret it as redirect specification 
												}   															instead of a view name.
												
													TO VALIDATE THE FORM SPRING SUPPORT FOR THE JAVA VALIDATION API(a.k.a JSR-303).We just need to make sure an implementation of the Java API,such as 
													Hibernate Validator,is in the project classpath.
													
													public class Spitter{
														
														private Long id;
														
														@NotNull
														@Size(min=5,max=16)
														private String username;
														
														...
													
													}
													
													
													@RequestMapping(value="/register", method=POST)
													public String processRegistration(@Valid Spitter spitter,Errors errors) {
														if (errors.hasErrors()) {
															return "registerForm";
														}	
														...
													}
												
											
											Path parameters
											
												If we want to support for instance the display of a single spittle given its ID, one option is to accept the ID as query parameter 
												using @RequestParam
												
												@RequestMapping(value="/show", method=RequestMethod.GET)
												public String showSpittle(
												@RequestParam("spittle_id") long spittle
												
												This handler method would handle requests such as /spittles/show?spittle_id=12345.
												Although this could be made to work, it’s not ideal from a resource-orientation perspective.
												Ideally, the resource being identified (the Spittle) would be identified by
												the URL path, not by query parameters. As a general rule, query parameters should
												not be used to identify a resource. A GET request for /spittles/12345 is better than one
												for /spittles/show?spittle_id=12345. The former identifies a resource to be retrieved.
												The latter describes an operation with a parameter—essentially RPC over HTTP.
												To accommodate these path variables, Spring MVC allows for placeholders in an @RequestMapping path.
												
												@RequestMapping(value="/{spittleId}", method=RequestMethod.GET)
												public String spittle(
												@PathVariable("spittleId") long spittleId,
												
												Sugar syntax
													If no value attribute is given for @PathVariable, it assumes the placeholder’s name is the same as the method parameter name!!!
												
												handle requests for /spittles/12345
												
												Understanding VIEW RESOLUTION
												
													public interface ViewResolver{
														View resolveViewName(String name,Locale locale) throws Exception;
													}
													
														THIS RETURNS A VIEW INSTANCE :
														
														public interface View{
															String getContentType();
															void render(Map<String,?> model,HttpServletRequest request,HttpServletResponse response);
														}
														
													Spring supports JSP views in two ways :

														InternalResourceViewResolver can be used to resolve view names into JSP files.If we are using JSTL tags in our JSP pages,
														InternalResourceViewResolver can resolve view names into JSP files fronted by JstlView to expose JSTL locale and resource bundle
														variables to JSTL formatting and message tags.
														
														Binding forms to model :
															Use the Spring's form-binding tag library
															
																<%@ taglib uri="http://www.springframework.org/tags/form" prefix="sf" %>
																										_____________________________
																<sf:form method="POST" commandName="spitter">						|
																First Name: <sf:input path="firstName" /><br/>						|
																				<sf:errors path="firstName" cssClass="error"/><br/>	|
																...																	|
																																	|
																@RequestMapping(value="/register", method=GET)						|
																public String showRegistrationForm(Model model) {                   |
																	model.addAttribute(new Spitter());-------------------------------
																	return "registerForm";            The model key will be inferred from the object type
																}
																
																Error messages from property files
																	@NotNull
																	@Size(min=5, max=16, message="{username.size}")
																	private String username;
																	
										SPRING MVC IS A REQUEST (ACTION) BASED FRAMEWORK
										JSF IS A COMPONENT BASED FRAMEWORK
										
										Customizing DispatcherServlet :
										
											After AbstractAnnotationConfigDispatcherServletInitializer registers DispatcherServlet with servlet container,it calls the customizeRegistrattion() method,passing in
											the ServletRegistration.Dynamic that resulted from the servlet registration.By overriding customizeRegistrattion() we can apply additional configuration to DispatcherServlet.
											For instance, configure multipart support:
											
												@Override
												protected void customizeRegistration(Dynamic registration) {
													registration.setMultipartConfig(new MultipartConfigElement("/tmp/spittr/uploads"));
												}
												
												Given the way that AbstractAnnotationConfigDispatcherServletInitializer is defined, it will create a DispatcherServlet and a ContextLoaderListener. But what
												if you want to register additional servlets, filters, or listeners?
												
												Therefore, if you need to register any additional components into the web container, you need only create a new initializer class. The easiest way to do this is by 
												implementing Spring’s WebApplicationInitializer interface.
												
											Multipart Resolver
												DispatcherServlet doesn’t implement any logic for parsing the data in a multipart request. Instead, it delegates to an implementation of Spring’s MultipartResolver
												strategy interface to resolve the content in a multipart request. Since Spring 3.1, Spring comes with two out-of-the-box implementations of MultipartResolver to
												choose from:
												 CommonsMultipartResolver — Resolves multipart requests using Jakarta Commons FileUpload
												 StandardServletMultipartResolver — Relies on Servlet 3.0 support for multipart requests (since Spring 3.1)
												 
												 Thymeleaf
												 
													<form method="POST" th:object="${spitter}" enctype="multipart/form-data">
													...
													<label>Profile Picture</label>:
													<input type="file" name="profilePicture" accept="image/jpeg,image/png,image/gif" /><br/>
													...
													</form>
												 
												 In the Controller 
													@RequestMapping(value="/register", method=POST)
													public String processRegistration(@RequestPart("profilePicture") byte[] profilePicture,@Valid Spitter spitter,Errors errors) {
													...
													}
													
											Advisors Controllers

												Certain aspects of controller classes might be handier if they could be applied broadly across all controllers in a given application. @ExceptionHandler methods, for
												instance, could prove useful in handling exceptions across multiple controllers.
												
											Carrying data across redirect requests
												Typically when a handler method completes,any model data specified in the method is copied into the request as request attributes,and the request is forward
												to the view for rendering.Because it is the same request that is handled by both the controller method and the view,the request attributes survive the forward.
												But when a controller method results in a redirect, the original request ends and a new HTTP GET request begins. Any model data carried in
												the original request dies with the request. The new request is devoid of any model data in its attributes and has to figure it out on its own.
												
													return "redirect:/spitter/" + spitter.getUsername();
													The redirect: prefix makes working with redirects plain and simple!!!
													
												In Servlet specification there is two different paths :

													The sendRedirect() method of HttpServletResponse interface
														The sendRedirect() method works at client side.
														It always sends a new request.
													forward() method of RequestDispatcher
														The forward() method works at server side.
														It sends the same request and response objects to another servlet.
														
												In Spring we have two options:
												
													Passing data as path variables and/or query parameters using URL templates
														Model attributes are ultimately copied into the request as request attributes!!!!
													Sending data in flash attributes
														One option regarding the path and query parameters is to put the data into session!!!
														Spring doesn't think you should be responsible for managing that data.
														Spring offers a way to set flash attributes via RedirectAttributes, a sub-interface of Model added in Spring 3.1.
														
								Spring Web Flow
										
										Spring Web Flow is an extension to Spring MVC that enables development of flow based web applications. It does this by separating the definition of an application’s
										flow from the classes and views that implement the flow’s behavior.
										
										Flow Executor
										Flow Register
											<flow:flow-registry id="flowRegistry" base-path="/WEB-INF/flows">
												<flow:flow-location-pattern value="*-flow.xml" />
											</flow:flow-registry>
											
										Handling flow requests
											As we saw in the previous chapter, DispatcherServlet typically dispatches requests to controllers. But for flows, we need a FlowHandlerMapping to help Dispatcher-Servlet 
											know that it should send flow requests to Spring Web Flow. The FlowHandler-Mapping is configured in the Spring application context like this:
											
											<bean class="org.springframework.webflow.mvc.servlet.FlowHandlerMapping">
												<property name="flowRegistry" ref="flowRegistry" />
											</bean>	
											
										Whereas the FlowHandlerMapping’s job is to direct flow requests to Spring Web Flow, it’s the job of a FlowHandlerAdapter to answer that call. A FlowHandlerAdapter
										is equivalent to a Spring MVC controller in that it handles requests coming in for a flow and processes those requests. The FlowHandlerAdapter is wired as a Spring bean
										like this:
											<bean class="org.springframework.webflow.mvc.servlet.FlowHandlerAdapter">
												<property name="flowExecutor" ref="flowExecutor" />
											</bean>	
										
										FLOW COMPONENTS
											States
												Action
												Decision
												End
												Subflow
												View
											Transitions
												Transitions connect the states within a flow.
												Transitions are defined to take place on some event being fired.
													<transition on="phoneEntered" to="lookupCustomer"/>
													
												GLOBAL TRANSITIONS
													<global-transitions>
														<transition on="cancel" to="endState" />
													</global-transitions>
													
											SCOPING FLOW DATA
												Conversation
												Flow
												Request
												Flash
												View
										
										                                   (CustomerReady)           (orderCreated)           (paymentTaked)
											START---------Identify Customer---------------buildOrder---------------takePayment---------------saveOrder----------thank customer--------END
											
											<?xml version="1.0" encoding="UTF-8"?>
											<flow xmlns="http://www.springframework.org/schema/webflow" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
											xsi:schemaLocation="http://www.springframework.org/schema/webflow http://www.springframework.org/schema/webflow/spring-webflow-2.3.xsd">
												<var name="order" class="com.springinaction.pizza.domain.Order"/>
												<subflow-state id="identifyCustomer" subflow="pizza/customer">
													<output name="customer" value="order.customer"/>
													<transition on="customerReady" to="buildOrder" />
												</subflow-state>
												<subflow-state id="buildOrder" subflow="pizza/order">
													<input name="order" value="order"/>
													<transition on="orderCreated" to="takePayment" />
												</subflow-state>
												<subflow-state id="takePayment" subflow="pizza/payment">
													<input name="order" value="order"/>
													<transition on="paymentTaken" to="saveOrder"/>
												</subflow-state>
												<action-state id="saveOrder">
													<evaluate expression="pizzaFlowActions.saveOrder(order)" />
													<transition to="thankCustomer" />
												</action-state>
												<view-state id="thankCustomer">
													<transition to="endState" />
												</view-state>
												<end-state id="endState" />
												<global-transitions>
													<transition on="cancel" to="endState" />
												</global-transitions>
											</flow>
											
											thankCustomer
												...
												<a href='${flowExecutionUrl}&_eventId=finished'>Finish</a>
												
												flowExecutionUrl variable, which contains the URL for the flow, for use in the view. The Finish link attaches an _eventId parameter to the
												URL to fire a finished event back to the web flow.
												
												
												
												SubFlow "identifyCustomer"
												                           (phoneEntered)                        (CustomerNotFoundException)
												START------------welcome--------------------------lookupCustomer-----------------------registrationForm--------------------------------
												                    |                                   |                                    |                                        |
																	|									|									 |										  |
																	|									|									 |                                        |
																	|									|									 |                                        |
																	|									|									 |                                        |
																	|									|								CheckDeliveryArea------------                 |
																	|									|									 |  true                |   false         |Cancel  
																	|									|									 |                      |                 |
																	|									|									 |       (Accept)       |                 |
																	|							CUSTOMERREADY<----------------------- addCustomer<----------deliveryWarning           |
																	|																	     |                                        |
																	|																		 |                                        |
																	|																		 |                                        |
																	|																		 |Cancel                                  |
																	|							Cancel        								 |                                        |
																	|--------------------------------------------------------------------->CANCEL<------------------------------------
													
													<?xml version="1.0" encoding="UTF-8"?>
													<flow xmlns="http://www.springframework.org/schema/webflow" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
													xsi:schemaLocation="http://www.springframework.org/schema/webflow http://www.springframework.org/schema/webflow/spring-webflow-2.3.xsd">
														<var name="customer" class="com.springinaction.pizza.domain.Customer"/>
														<view-state id="welcome">
															<transition on="phoneEntered" to="lookupCustomer"/>
														</view-state>
														<action-state id="lookupCustomer">
															<evaluate result="customer" expression= "pizzaFlowActions.lookupCustomer(requestParameters.phoneNumber)" />
															<transition to="registrationForm" on-exception="com.springinaction.pizza.service.CustomerNotFoundException" />
															<transition to="customerReady" />
														</action-state>
														<view-state id="registrationForm" model="customer">
															<on-entry>
																<evaluate expression="customer.phoneNumber = requestParameters.phoneNumber" />
															</on-entry>
															<transition on="submit" to="checkDeliveryArea" />
														</view-state>
														<decision-state id="checkDeliveryArea">
															<if test="pizzaFlowActions.checkDeliveryArea(customer.zipCode)" then="addCustomer" else="deliveryWarning"/>
														</decision-state>
														<view-state id="deliveryWarning">
															<transition on="accept" to="addCustomer" />
														</view-state>
														<action-state id="addCustomer">
															<evaluate expression="pizzaFlowActions.addCustomer(customer)" />
															<transition to="customerReady" />
														</action-state>
														<end-state id="cancel" />
														<end-state id="customerReady">
															<output name="customer" />
														</end-state>
														<global-transitions>
															<transition on="cancel" to="cancel" />
														</global-transitions>
													</flow>
													
													
									Securing Web Applications

												Spring Security, a security framework implemented with Spring AOP and servlet filters.
												To secure web requests and restrict access at the URL level, Spring Security uses servlet filters. Spring Security can also secure method invocations 
												using Spring AOP, proxying objects and applying advice to ensure that the user has the proper authority to invoke secured methods.
												
												Filtering Web Requests
												
													Configuring in web.xml
														<filter>
															<filter-name>springSecurityFilterChain</filter-name>
															<filter-class>
																org.springframework.web.filter.DelegatingFilterProxy
															</filter-class>
														</filter>
														
														In Java
														
														Create a new class that extends AbstractSecurityWebApplicationInitializer:

															package spitter.config;
															import org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer;
															
															public class SecurityWebInitializer extends AbstractSecurityWebApplicationInitializer {}
															
															AbstractSecurityWebApplicationInitializer implements WebApplicationInitializer, so it will be discovered by Spring 
															and be used to register DelegatingFilterProxy with the web container.
															Although you can override its appendFilters() or insertFilters() methods to register filters of your own choosing, you need not
															override anything to register DelegatingFilterProxy.
															Whether you configure DelegatingFilterProxy in web.xml or by subclassing AbstractSecurityWebApplicationInitializer, it will intercept requests coming
															into the application and delegate them to a bean whose ID is springSecurityFilterChain<---Very important
															
															As for the springSecurityFilterChain bean itself,it is another special filter known as FilterChainProxy,it is a single filter that chains together
															one or more additional filters.
															Spring Security relies on several servlet filters to provide different security features, but you should almost never need to know these details, as you likely
															won't need to explicitly declare the springSecurityFilterChain bean or any of the filters it chains together. 
															Those filters will be created when you enable web security.
															
														Configure Security Configuration

															@Configuration
															@EnableWebSecurity
															public class SecurityConfig extends WebSecurityConfigurerAdapter {
															}
															
														Spring Security must be configured in a bean that implements WebSecurityConfigurer or (for convenience) extends WebSecurityConfigurerAdapter. 
														Any bean in the Spring application context that implements WebSecurityConfigurer can contribute to Spring Security configuration, but it's often most
														convenient for the configuration class to extend WebSecurityConfigurerAdapter.
														@EnableWebSecurity is generally useful for enabling security in any web application.But if we happen to be developing a Spring MVC application, we should consider
														using @EnableWebMvcSecurity.
														Among other things, the @EnableWebMvcSecurity annotation configures a Spring MVC argument resolver so that handler methods can receive the authenticated user’s
														principal (or username) via @AuthenticationPrincipal-annotated parameters. It also configures a bean that automatically adds a hidden cross-site request forgery
														(CSRF) token field on forms using Spring’s form-binding tag library.
														
														Overriding WebSecurityConfigurerAdapter configure methods :
															
																configure(WebSecurity)
																	Override to configure Spring Security’s filter chain.
																configure(HttpSecurity)
																	Override to configure how requests are secured by interceptors.
																configure(AuthenticationManagerBuilder)
																	Override to configure user-details services.
																	
														USER STORE

															In Memory
																@Override
																protected void configure(AuthenticationManagerBuilder auth) throws Exception {
																	auth.inMemoryAuthentication().withUser("user").password("password").roles("USER").and().withUser("admin").password("password").roles("USER", "ADMIN");
																}
															Database
																@Autowired
																DataSource dataSource;
																@Override
																protected void configure(AuthenticationManagerBuilder auth) throws Exception {
																	auth.jdbcAuthentication().dataSource(dataSource);
																}
																
																IT MAKES SOME ASSUMPTIONS ABOUT YOUR DATABASE SCHEMA!!!
																
																Alternative
																	.usersByUsernameQuery("select username, password, true from Spitter where username=?")
																	
																WORKING WITH ENCODED PASSWORDS

																	auth.jdbcAuthentication().dataSource(dataSource).usersByUsernameQuery("select username, password, true from Spitter where username=?")
																	.authoritiesByUsernameQuery("select username, 'ROLE_USER' from Spitter where username=?").passwordEncoder(new StandardPasswordEncoder("53cr3t"));
																	
																	The passwordEncoder method accepts any implementation of Spring Security’s PasswordEncoder interface. Spring Security’s cryptography module includes
																	three such implementations: BCryptPasswordEncoder, NoOpPasswordEncoder, and StandardPasswordEncoder.
																	We can always provide your own custom implementation!!!
																	
																	public interface PasswordEncoder {
																		String encode(CharSequence rawPassword);
																		boolean matches(CharSequence rawPassword, String encodedPassword);
																	}
																	
																	No matter which password encoder you use, it’s important to understand that the password in the database is never decoded. 
																	Instead, the password that the user enters at login is encoded using the same algorithm and is then compared with the encoded
																	password in the database. That comparison is performed in the PasswordEncoder’s matches() method.
																	
																	CUSTOM USER SERVICE
																	
																	public interface UserDetailsService {
																		UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
																	}
																	
																	@Autowired
																    SpitterRepository spitterRepository;

																	@Override
																	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
																		auth.userDetailsService(new SpitterUserService(spitterRepository));
																	}
																	
															Security Requests
																@Override
																protected void configure(HttpSecurity http) throws Exception {
																	http.authorizeRequests().antMatchers("/spitters/me").authenticated().antMatchers(HttpMethod.POST, "/spittles").authenticated().anyRequest().permitAll();
																}
																
																Most methods are one-dimensional,we can use hasRole() to require a certain role,but we can not also use hasIpAddress() to require a specific
																IP address on the same path.
																Using access() method we can also use SPEL as a means for declaring access requirements.
																
																	.antMatchers("/spitter/me").access("hasRole('ROLE_SPITTER')")
																	.antMatchers("/spitter/me").access("hasRole('ROLE_SPITTER') and hasIpAddress('192.168.1.2')")
																	
																In addition to the authorizeRequests() method, the HttpSecurity object passed into configure() has a requiresChannel() method that lets you declare channel
																requirements for various URL patterns.
																
																@Override
																protected void configure(HttpSecurity http) throws Exception {
																	http.authorizeRequests().antMatchers("/spitter/me").hasRole("SPITTER").antMatchers(HttpMethod.POST, "/spittles").hasRole("SPITTER")
																	.anyRequest().permitAll().and().requiresChannel().antMatchers("/spitter/form").requiresSecure();
																}
																
																Spring Security implements CSRF protection with a synchronizer token. State changing requests (for example, any request that is not GET, HEAD, OPTIONS, 
																or TRACE) will be intercepted and checked for a CSRF token. If the request doesn’t carry a CSRF token, or if the token doesn’t match the token on 
																the server, the request will fail with a CsrfException.
																
															Remember me functionality
															
												Spring in the backend
															
															Spring data access

																Service Object ----------------------------->   Repository Interface
																														^
																														|
																														|
																														|
																														|
																														|
																														|
																														|
																												Repository Implementation


															Templating Data Access
															
																Template Method Pattern
																	A template method defines the skeleton of a process.
																	Implements the fixed parts and the variable parts delegates to implementation-specific portions of the process to an interface.
																	Spring separates the fixed and variable parts of the data-access process into two distinct classes: templates and callbacks.
																	Templates manage the fixed part of the process, whereas your custom data-access code is handled in callbacks.
																	
																	
																Defining a datasource
																	Data sources that are defined by a JDBC driver
																	Data sources that are looked up by JNDI
																	Data sources that pool connections
																	
																	
												How JDBC works
													The JDBC specification requires that compliant drivers register themselves with java.sql.DriverManager when they are loaded(using static initializers blocks).
													Starting from JDBC 4.0(JDK6),JDBC drivers are required to specify a services definition declaring all java.sql.Driver implementations provided by 
													the driver (usually one). This is done through a file META-INF/services/java.sql.Driver.
													The DriverManager will query all instances of this file on the classpath (using java.util.ServiceLoader and load all driver implementations contained in these files. 
													As a (compliant) driver is required to register itself, all these implementations are now registered with DriverManager.
													IT USE THE SERVICE PROVIDER INTERFACE!!!!!READ ABOUT IT.
													
													Because of its properties, a DataSource object is a better alternative than the DriverManager class for getting a connection. Programmers no longer have to hard code 
													the driver name or JDBC URL in their applications, which makes them more portable. Also, DataSource properties make maintaining code much simpler. 
													If there is a change, the system administrator can update data source properties and not be concerned about changing every application that makes a connection to 
													the data source. For example, if the data source were moved to a different server, all the system administrator would have to do is set the serverName property 
													to the new server name.
													Aside from portability and ease of maintenance, using a DataSource object to get connections can offer other advantages. When the DataSource interface is 
													implemented to work with a ConnectionPoolDataSource implementation, all of the connections produced by instances of that DataSource class will automatically 
													be pooled connections. Similarly, when the DataSource implementation is implemented to work with an XADataSource class, all of the connections it produces 
													will automatically be connections that can be used in a distributed transaction. The next section shows how to deploy these types of DataSource implementations.
													
													https://docs.oracle.com/javase/tutorial/jdbc/basics/sqldatasources.html
																	
																	JNDI
																		XML
																			<jee:jndi-lookup id="dataSource" jndi-name="/jdbc/SpitterDS" resource-ref="true" />
																				If the application is running in a Java application server, you’ll want to set the resource-ref property to true so that the 
																				value given in jndi-name will be prepended with java:comp/env/.
																		JAVA
																			@Bean
																			public JndiObjectFactoryBean dataSource() {
																				JndiObjectFactoryBean jndiObjectFB = new JndiObjectFactoryBean();
																				jndiObjectFB.setJndiName("jdbc/SpittrDS");
																				jndiObjectFB.setResourceRef(true);
																				jndiObjectFB.setProxyInterface(javax.sql.DataSource.class);
																				return jndiObjectFB;
																			}
																	Pooled Connections		
																			Most of these connection pools can be configured as a data source in Spring in a way that resembles Spring’s own DriverManagerDataSource or 
																			SingleConnectionDataSource
																			
																			XML
																				<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
																				p:driverClassName="org.h2.Driver"
																				p:url="jdbc:h2:tcp://localhost/~/spitter"
																				p:username="sa"
																				p:password=""
																				p:initialSize="5"
																				p:maxActive="10" />
																			JAVA
																				@Bean
																				public BasicDataSource dataSource() {
																					BasicDataSource ds = new BasicDataSource();
																					ds.setDriverClassName("org.h2.Driver");
																					ds.setUrl("jdbc:h2:tcp://localhost/~/spitter");
																					ds.setUsername("sa");
																					ds.setPassword("");
																					ds.setInitialSize(5);
																					ds.setMaxActive(10);
																					return ds;
																				}
																				
																	JDBC driver based data sources

																		DriverManagerDataSource
																			Returns a new connection every time a connection is requested. Unlike DBCP’s BasicDataSource, the connections provided
																			by DriverManagerDataSource aren't pooled.
																		SimpleDriverDataSource
																			Works much the same as DriverManagerDataSource except that it works with the JDBC driver directly to overcome class loading
																			issues that may arise in certain environments, such as in an OSGi container.
																		SingleConnectionDataSource
																			Returns the same connection every time a connection is requested. Although SingleConnectionDataSource isn’t exactly
																			a pooled data source, you can think of it as a data source with a pool of exactly one connection.
																			
																		Example
																			@Bean
																			public DataSource dataSource() {
																				DriverManagerDataSource ds = new DriverManagerDataSource();
																				ds.setDriverClassName("org.h2.Driver");
																				ds.setUrl("jdbc:h2:tcp://localhost/~/spitter");
																				ds.setUsername("sa");
																				ds.setPassword("");
																				return ds;
																			}
																			
																			public Spitter findOne(long id) {
																				return jdbcOperations.queryForObject(SELECT_SPITTER_BY_ID, new SpitterRowMapper(),id);
																			}
																			
																			private static final class SpitterRowMapper implements RowMapper<Spitter> {
																				public Spitter mapRow(ResultSet rs, int rowNum) throws SQLException {
																					return new Spitter(
																									rs.getLong("id"),
																									rs.getString("username"),
																									rs.getString("password"),
																									rs.getString("fullName"),
																									rs.getString("email"),
																									rs.getBoolean("updateByEmail"));
																				}
																			}
																			
																			Because the RowMapper interface only declares the addRow() method, it fits the bill for a functional interface. 
																			This means that if you’re developing your application using Java 8, you can express the RowMapper implementation with a lambda instead of 
																			with a concrete class implementation.
																			The findOne() method can be rewritten using Java 8 lambdas like this:
																			
																				public Spitter findOne(long id) {
																					return jdbcOperations.queryForObject(
																						SELECT_SPITTER_BY_ID,(rs, rowNum) -> {
																							return new Spitter(
																								rs.getLong("id"),
																								rs.getString("username"),
																								rs.getString("password"),
																								rs.getString("fullName"),
																								rs.getString("email"),
																								rs.getBoolean("updateByEmail"));
																							},
																						id);
																				}
																				
																				Method references
																					public Spitter findOne(long id) {
																						return jdbcOperations.queryForObject(SELECT_SPITTER_BY_ID, this::mapSpitter, id);
																					}
																					
																					private Spitter mapSpitter(ResultSet rs, int row) throws SQLException {
																					return new Spitter(
																						rs.getLong("id"),
																						rs.getString("username"),
																						rs.getString("password"),
																						rs.getString("fullName"),
																						rs.getString("email"),
																						rs.getBoolean("updateByEmail"));
																					}
																					
																Persisting data with object-relational mapping
																	Lazy Loading
																	Eager Fetching
																	Cascading
																	Caching
																	
																	Hibernate
																		Interface to work with Hibernate is org.hibernate.Session(provides basic data-access functionality like save,update and load.
																		To get a reference to Session is through an implementation of SessionFactory interface.
																		In Spring to get an SessionFactory is through session-factory beans.
																		
																		@Bean
																		public LocalSessionFactoryBean sessionFactory(DataSource dataSource) {
																			LocalSessionFactoryBean sfb = new LocalSessionFactoryBean();
																			sfb.setDataSource(dataSource);
																			sfb.setPackagesToScan(new String[] { "com.habuma.spittr.domain" });
																			Properties props = new Properties();
																			props.setProperty("dialect", "org.hibernate.dialect.H2Dialect");
																			sfb.setHibernateProperties(props);
																			return sfb;
																		}
																		
																		
																		@Repository -->
																			One of Spring’s stereotype annotations that, among other things, are scanned by Spring component-scanning. This means you
																			won't have to explicitly declare a HibernateSpitterRepository bean, as long as the repository class is in a package covered by component-scanning.
																			In addition to helping to reduce explicit configuration, @Repository serves another purpose. Recall that one of the jobs of a template class 
																			is to catch platform specific exceptions and rethrow them as one of Spring’s unified unchecked exceptions.
																			But if you’re using Hibernate contextual sessions and not a Hibernate template, how can the exception translation take place?
																			To add exception translation to a template-less Hibernate repository, you just need
																			to add a PersistenceExceptionTranslationPostProcessor bean to the Spring application context:
																			@Bean
																			public BeanPostProcessor persistenceTranslation() {
																				return new PersistenceExceptionTranslationPostProcessor();
																			}
																			PersistenceExceptionTranslationPostProcessor is a bean post-processor that adds an adviser to any bean that's annotated with @Repository 
																			so that any platform-specific exceptions are caught and then rethrown as one of Spring’s unchecked data-access exceptions.
																		
																		public HibernateSpitterRepository(SessionFactory sessionFactory) {
																			this.sessionFactory = sessionFactory;
																		}
																		
																		private Session currentSession() {
																			return sessionFactory.getCurrentSession();
																		}
																		
																		public long count() {
																			return findAll().size();
																		}
																		
																		public Spitter save(Spitter spitter) {
																			Serializable id = currentSession().save(spitter);
																			return new Spitter((Long) id,
																			spitter.getUsername(),
																			spitter.getPassword(),
																			spitter.getFullName(),
																			spitter.getEmail(),
																			spitter.isUpdateByEmail());
																		}
																		
																		public Spitter findOne(long id) {
																			return (Spitter) currentSession().get(Spitter.class, id);
																		}
																		
																		public Spitter findByUsername(String username) {
																			return (Spitter) currentSession().createCriteria(Spitter.class).add(Restrictions.eq("username", username)).list().get(0);
																		}
																		
																		public List<Spitter> findAll() {
																			return (List<Spitter>) currentSession().createCriteria(Spitter.class).list();
																		}
																		}
																		
															Spring and JPA

																JPA-based applications use an implementation of EntityManagerFactory to get an instance of an EntityManager. The JPA specification defines two
																kinds of entity managers:
																	Application-managed—Entity managers are created when an application directly requests one from an entity manager factory. 
																	With application-managed entity managers, the application is responsible for opening or closing entity managers and involving the entity manager 
																	in transactions. This type of entity manager is most appropriate for use in standalone applications that don’t run in a Java EE container.
														
																	Container-managed—Entity managers are created and managed by a Java EE container. The application doesn't interact with the entity manager factory at
																	all. Instead, entity managers are obtained directly through injection or from JNDI. The container is responsible for configuring the entity manager 
																	factories. This type of entity manager is most appropriate for use by a Java EE container that wants to maintain some control over JPA 
																	configuration beyond what's specified in persistence.xml.
																	
																	LocalEntityManagerFactoryBean produces an application-managed EntityManagerFactory.
																	LocalContainerEntityManagerFactoryBean produces a container-managed EntityManagerFactory.
																	
																	CONFIGURING APPLICATION-MANAGED JPA
																	
																	Application-managed entity-manager factories derive most of their configuration information from a configuration file called persistence.xml. 
																	This file must appear in the META-INF directory in the classpath.
																	The purpose of the persistence.xml file is to define one or more persistence units. A persistence unit is a grouping of one or more persistent 
																	classes that correspond to a single data source.
																	
																	<persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">
																		<persistence-unit name="spitterPU">
																			<class>com.habuma.spittr.domain.Spitter</class>
																			<class>com.habuma.spittr.domain.Spittle</class>
																			<properties>
																				<property name="toplink.jdbc.driver" value="org.hsqldb.jdbcDriver" />
																				<property name="toplink.jdbc.url" value= "jdbc:hsqldb:hsql://localhost/spitter/spitter" />
																				<property name="toplink.jdbc.user"value="sa" />
																				<property name="toplink.jdbc.password" value="" />
																			</properties>
																		</persistence-unit>
																	</persistence>
																	
																	@Bean
																	public LocalEntityManagerFactoryBean entityManagerFactoryBean() {
																		LocalEntityManagerFactoryBean emfb = new LocalEntityManagerFactoryBean();
																		emfb.setPersistenceUnitName("spitterPU");
																		return emfb;
																	}
																	
																	CONFIGURING CONTAINER-MANAGED JPA
																	
																	@Bean
																	public LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource, JpaVendorAdapter jpaVendorAdapter) {
																		LocalContainerEntityManagerFactoryBean emfb =
																		new LocalContainerEntityManagerFactoryBean();
																		emfb.setDataSource(dataSource);
																		emfb.setJpaVendorAdapter(jpaVendorAdapter);
																		return emfb;
																	}
																	
																	You can use the jpaVendorAdapter property to provide specifics about the particular JPA implementation to use. Spring comes with a handful of 
																	JPA vendor adapters to choose from:
																		 EclipseLinkJpaVendorAdapter
																		 HibernateJpaVendorAdapter
																		 OpenJpaVendorAdapter
																		 
																	@Bean
																	public JpaVendorAdapter jpaVendorAdapter() {
																		HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter();
																		adapter.setDatabase("HSQL");
																		adapter.setShowSql(true);
																		adapter.setGenerateDdl(false);
																		adapter.setDatabasePlatform("org.hibernate.dialect.HSQLDialect");
																		return adapter;
																	}
																	
																	Certain dynamic persistence features require that the class of persistent objects be modified with instrumentation to support the feature. 
																	Objects whose properties are lazily loaded (they won’t be retrieved from the database until they’re accessed) must have their class instrumented 
																	with code that knows to retrieve unloaded data on access. Some frameworks use dynamic proxies to implement lazy loading.
																	Others, such as JDO, perform class instrumentation at compile time.
																	
																	@Repository
																	@Transactional
																	public class JpaSpitterRepository implements SpitterRepository {
																	
																		@PersistenceUnit
																		private EntityManagerFactory emf;
																		
																		public void addSpitter(Spitter spitter) {
																			emf.createEntityManager().persist(spitter);
																		}
																		
																		public Spitter getSpitterById(long id) {
																			return emf.createEntityManager().find(Spitter.class, id);
																		}
																		
																		public void saveSpitter(Spitter spitter) {
																			emf.createEntityManager().merge(spitter);
																		}
																		...
																	}
																	
																	Problem -> Each method ends up calling createEntityManager().
																			   The problem is that an EntityManager isn't thread-safe and generally shouldn't be injected into a shared singleton bean like your repository.
																	
																	
																	@Repository
																	@Transactional  --> persistence methods in this repository are involved in a transactional context.
																	public class JpaSpitterRepository implements SpitterRepository {
																		@PersistenceContext
																		private EntityManager em;
																		
																		public void addSpitter(Spitter spitter) {
																			em.persist(spitter);
																		}
																		
																		public Spitter getSpitterById(long id) {
																			return em.find(Spitter.class, id);
																		}
																		
																		public void saveSpitter(Spitter spitter) {
																			em.merge(spitter);
																		}
																		...
																	}
																	
																	@PersistenceContext doesn't inject an EntityManager -at least,not exactly. Instead of giving the repository a real EntityManager, it gives a proxy to a
																	real EntityManager. That real EntityManager either is one associated with the current transaction or, if one doesn’t exist, creates a new one. 
																	Thus, you know that you're always working with an entity manager in a thread-safe way.
																	
																	It's important to understand that @PersistenceUnit and @PersistenceContext aren't Spring annotations; they're provided by the JPA specification. 
																	In order forSpring to understand them and inject an EntityManagerFactory or EntityManager,Spring's PersistenceAnnotationBeanPostProcessor 
																	must be configured.
																	
																	@Bean
																	public PersistenceAnnotationBeanPostProcessor paPostProcessor() {
																		return new PersistenceAnnotationBeanPostProcessor();
																	}
																	
														Automatic JPA repositories with Spring Data
																public interface SpitterRepository extends JpaRepository<Spitter, Long> {
																}
																
																To ask Spring Data to create an implementation of SpitterRepository, you need to add a single element to your Spring configuration.
																
																<?xml version="1.0" encoding="UTF-8"?>
																<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
																	xmlns:jpa="http://www.springframework.org/schema/data/jpa" xsi:schemaLocation="http://www.springframework.org/schema/data/jpa
																	http://www.springframework.org/schema/data/jpa/spring-jpa-1.0.xsd">
																	
																	<jpa:repositories base-package="com.habuma.spittr.db" />
																	...
																</beans>
																
																The <jpa:repositories> element holds all the magic of Spring Data JPA. Much like the <context:component-scan> element, <jpa:repositories> is 
																given a base package to scan. But where <context:component-scan> scans a package (and its subpackages) for classes that are annotated with 
																@Component, <jpa:repositories> scans its base package for any interfaces that extend Spring Data JPA’s Repository interface.
																When it finds any interface extending Repository, it automatically (at application startup time) generates an implementation of that interface.
																Instead of using the <jpa:repositories> element, you can use @EnableJpaRepositories in your Java configuration class.
																
																@Configuration
																@EnableJpaRepositories(basePackages="com.habuma.spittr.db")
																public class JpaConfiguration {
																...
																}
																
																Spring Data JPA provides a few ways to add custom methods to a repository
																
																public interface SpitterRepository extends JpaRepository<Spitter, Long> {
																	Spitter findByUsername(String username);<----------CUSTOM METHOD
																}
																
																When creating the repository implementation, Spring Data will examine any methods in the repository interface, parse the method name, 
																and attempt to understand the method’s purpose in the context of the persisted object. In essence, Spring Data defines a sort of miniature 
																domain-specific language (DSL) where persistence details are expressed in repository method signatures.
																Spring Data knows that this method is intended to find Spitters, because you parameterized JpaRepository with Spitter. The method name, findByUsername,
																makes it clear that this method should find Spitters by matching their username property with the username passed in as a parameter to the method. 
																Moreover, because the signature defines the method as returning a single Spitter and not a collection, it knows that it should look 
																for only one Spitter whose username matches.
																Repository methods are composed of a verb, an optional subject, the word By, and a predicate. In the case of findByUsername(), the verb is 
																find and the predicate is Username; the subject isn't specified and is implied to be a Spitter.
																Spring Data allows for four verbs in the method name: get, read, find, and count. The get, read, and find verbs are synonymous; all three 
																result in repository methods that query for data and return objects. The count verb, on the other hand, returns a count
																of matching objects, rather than the objects themselves.
																The predicate is the most interesting part of the method name. It specifies the properties that will constrain the result set.
																
																Declaring custom queries
																
																@Query("select s from Spitter s where s.email like '%gmail.com'")
																List<Spitter> findAllGmailSpitters();
																
																
																When Spring Data JPA generates the implementation for a repository interface, it also looks for a class whose name is the same as the interface’s 
																name postfixed with Impl. If the class exists, Spring Data JPA merges its methods with those generated by Spring Data JPA.
																For the SpitterRepository interface, the class it looks for is named SpitterRepositoryImpl.
																
																public class SpitterRepositoryImpl implements SpitterSweeper {
																		@PersistenceContext
																		private EntityManager em;
																		
																		public int eliteSweep() {
																		String update = "UPDATE Spitter spitter " +
																			"SET spitter.status = 'Elite' " +
																			"WHERE spitter.status = 'Newbie' " +
																			"AND spitter.id IN (" +
																			"SELECT s FROM Spitter s WHERE (" +
																			" SELECT COUNT(spittles) FROM s.spittles spittles) > 10000" +
																			")";
																			return em.createQuery(update).executeUpdate();
																		}
																}		
																		
																
																
																
																
									GENERICS
										 generics enable types (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar formal parameters used in 
										 method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, 
										 while the inputs to type parameters are types.
										 
											public class Box {
												private Object object;

												public void set(Object object) { this.object = object; }
												public Object get() { return object; }
											}
											
											/**
											 * Generic version of the Box class.
											 * @param <T> the type of the value being boxed
											 */
											public class Box<T> {
												// T stands for "Type"
												private T t;

												public void set(T t) { this.t = t; }
												public T get() { return t; }
											}
											
											Raw Types
											
											To create a parameterized type of Box<T>, you supply an actual type argument for the formal type parameter T:

											Box<Integer> intBox = new Box<>();
											If the actual type argument is omitted, you create a raw type of Box<T>:

											Box rawBox = new Box();
											
											
											Generic Methods

											Generic methods are methods that introduce their own type parameters. This is similar to declaring a generic type, but the type parameter's scope is 
											limited to the method where it is declared. Static and non-static generic methods are allowed, as well as generic class constructors.
											The syntax for a generic method includes a type parameter, inside angle brackets, and appears before the method's return type. 
											For static generic methods, the type parameter section must appear before the method's return type.
											
											public class Util {
											
												public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2) {
													return p1.getKey().equals(p2.getKey()) && p1.getValue().equals(p2.getValue());
												}
												
											}
											
											boolean same = Util.<Integer, String>compare(p1, p2);
											
											The type has been explicitly provided, as shown in bold. Generally, this can be left out and the compiler will infer the type that is needed:

											Pair<Integer, String> p1 = new Pair<>(1, "apple");
											Pair<Integer, String> p2 = new Pair<>(2, "pear");
											boolean same = Util.compare(p1, p2);   --------------------> TYPE INFERENCE
											
											Bounded Type Parameters

											There may be times when you want to restrict the types that can be used as type arguments in a parameterized type. For example, a method that operates 
											on numbers might only want to accept instances of Number or its subclasses.
											
												public class Box<T> {

													private T t;          

													public void set(T t) {
														this.t = t;
													}

													public T get() {
														return t;
													}

													public <U extends Number> void inspect(U u){<-------GENERIC METHOD(Type parameters only matters to the method!!!)
														System.out.println("T: " + t.getClass().getName());
														System.out.println("U: " + u.getClass().getName());
													}

													public static void main(String[] args) {
														Box<Integer> integerBox = new Box<Integer>();
														integerBox.set(new Integer(10));
														integerBox.inspect("some text"); // error: this is still String!
													}
												}
											
																	
																		
																	
							NOSQL DATABASES
							
								Spring Data MongoDB brings MongoDB to Spring applications in three ways:
										Annotations for object-to-document mapping
										Template-based database access with MongoTemplate
										Automatic runtime repository generation
								
												Enable MongoDB
												
													MongoClient bean to be able to access the MongoDB database. 
													We'll also need a MongoTemplate bean to be able to perform template-based data access against the database.

													@Configuration
													@EnableMongoRepositories(basePackages="orders.db")
													public class MongoConfig {
													
														@Bean
														public MongoFactoryBean mongo() {
															MongoFactoryBean mongo = new MongoFactoryBean();
															mongo.setHost("localhost");
															return mongo;
														}
														@Bean
														public MongoOperations mongoTemplate(Mongo mongo) {
															return new MongoTemplate(mongo, "OrdersDB");
														}
													}
													
													
													Enabled Spring Data’s automatic JPA repository generation with the @EnableJpaRepositories annotation. Similarly, the @EnableMongoRepositories 
													annotation does the same thing for MongoDB.
													The first @Bean method uses MongoFactoryBean to declare a Mongo instance.
													This bean will bridge Spring Data MongoDB to the database itself (not unlike what a DataSource does when working with a relational database). 
													Although you could create an instance of Mongo directly with MongoClient, you’d be forced to deal with the UnknownHostException that’s thrown from MongoClient’s 
													constructor. It’s easier to use Spring Data MongoDB’s MongoFactoryBean here. As a factory bean, MongoFactoryBean will construct an instance of Mongo for you, 
													without you needing to worry much about UnknownHostException.
													The other @Bean method declares a MongoTemplate bean. It’s constructed giving it
													a reference to the Mongo instance created by the other bean method and the name of the database. In a moment, you’ll see how to use MongoTemplate to query the database.
													Even if you never use MongoTemplate directly, you’ll need this bean because the automatically generated repositories will use it under the covers.
													Rather than declare those beans directly, the configuration class could extend AbstractMongoConfiguration and override its getDatabaseName() and mongo() methods.
													
													@Configuration
													@EnableMongoRepositories("orders.db")
													public class MongoConfig extends AbstractMongoConfiguration {
														@Override
														protected String getDatabaseName() {
															return "OrdersDB";
														}
														
														@Override
														public Mongo mongo() throws Exception {
															return new MongoClient();
														}
													}
													
													
													When working with JPA, you had to map your Java entity types to relational tables and columns. The JPA specification provides for several annotations to 
													support object-to-relational mapping, and some JPA implementations, such as Hibernate, add their own mapping annotations as well.
													MongoDB, however, doesn’t come with its own object-to-document mapping annotations.
													Spring Data MongoDB seized the opportunity to fill that gap with a handful of
													annotations that you can use to map your Java types to MongoDB documents.
													We've already enabled Spring Data MongoDB repositories with @EnableMongoRepositories, so all that’s left is to create an interface that you can generate the
													repository implementation from. Instead of extending JpaRepository, however, we'll need to extend MongoRepository. The OrderRepository interface in the following
													listing extends MongoRepository to provide basic CRUD operations for Order documents.
													
													public interface OrderRepository extends MongoRepository<Order, String> {
													}
													
													As you’ll recall from our exploration of Spring Data JPA, any interface that extends Repository will have an implementation automatically generated at runtime.
													Spring Data JPA supports a method-naming convention that helps Spring Data to automatically generate implementations for the
													methods that follow that convention. As it turns out, the very same convention works with Spring Data MongoDB.
													
													@Query annotation can be used to specify a custom query for a repository method. @Query works equally well with MongoDB as it does with JPA. 
													The only material difference is that for MongoDB, @Query takes a JSON query string instead of a JPA query.
													
													We learned how to mix fully custom methods into an otherwise automatically generated repository. For JPA, that involved creating an intermediary
													interface that declares the custom method(s), an implementation class for those custo methods, and changing the automatic repository interface to 
													extend the intermediary interface. The steps are the same for a Spring Data MongoDB repository.
													
											Working with graph data in Neo4j

													Whereas document databases store data in coarse-grained documents, graph databases store data in several fine-grained nodes that are connected with each other
													through relationships. A node in a graph database typically represents a concept in the database, having properties that describe the state of the node. 
													Relationships connect two nodes and may carry properties of their own.
													At their simplest, graph databases are more general purpose than document databases, potentially being a schemaless alternative to relational databases. But because
													data is structured as a graph, it’s possible to traverse relationships to discover things about your data that would be difficult or even impossible with other 
													kinds of databases.
													Spring Data Neo4j offers many of the same capabilities as Spring Data JPA and Spring Data MongoDB, albeit targeting the Neo4j graph database.
													
													SPECIFYING CUSTOM QUERIES
														When the naming convention doesn’t meet your needs, you also have the option of annotating a method with @Query to specify your own query. we've seen @Query
														before. With Spring Data JPA, you used it to specify a JPA query for a repository method. With Spring Data MongoDB, you used it to specify a JSON-matching query.
														When using Spring Data Neo4j, however, you must specify a Cypher query:
														
															@Query("match (o:Order)-[:HAS_ITEMS]->(i:Item) " + "where i.product='Spring in Action' return o")
															List<Order> findSiAOrders();
															
														Here, the findSiAOrders() is annotated with @Query and given a Cypher query to find all Order nodes that are related to an Item whose product property is equal to
														"Spring in Action".
														
											Working with Key-Value data in REDIS


										CACHING DATA

												Spring doesn't implement a cache solution, it offers declarative support for caching that integrates with several popular caching implementations.
												Enable annotation-driven caching by adding @EnableCaching to one of your configuration classes :
												
												@Configuration
												@EnableCaching
												public class CachingConfig {
												
													@Bean
													public CacheManager cacheManager() {
														return new ConcurrentMapCacheManager();
													}
												}
												
												They create an aspect with pointcuts that trigger off of Spring’s caching annotations. Depending on the annotation used and the state of the cache, 
												that aspect will fetch a value from the cache, add a value to the cache, or remove a value from the cache.
												
												Annotating methods for caching
												
												@Cacheable("spittleCache")
												public Spittle findOne(long id) {
													try {
														return jdbcTemplate.queryForObject(SELECT_SPITTLE_BY_ID,new SpittleRowMapper(),id);
													} catch (EmptyResultDataAccessException e) {
														return null;
													}
												}
												When findOne() is called, the caching aspect intercepts the call and looks for a previously
												returned value in the cache named spittleCache. The cache key is the id
												parameter passed to the findOne() method.
												
												@CachePut(value="spittleCache", key="#result.id")
												Spittle save(Spittle spittle);
												
												We don’t want to cache any Spittle objects whose message property contains the text "NoCache".
												@Cacheable(value="spittleCache" unless="#result.message.contains('NoCache')")
												Spittle findOne(long id);
												
												@Cacheable(value="spittleCache" unless="#result.message.contains('NoCache')" condition="#id >= 10")
												Spittle findOne(long id);
												
												condition attribute does not use #result because the method was not yet executed and the condition attribute has the goal to prevent to store
												values on the cache!!!
												
												@CacheEvict("spittleCache")
												void remove(long spittleId);
												
										SECURING METHODS

												Spring Security provides three different kinds of security annotations:
														Spring Security’s own @Secured
														JSR-250’s @RolesAllowed
														Expression-driven annotations, with @PreAuthorize, @PostAuthorize,@PreFilter, and @PostFilter
														
														@Configuration
														@EnableGlobalMethodSecurity(securedEnabled=true)
														public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
														}
														
														In addition to being annotated with @EnableGlobalMethodSecurity, you’ll notice that the configuration class extends GlobalMethodSecurityConfiguration. Much
														like the WebSecurityConfigurerAdapter class that your web security configuration class extended in chapter 9, this class offers you the opportunity to configure 
														the finer points of method-level security.
														When securedEnabled is true, a pointcut is created such that the Spring Security aspects will wrap bean methods that are annotated with @Secured.
														
														@Secured({"ROLE_SPITTER", "ROLE_ADMIN"})
														public void addSpittle(Spittle spittle) {
														// ...
														}
														
														The @RolesAllowed annotation is equivalent to @Secured in almost every way. The only substantial difference is that @RolesAllowed is one of Java’s 
														standard annotations as defined in JSR-250.
														
												Using expressions for method-level security
												
													@Configuration
													public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
													}
													
													The key difference between @PreAuthorize and @PostAuthorize is in when their expressions are evaluated. @PreAuthorize is evaluated before the method executes
													and prevents method execution unless the expression evaluates to true. In contrast,@PostAuthorize waits until the method has returned before deciding whether or not
													to raise a security exception.
													
													@PreAuthorize("(hasRole('ROLE_SPITTER') and #spittle.text.length() <= 140)" + "or hasRole('ROLE_PREMIUM')")
													public void addSpittle(Spittle spittle) {
													// ...
													}
													
													Just like @PreAuthorize and @PostAuthorize, @PostFilter takes a SpEL expression as its value parameter. But instead of using that expression to restrict access to a
													method, @PostFilter evaluates that expression against each member of a collection being returned from the method, removing those members for whom the expression
													evaluates to false.
													
													@PreAuthorize("hasAnyRole({'ROLE_SPITTER', 'ROLE_ADMIN'})")
													@PostFilter( "hasRole('ROLE_ADMIN') || " + "filterObject.spitter.username == principal.name")
													public List<Spittle> getOffensiveSpittles() {
													...
													}
													
													In addition to postfiltering a method's return value, you also have the option of prefiltering the values passed into a method.
													
													@PreAuthorize("hasAnyRole({'ROLE_SPITTER', 'ROLE_ADMIN'})")
													@PreFilter( "hasRole('ROLE_ADMIN') || " + "targetObject.spitter.username == principal.name")
													public void deleteSpittles(List<Spittle> spittles) { ... }
													
													DEFINING A PERMISSION EVALUATOR FOR COMPLEX EXPRESSIONS
													
													@PreAuthorize("hasAnyRole({'ROLE_SPITTER', 'ROLE_ADMIN'})")
													@PreFilter("hasPermission(targetObject, 'delete')")
													public void deleteSpittles(List<Spittle> spittles) { ... }
													
													where did hasPermission() come from ?
													
														hasPermission() function is a Spring Security–provided extension to SpEL.
														
														public class SpittlePermissionEvaluator implements PermissionEvaluator {

															private static final GrantedAuthority ADMIN_AUTHORITY = new GrantedAuthorityImpl("ROLE_ADMIN");
															
															public boolean hasPermission(Authentication authentication, Object target, Object permission) {
																if (target instanceof Spittle) {
																	Spittle spittle = (Spittle) target;
																	String username = spittle.getSpitter().getUsername();
																	if ("delete".equals(permission)) {
																		return isAdmin(authentication) || username.equals(authentication.getName());
																	}
																}
															throw new UnsupportedOperationException("hasPermission not supported for object <" + target + "> and permission <" + permission + ">");
															}
															
															public boolean hasPermission(Authentication authentication,Serializable targetId, String targetType, Object permission) {
																throw new UnsupportedOperationException();
															}
															
															private boolean isAdmin(Authentication authentication) {
																return authentication.getAuthorities().contains(ADMIN_AUTHORITY);
															}
														}
														
														Once the permission evaluator is ready, you need to register it with Spring Security for it to back the hasPermission() operation in the 
														expression given to @PostFilter. To do that, you’ll need to replace the expression handler with one that’s configured to use your custom permission evaluator.
														
														overriding the createExpressionHandler method from GlobalMethodSecurityConfiguration:

														@Override
														protected MethodSecurityExpressionHandler createExpressionHandler() {
														DefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler();
														expressionHandler.setPermissionEvaluator(new SpittlePermissionEvaluator());
														return expressionHandler;
														}
														
								INTEGRATING SPRING

									Several remoting technologies are available to you as a Java developer, including these:
										Remote Method Invocation (RMI)
										Caucho’s Hessian and Burlap
										Spring’s own HTTP-based remoting
										Web services with JAX-RPC and JAX-WS
															
										Spring supports RPC via several remoting technologies.
										
										Remote Method Invocation(RMI)
														Accessing/exposing Java-based services when network constraints such as firewalls aren’t a factor.

										Hessian or Burlap 
														Accessing/exposing Java-based services over HTTP when network constraints are a factor. Hessian is a binary protocol, whereas Burlap is XML-based.
										HTTP invoker 
														Accessing/exposing Spring-based services when network constraints are a factor and you desire Java serialization over XML or proprietary serialization.
										JAX-RPC and JAX-WS 
														Accessing/exposing platform-neutral, SOAP-based web services
														
											Services can be configured into your application as Spring-managed beans. This is accomplished using a proxy factory bean that enables you to wire
											remote services into properties of your other beans as if they were local objects.


											RMI
												RMI—first introduced into the Java platform in JDK 1.1—gives Java programmers a powerful way to communicate between Java programs. Before RMI, the only remoting options 
												available to Java programmers were CORBA (which at the time required the purchase of a third-party object request broker [ORB]) and handwritten socket programming.
												Spring simplifies the RMI model by providing a proxy factory bean that enables you to wire RMI services into your Spring application as if
												they were local JavaBeans. Spring also provides a remote exporter that makes short work of converting your Spring-managed beans into RMI services.
												
												To create an RMI service, it involves the following steps:
													1 Write the service implementation class with methods that throw java.rmi.RemoteException.
													2 Create the service interface to extend java.rmi.Remote.
													3 Run the RMI compiler (rmic) to produce client stub and server skeleton classes.
													4 Start an RMI registry to host the services.
													5 Register the service in the RMI registry.
													
												RmiServiceExporter exports any Spring-managed bean as an RMI service.RmiServiceExporter works by wrapping the bean in an adapter class. The adapter class is 
												then bound to the RMI registry and proxies requests to the service class—SpitterServiceImpl.
												
												@Bean
												public RmiServiceExporter rmiExporter(SpitterService spitterService) {
													RmiServiceExporter rmiExporter = new RmiServiceExporter();
													rmiExporter.setService(spitterService);
													rmiExporter.setServiceName("SpitterService");
													rmiExporter.setServiceInterface(SpitterService.class);
													return rmiExporter;
												}
												
											Hessian and Burlap	
												
												Hessian, like RMI, uses binary messages to communicate between client and service.
												But unlike other binary remoting technologies (such as RMI), the binary message is portable to languages other than Java, including PHP, Python, C++, and C#.
												Burlap is an XML-based remoting technology, which automatically makes it portable to any language that can parse XML.
												Unlike other XML-based remoting technologies (such as SOAP and XML-RPC), Burlap’s message structure is as simple as possible and doesn’t require 
												an external definition language (such as WSDL or IDL).
												HessianServiceExporter performs the same function for a Hessian service as RmiServiceExporter does for an RMI service: it exposes the public methods of a POJO
												as methods of a Hessian service. How it pulls off this feat is different from how RmiServiceExporter exports POJOs as RMI services.
												HessianServiceExporter is a Spring MVC controller (more on that in a moment) that receives Hessian requests and translates them into method calls on the exported
												POJO.
												
												@Bean
												public HessianServiceExporter hessianExportedSpitterService(SpitterService service) {
													HessianServiceExporter exporter = new HessianServiceExporter();
													exporter.setService(service);
													exporter.setServiceInterface(SpitterService.class);
													return exporter;
												}
													
										
												Hessian is HTTP-based, HessianServiceExporter is implemented as a Spring MVC controller. This means that in order to use exported Hessian services.
												
													Configure a Spring DispatcherServlet in web.xml, and deploy your application as a web application.
													Configure a URL handler in your Spring configuration to dispatch Hessian service URLs to the appropriate Hessian service bean.
													
														In web.xml
															<servlet-mapping>
																<servlet-name>spitter</servlet-name>
																<url-pattern>*.service</url-pattern>
															</servlet-mapping>
														
														Java WebApplicationInitializer
															ServletRegistration.Dynamic dispatcher = container.addServlet("appServlet", new DispatcherServlet(dispatcherServletContext));
															dispatcher.setLoadOnStartup(1);
															dispatcher.addMapping("/");
															dispatcher.addMapping("*.service");
															
															
															DispatcherServlet by extending AbstractDispatcherServletInitializer or AbstractAnnotationConfigDispatcherServletInitializer
															
															@Override
															protected String[] getServletMappings() {
															return new String[] { "/", "*.service" };
															}
															
															@Bean
															public HandlerMapping hessianMapping() {
																SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
																Properties mappings = new Properties();
																mappings.setProperty("/spitter.service","hessianExportedSpitterService");
																mapping.setMappings(mappings);
																return mapping;
															}
															
												Spring's HttpInvoker
													The Spring team recognized a void between RMI services and HTTP-based services such as Hessian and Burlap. On the one side, RMI uses Java’s standard object serialization
													but is difficult to use across firewalls. On the other side, Hessian and Burlap work well across firewalls but use a proprietary object-serialization mechanism.
													Thus Spring’s HTTP invoker was born. The HTTP invoker is a new remoting model created as part of the Spring Framework to perform remoting across 
													HTTP (to make the firewalls happy) and using Java’s serialization (to make programmers happy).
													
													@Bean
													public HttpInvokerServiceExporter httpExportedSpitterService(SpitterService service) {
														HttpInvokerServiceExporter exporter = new HttpInvokerServiceExporter();
														exporter.setService(service);
														exporter.setServiceInterface(SpitterService.class);
														return exporter;
													}
													
													HttpInvokerServiceExporter works much like HessianServiceExporter and BurlapServiceExporter. It’s a Spring MVC controller that receives requests from a client through 
													DispatcherServlet and translates those requests into method calls on the service implementation POJO.
													
													Because HttpInvokerServiceExporter is a Spring MVC controller, you need to set up a URL handler to map an HTTP URL to the service.
													
													@Bean
													public HandlerMapping httpInvokerMapping() {
														SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
														Properties mappings = new Properties();
														mappings.setProperty("/spitter.service","httpExportedSpitterService");
														mapping.setMappings(mappings);
														return mapping;
													}
												
												Publishing and consuming web services
												
													You saw how to create RMI services using RmiServiceExporter, Hessian services using HessianServiceExporter, Burlap services using BurlapServiceExporter, and HTTP
													invoker services using HttpInvokerServiceExporter.
													Spring does provide a JAX-WS service exporter, SimpleJaxWsServiceExporter, but we should know that it may not be the best choice in all situations. 
													SimpleJaxWsServiceExporter requires that the JAX-WS runtime support publishing of endpoints to a specified address!!!
													If we'll be deploying to a JAX-WS runtime that doesn’t support publishing to a specified address, we'll have write your JAX-WS endpoints in a more conventional way.
													That means the lifecycle of the endpoints will be managed by the JAX-WS runtime and not by Spring.
													Just as with any other object in a sizable application, a JAX-WS endpoint will likely depend on other objects to do its work. That means JAX-WS endpoints could benefit
													from dependency injection. But if the endpoint’s lifecycle is managed by the JAX-WS runtime and not by Spring, it would seem to be impossible to wire Spring-managed
													beans into a JAX-WS–managed endpoint instance.
													The secret to wiring JAX-WS endpoints is to extend SpringBeanAutowiringSupport!!!
													By extending SpringBeanAutowiringSupport, you can annotate an endpoint’s properties with @Autowired, and its dependencies will be met.
													
														@WebService(serviceName="SpitterService")
														public class SpitterServiceEndpoint extends SpringBeanAutowiringSupport {
															@Autowired
															SpitterService spitterService;
															
															@WebMethod
															public void addSpittle(Spittle spittle) {
																spitterService.saveSpittle(spittle);
															}
															...
															
													Spring’s SimpleJaxWsServiceExporter works much like the other service exporters that you saw earlier in this chapter, in that it publishes Spring-managed beans as
													service endpoints in a JAX-WS runtime. Unlike those other service exporters, SimpleJaxWsServiceExporter doesn’t need to be given a reference to the bean 
													it’s supposed to export. Instead, it publishes all beans that are annotated with JAX-WS annotations as JAX-WS services.
													
													@Bean
													public SimpleJaxWsServiceExporter jaxWsExporter() {
														return new SimpleJaxWsServiceExporter();
													}
												
												Proxying JAX-WS services on the client side
												
													@Bean
													public JaxWsPortProxyFactoryBean spitterService() {
														JaxWsPortProxyFactoryBean proxy = new JaxWsPortProxyFactoryBean();
														proxy.setWsdlDocument("http://localhost:8080/services/SpitterService?wsdl");
														proxy.setServiceName("spitterService");
														proxy.setPortName("spitterServiceHttpPort");
														proxy.setServiceInterface(SpitterService.class);
														proxy.setNamespaceUri("http://spitter.com");
														return proxy;
													}
													
										REST

													A mistake that's often made when approaching REST is to think of it as "web services with URLs"—to think of REST as another remote procedure call (RPC) mechanism,
													like SOAP, but invoked through plain HTTP URLs and without SOAP’s hefty XML namespaces.
													On the contrary, REST has little to do with RPC. Whereas RPC is service oriented and focused on actions and verbs, REST is resource oriented, emphasizing the things
													and nouns that comprise an application.
													Resources in REST are identified and located with URLs. There are no strict rules regarding RESTful URL structure, but the URL should identify a resource, not bark a
													command to the server. Again, the focus is on things, not actions.
														There are actions in REST, and they're defined by HTTP methods.
														Resources can be represented in a variety of ways using Spring views and view resolvers, including View implementations for rendering model data as XML,
														JSON, Atom, and RSS. The representation best suited for the client can be chosen using ContentNegotiatingViewResolver.
														
														Spring offers two options to transform a resource's Java representation into the representation that's shipped to the client:
															Content negotiation
																A view is selected that can render the model into a representation to be served to the client.
															Message conversion
																A message converter transforms an object returned from the controller into a representation to be served to the client.
																
														When a controller's handler method finishes, a logical view name is usually returned. If the method doesn't directly return a logical view name 
														(if the method returns void, for example), the logical view name is derived from the request’s URL. DispatcherServlet then passes the view name to a 
														view resolver, asking it to help determine which view should render the results of the request.
														In a human-facing web application, the view chosen is almost always rendered as HTML; view resolution is a one-dimensional activity. 
														If the view name matches a view, then that's the view you go with.
														When it comes to resolving view names into views that can produce resource representations, there's an additional dimension to consider. Not only does the view need
														to match the view name, but the view also needs to be chosen to suit the client. If the client wants JSON data, then an HTML-rendering 
														view won't do—even if the view name matches.
														Spring's ContentNegotiatingViewResolver is a special view resolver that takes the content type that the client wants into consideration.
														
														@Bean
														public ViewResolver cnViewResolver() {
															return new ContentNegotiatingViewResolver();
														}
														
														Understanding how ContentNegotiatingViewResolver works involves getting to know the content-negotiation two-step:
															1 Determine the requested media type(s).
															2 Find the best view for the requested media type(s).
															
															The first step in the content-negotiation two-step is determining what kind of resource representation the client wants.
															Shouldn't the request’s Accept header give a clear indication of what representation should be sent to the client?
															Unfortunately, the Accept header can't always be deemed reliable. If the client in question is a web browser, there's no guarantee that what the client 
															wants is what the browser sends in the Accept header. Web browsers typically only accept human friendly content types (such as text/html), 
															and there's no way to specify a different content type. ContentNegotiatingViewResolver considers the Accept header and uses whatever media types it asks for,
															but only after it first looks at the URL’s file extension!!!
															
															The media-type selection process, as described so far, outlines the default strategy for determining the requested media types. 
															But you can change how it behaves by giving it a ContentNegotiationManager. A few of the things you can do via a ContentNegotiationManager
															
															There are three ways to configure a ContentNegotiationManager:
																Directly declare a bean whose type is ContentNegotiationManager.
																Create the bean indirectly via ContentNegotiationManagerFactoryBean.
															|	Override the configureContentNegotiation() method of WebMvcConfigurerAdapter.
															|
															|---->For Java configuration,the easiest way to get a ContentNegotiationManager is to extend WebMvcConfigurerAdapter and override 
																  configureContentNegotiation() method.
																  
																	@Override
																	public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
																		configurer.defaultContentType(MediaType.APPLICATION_JSON);
																	}
																	
																	Now that you have a ContentNegotiationManager bean, all you need to do is inject it into the contentNegotiationManager 
																	property of ContentNegotiatingViewResolver.
																	
																	@Bean
																	public ViewResolver cnViewResolver(ContentNegotiationManager cnm) {
																		ContentNegotiatingViewResolver cnvr = new ContentNegotiatingViewResolver();
																		cnvr.setContentNegotiationManager(cnm);
																		return cnvr;
																	}
																	
																	@Bean
																	public ViewResolver beanNameViewResolver() {
																		return new BeanNameViewResolver();
																	}

																	@Bean
																	public View spittles() {
																		return new MappingJackson2JsonView();
																	}
																	
																	Unlike Spring's other view resolvers, ContentNegotiatingViewResolver doesn’t resolve views on its own. Instead, it delegates to other view resolvers, 
																	asking them to resolve the view.
																	ContentNegotiatingViewResolver asks the other view resolvers to resolve the logical view name into a view. Every view that's resolved is added to a 
																	list of candidate views. With the candidate view list assembled, ContentNegotiatingViewResolver cycles through all the requested media types, 
																	trying to find a view from among the candidate views that produces a matching content type. The first match found is the one that's used to 
																	render the model.
																	If the logical view name is "spittles", then the configured BeanNameViewResolver resolves the View declared in the spittles() method.
																	That's because the bean name matches the logical view name.
																	
																	
																	The key benefit of using ContentNegotiatingViewResolver is that it layers REST resource representation on top of the Spring MVC with no change 
																	in controller code.
																	The same controller method that serves human-facing HTML content can also serve JSON or XML to a non-human client.
																	Content negotiation is a convenient option when there’s a great deal of overlap between your human and non-human interfaces.
																	
														Working with HTTP message converters

																When using message conversion, DispatcherServlet doesn’t bother with ferrying model data to a view. In fact, there is no model, and there is no view. 
																There is only data produced by the controller and a resource representation produced when a message converter transforms that data.
																Normally, when a handler method returns a Java object (anything other than String or an implementation of View), that object ends up in the model for 
																rendering in the view. But if you’re going to employ message conversion, you need to tell Spring to skip the normal model/view flow and use a message 
																converter instead.
																
																@RequestMapping(method=RequestMethod.GET,produces="application/json")
																public @ResponseBody List<Spittle> spittles(@RequestParam(value="max",defaultValue=MAX_LONG_AS_STRING) long max,
																@RequestParam(value="count", defaultValue="20") int count) {
																	return spittleRepository.findSpittles(max, count);
																}
																	
																	DispatcherServlet considers the request’s Accept header and looks for a message converter that can give the client the representation it wants.
																	This method will only handle requests whose Accept header includes application/json. Any other kind of request, even if it’s a GET
																	request whose URL matches the path specified, won’t be handled by this method.
																	
																	Just as @ResponseBody tells Spring to employ a message converter when sending data to a client, the @RequestBody tells Spring to find a message 
																	converter to convert a resource representation coming from a client into an object.
																	
																	@RequestMapping(method=RequestMethod.POST,consumes="application/json")
																	public @ResponseBody Spittle saveSpittle(@RequestBody Spittle spittle) {
																		return spittleRepository.save(spittle);
																	}
																	
																	
																	If we annotate our controller class with @RestController instead of @Controller, Spring applies message conversion to all handler methods in the 
																	controller. We don't need to annotate each method with @ResponseBody.
																	
															Communicating errors to the client

																Spring offers a few options for dealing with such scenarios:
																	Status codes can be specified with the @ResponseStatus annotation.
																	Controller methods can return a ResponseEntity that carries more metadata concerning the response.
																	An exception handler can deal with the error cases, leaving the handler methods to focus on the happy path.
																	
																		
																	@RequestMapping(value="/{id}", method=RequestMethod.GET)
																	public ResponseEntity<Spittle> spittleById(@PathVariable long id) {
																		Spittle spittle = spittleRepository.findOne(id);
																		HttpStatus status = spittle != null ? HttpStatus.OK : HttpStatus.NOT_FOUND;
																		return new ResponseEntity<Spittle>(spittle, status);
																	}
																	
																	@ExceptionHandler(SpittleNotFoundException.class)
																	public ResponseEntity<Error> spittleNotFound(SpittleNotFoundException e) {
																		long spittleId = e.getSpittleId();
																		Error error = new Error(4, "Spittle [" + spittleId + "] not found");
																		return new ResponseEntity<Error>(error, HttpStatus.NOT_FOUND);
																	}
																	
																	The @ExceptionHandler annotation can be applied to controller methods to handle specific exceptions. Here, it’s indicating that if a 
																	SpittleNotFoundException is thrown from any of the handler methods in the same controller, the spittleNotFound() method should be called to 
																	handle that exception.
																	
																	Now we can remove most of the error handling from the spittleById() method:
																	@RequestMapping(value="/{id}", method=RequestMethod.GET)
																	public ResponseEntity<Spittle> spittleById(@PathVariable long id) {
																		Spittle spittle = spittleRepository.findOne(id);
																		if (spittle == null) { throw new SpittleNotFoundException(id); }
																		return new ResponseEntity<Spittle>(spittle, HttpStatus.OK);
																	}
																	
																	@RequestMapping(method=RequestMethod.POST,consumes="application/json")
																	public ResponseEntity<Spittle> saveSpittle(@RequestBody Spittle spittle,UriComponentsBuilder ucb) {
																		Spittle spittle = spittleRepository.save(spittle);
																		HttpHeaders headers = new HttpHeaders();
																		URI locationUri = ucb.path("/spittles/").path(String.valueOf(spittle.getId())).build().toUri();
																		headers.setLocation(locationUri);
																		ResponseEntity<Spittle> responseEntity = new ResponseEntity<Spittle>(spittle, headers, HttpStatus.CREATED)
																		return responseEntity;
																	}
																	
															Exploring RestTemplate's operations

																public Profile fetchFacebookProfile(String id) {
																	RestTemplate rest = new RestTemplate();
																	return rest.getForObject("http://graph.facebook.com/{spitter}",Profile.class, id);
																}
																
																Alternatively
																
																public Spittle[] fetchFacebookProfile(String id) {
																	Map<String, String> urlVariables = new HashMap<String, String();
																	urlVariables.put("id", id);
																	RestTemplate rest = new RestTemplate();
																	return rest.getForObject("http://graph.facebook.com/{spitter}",Profile.class, urlVariables);
																}
																
													Messaging in Spring

															Two main actors in asynchronous messaging: message brokers and destinations.
															There are two common types of destinations: queues and topics.
															Each of these is associated with a specific messaging model: either point-to-point (for queues) or publish/subscribe (for topics).
															In the point-to-point model, each message has exactly one sender and one receiver although each message in a message queue is delivered to only one receiver, 
															this doesn't imply that only one receiver is pulling messages from the queue. It’s likely that several receivers are processing messages from the queue.
															
															In the publish/subscribe messaging model, messages are sent to a topic. As with queues, many receivers may be listening to a topic. But unlike with queues, 
															where a message is delivered to exactly one receiver, all subscribers to a topic receive a copy of the message.
															
															Synchronous communications limitations
															
																Waiting
																Coupled through service interface
																Coupled to the service location
																Coupled to the service availability
																
														Sending messages with JMS
															The Java Message Service (JMS) is a Java standard that defines a common API for working with message brokers. Before JMS, each message broker 
															had a proprietary API, making an application’s messaging code less portable between brokers. But with JMS, all compliant implementations can be worked with 
															via a common interface in much the same way that JDBC has given database operations a common interface.
															
															
															Creating message-driven POJOs
															
															IN EJB3 
																@MessageDriven(mappedName="jms/spittle.alert.queue")
																public class SpittleAlertHandler implements MessageListener {
																	@Resource
																	private MessageDrivenContext mdc;
																	public void onMessage(Message message) {
																	...
																	}
																}
																
															In Spring 
																public class SpittleAlertHandler {
																	public void handleSpittleAlert(Spittle spittle) {
																	// ... implementation goes here...
																	}
																}
																
																<bean id="spittleHandler" class="com.habuma.spittr.alerts.SpittleAlertHandler" />
																<jms:listener-container connection-factory="connectionFactory">
																	<jms:listener destination="spitter.alert.queue" ref="spittleHandler" method="handleSpittleAlert" />
																</jms:listener-container>
																
																Here you have a message listener that’s contained in a message-listener container. A message-listener container is a special bean that watches a JMS 
																destination, waiting for a message to arrive. Once a message arrives, the bean retrieves the message and passes it on to any message listeners that are 
																interested.
																
															Using message-based RPC
																How to make remote calls that use JMS as a transport?
																
																EXPORTING JMS-BASED SERVICES
																
																	Spring provides several options for exporting beans as remote services. You used RmiServiceExporter to export beans as RMI services,
																	HessianExporter and BurlapExporter for Hessian and Burlap services over HTTP, and HttpInvokerServiceExporter to create HTTP invoker services over HTTP.
																	JmsInvokerServiceExporter is much like those other service exporters.
																	If HttpInvokerServiceExporter exports services that communicate over HTTP, then JmsInvokerServiceExporter must export services that converse over JMS.
															
														Messaging with AMQP
															You may be wondering why you need another messaging specification. Isn’t JMS good enough? What does AMQP bring to the table that is missing from JMS?
															AMQP offers several advantages over JMS. First, AMQP defines a wire-level protocol for messaging, whereas JMS defines an API specification. JMS’s API
															specification ensures that all JMS implementations can be used through a common API but doesn’t mandate that messages sent by one JMS implementation 
															can be consumed by a different JMS implementation. AMQP’s wire-level protocol, on the other hand, specifies the format that messages will take when en route 
															between the producer and consumer. Consequently, AMQP is more interoperable than JMS—not only across different AMQP implementations, but also across 
															languages and platforms.Another significant advantage of AMQP over JMS is that AMQP has a much more flexible and transparent messaging model. 
															With JMS, there are only two messaging models to choose from: point-to-point and publish/subscribe. Both of those models are certainly possible with AMQP, 
															but AMQP enables you to route messages in a number of ways, and it does this by decoupling the message producer from the queue(s) in which the messages will 
															be placed.
															AMQP producers don’t publish directly to a queue. Instead, AMQP introduces a new level of indirection between the producer and any queues that will
															carry the message: the exchange.
															                                Binding
															PRODUCER ----------> EXCHANGE -----------> Queue-------------> Consumer
															
															Exchange isn't a pass-through mechanism to a queue. AMQP defines four different types of exchanges, each with a different
															routing algorithm that decides whether to place a message in a queue.AMQP defines four different types of exchanges, each with a different
															routing algorithm that decides whether to place a message in a queue.
															
															The four standard types of AMQP exchanges are as follows:
																Direct
																	A message will be routed to a queue if its routing key is a direct match for the routing key of the binding.
																Topic
																	A message will be routed to a queue if its routing key is a wildcard match for the routing key of the binding.
																Headers
																	A message will be routed to a queue if the headers and values in its table of arguments match those in the binding's table of arguments. A special
																	header named x-match can specify whether all values must match or if any can match.
																Fanout 
																    A message will be routed to all queues that are bound to the exchange, regardless of the routing key or headers/values in the table of arguments.
															
																
																<admin connection-factory="connectionFactory"/> 
																<queue id="spittleAlertQueue" name="spittle.alerts" />
		
															For simple messaging, this may be all you need. That's because there's a default direct exchange with no name, and all queues are bound to that exchange 
															with a routing key that's the same as the queue’s name. With this simple configuration, you could send messages to the no-name exchange and specify a routing 
															key of spittle.alert.queue to have messages routed to the queue. Essentially, this re-creates a JMSstyle point-to-point model.
															
															To have a message routed to multiple queues with no regard for the routing key, you can configure a fanout exchange and several queues like this:

															<admin connection-factory="connectionFactory" /> 
																<queue name="spittle.alert.queue.1" > 
																<queue name="spittle.alert.queue.2" > 
																<queue name="spittle.alert.queue.3" > 
																<fanoutexchange name="spittle.fanout">
																	<bindings> 
																		<binding queue="spittle.alert.queue.1" /> 
																		<binding queue="spittle.alert.queue.2" /> 
																		<binding queue="spittle.alert.queue.3" /> 
																	</bindings> 
																</fanoutexchange>
																
															Spring’s JMS support offers two ways to fetch a message from a queue: 
																synchronously via JmsTemplate and asynchronously with message-driven POJOs.	
																																	
												Messaging with WebSockets and Stomp
												
													In its simplest form, a WebSocket is just a communication channel between two applications.
													An application on one end of the WebSocket sends a message, and the other end handles that message. Because it's full-duplex, either end can send messages and
													either end can handle messages.
													
													To handle messages in Spring with low-level WebSocket support, you must write a class that implements WebSocketHandler:
													
														public interface WebSocketHandler {
															void afterConnectionEstablished(WebSocketSession session) throws Exception;
															void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception;
															void handleTransportError(WebSocketSession session, Throwable exception) throws Exception;
															void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception;
															boolean supportsPartialMessages();
														}

														Rather than implement WebSocketHandler directly, it's easier to extend AbstractWebSocketHandler, an abstract implementation of WebSocketHandler.
														
														public class MarcoHandler extends AbstractWebSocketHandler {
															private static final Logger logger = LoggerFactory.getLogger(MarcoHandler.class);
															protected void handleTextMessage( WebSocketSession session, TextMessage message) throws Exception {
																logger.info("Received message: " + message.getPayload());
																Thread.sleep(2000);
																session.sendMessage(new TextMessage("Polo!"));
															}
														}
														
													TextWebSocketHandler is a subclass of AbstractWebSocketHandler that refuses to handle binary messages. It overrides handleBinaryMessage() to close the WebSocket
													connection if a binary connection is received. In a similar way, Spring also offers BinaryWebSocketHandler, a subclass of AbstractWebSocketHandler that overrides
													handleTextMessage() to close the connection if a text message is received.
													
													@EnableWebSocket
													public class WebSocketConfig implements WebSocketConfigurer {
														@Override
														public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
															registry.addHandler(marcoHandler(), "/marco");
														}
														@Bean
														public MarcoHandler marcoHandler() {
															return new MarcoHandler();
														}
													}
													
												When WebSockets are not supported :

													WebSocket fallback is the specialty of SockJS.
													SockJS is a WebSocket emulator that mirrors the WebSocket API as closely as possible on the surface, but under the covers is clever enough to choose another 
													form of communication when WebSocket isn't available. SockJS will always favor WebSocket first, but if WebSocket isn't an option, it will determine the best available 
													option from the following:
													
														XHR streaming
														XDR streaming
														iFrame event source
														iFrame HTML file
														XHR polling
														XDR polling
														iFrame XHR polling
														JSONP polling
														
														@Override
														public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
															registry.addHandler(marcoHandler(), "/marco").withSockJS();
														}
														
												Working with STOMP messaging
													
													Working directly with WebSocket (or SockJS) is a lot like developing a web application using only TCP sockets. Without a higher-level wire protocol, it's up to you to
													define the semantics of the messages being sent between applications. And you'd need to be sure that both ends of the connection agreed on those semantics.
													Fortunately, you don’t have to work with raw WebSocket connections. Just as HTTP layers a request-response model on top of TCP sockets,
													STOMP layers a frame-based wire format to define messaging semantics on top of WebSocket.
													At a quick glance, STOMP message frames look very similar in structure to HTTP requests. Much like HTTP requests and responses, STOMP frames are comprised of a
													command, one or more headers, and a payload.
													
													SEND
													destination:/app/marco
													content-length:20
													
													{\"message\":\"Marco!\"}
													
													
													The destination header is probably the most interesting thing about the STOMP frame. It's a clue that STOMP is a messaging protocol, very much like JMS or AMQP.
													Messages are published to destinations that may, in fact, be backed by real message brokers. On the other end, message handlers can listen to those destinations to
													receive the messages sent.
													Spring's web messaging is built around a message broker, so there’s more to configure than just telling Spring that you'd like to handle messages.
													You must also configure a message broker and some basic destination details.
													
													@Configuration
													@EnableWebSocketMessageBroker
													public class WebSocketStompConfig extends AbstractWebSocketMessageBrokerConfigurer {
														@Override
														public void registerStompEndpoints(StompEndpointRegistry registry) {
															registry.addEndpoint("/marcopolo").withSockJS();
														}
														
														@Override
														public void configureMessageBroker(MessageBrokerRegistry registry) {
															registry.enableSimpleBroker("/queue", "/topic");
															registry.setApplicationDestinationPrefixes("/app");
														}
													}
													
													This configuration class is not only configuring WebSocket, but it's configuring broker-based STOMP messaging.
													When a message arrives, the destination prefix will determine how the message is handled. Application destinations are prefixed with /app and the
													broker destinations are prefixed with either /topic or /queue. A message headed for an application destination(/app) is routed directly to an 
													@MessageMapping-annotated controller method. Messages destined for the broker, including any messages resulting from values returned by @MessageMapping-annotated methods,
													are routed to the broker and are ultimately sent out to clients subscribed to those destinations.
													
													
								Managing Spring beans with JMX
									
									Spring's support for DI is a great way to configure bean properties in an application.
									But once the application has been deployed and is running, DI alone can't do much to help you change that configuration. Suppose you want to dig into a running
									application and change its configuration on the fly. That's where Java Management Extensions (JMX) comes in.
									JMX is a technology that enables you to instrument applications for management, monitoring, and configuration. Originally available as a separate extension
									to Java, JMX is now a standard part of the Java 5 distribution. The key component of an application that’s instrumented for management with
									JMX is the managed bean (MBean). An MBean is a JavaBean that exposes certain methods that define the management interface. The JMX specification defines four types of MBeans:
									
								

								Spring Boot
								
								
								Maven
									CONVENTION OVER CONFIGURATION !!!!
									Without customization, source code is assumed to be in ${basedir}/src/main/java and resources are assumed to be in ${basedir}/src/main/resources. Tests are assumed to be in
									${basedir}/src/test, and a project is assumed to produce a JAR file. Maven assumes that you want the compile byte code to ${basedir}/target/classes and
									then create a distributable JAR file in ${basedir}/target.
									Most of the action in Maven happens in plugin goals which take care of things like compiling source, packaging bytecode, publishing sites, and any other task which need to happen in a
									build. The Maven you download from Apache doesn't know much about packaging a WAR file or running JUnit tests; most of the intelligence of Maven is implemented in the plugins and 
									the plugins are retrieved from the Maven Repository.
									
									Dependency Management
										Because a project is defined a unique coordinate which consists of a group identifier, artifact identifier, and version, projects can 
										now use these coordinates to declare dependencies.
										
									Remote Repositories
										Related to dependency management, we can use the coordinates defined in the Maven Project Object Model (POM) to create repositories of Maven artifacts.

									Universal Reuse of Build Logic
										Plugins are coded to work with the Project Object Model (POM); they are not designed to operate upon specific files in known locations. Everything is
										abstracted into the Model, plugin configuration and customization happens in the model.	
										
									Tool Portability / Integration
										Tools like Eclipse, NetBeans, and IntelliJ now have a common place to find information about a project. Before the advent of Maven, every IDE had a
										different way to store what was essentially a custom Project Object Model (POM). Maven has standardized this description, and while each IDE continues
										to maintain custom project files, they can be easily generated from the model.

									Easy Searching and Filtering of Project Artifacts
										Tools like Nexus allow you to index and search the contents of a repository using the information stored in the POM.
										
									Installation details
										bin contains scripts that executes Maven
										boot contains JAR file that is responsible for creating the classloader in which Maven executes
										conf contains a global "settings.xml" that could be used to customize the behaviour of our Maven installation.
										USUALLY WE SHOULD AVOID CUSTOMIZING THE settings.xml in M2_HOME/conf , usually we customize settings.xml in ~/.m2/settings.xml!!!
										
										
									Once you start using Maven extensively, you'll notice that Maven has created some local user-specific configuration files and a local repository in your home
									directory. In ~/.m2 there will be:
											~/.m2/settings.xml
											A file containing user-specific configuration for authentication, repositories, and other information to customize the behavior of Maven.
											~/.m2/repository/
											This directory contains your local Maven repository. When you download a dependency from a remote Maven repository, Maven stores a copy of the
											dependency in your local repository.
											
										Help Plugin
											mvn help:describe -Dplugin=help -Dmojo=compile -Dfull
											
									Maven always execute against an effective POM,a combination of settings from this project's pom.xml,all parents POMs,a super POM defined within Maven,user defined 
									settings and active profiles.
									Maven plugin is a collection of one or more goals.
										pluginId:goalId
											Goals define parameters that can define sensible default values.
											
									The core of Maven has little to do with the specific tasks involved in your project’s build. By itself, Maven doesn’t know how to compile your code or even how to
									make a JAR file. It delegates all of this work to Maven plugins like the Compiler plugin and the Jar plugin, which are downloaded on an as-needed basis and
									periodically updated from the central Maven repository.
									Plugin goals can be attached to a lifecycle phase. As Maven moves through the phases in a lifecycle, it will execute the goals attached to each particular phase.
									Each phase may have zero or more goals bound to it.
										PHASES
											process-resources
											compile
											process-classes
											process-test-resources
											test-compile
											test
											prepare-package
											package
											
											
										Instead of executing a Maven lifecycle goal we could achieve the same results by specifying a sequence of plugins goals
											mvn resources:resources \
												compiler:compile \
												resources:testResources \
												compiler:testCompile \
												surefire:test \
												jar:jar \
												install:install
												
										Maven archetype is a Maven project templating toolkit
										An archetype is defined as an original pattern or model from which all other things of the same kind are made!!!
										https://maven.apache.org/guides/introduction/introduction-to-archetypes.html		
												
										We've highlighted the Maven coordinates for this project: the groupId, artifactId, version and packaging. These combined identifiers make up a
										project's coordinates.2Just like in any other coordinate system, a Maven coordinate is an address for a specific point in "space": from general to specific. Maven
										pinpoints a project via its coordinates when one project relates to another, either as a dependency, a plugin, or a parent project reference.
										We can't have a project with the same three groupId, artifactId, and version identifiers.
										Maven Space is a coordinate system of projects!!!
										What makes a Maven repository a Maven repository? The Maven repository is defined by structure, a repository is a collection of project artifacts stored in a
										structure and format which can be easily understood by Maven. In a Maven repository everything is stored in a directory structure that closely matches a project's Maven coordinates.
										You will see that an artifact with the coordinates org.apache.commons:commons-email:1.1 is available under the directory /org/apache/commons/commons-email/1.1/ in a file named
										commons-email-1.1.jar. The standard for a Maven repository is to store an artifact in the following directory relative to the root of the repository:
													/<groupId>/<artifactId>/<version>/<artifactId>-<version>.<packaging>
										Maven downloads artifacts and plugins from a remote repository to your local machine and stores these artifacts in your local Maven repository. Once Maven has
										downloaded an artifact from the remote Maven repository it never needs to download that artifact again as Maven will always look for the artifact in the local
										repository before looking else where.
										Support for transitive dependencies is one of Maven’s most powerful features!!!!
										
										Difference between "install" and "package" phases
											package -> just create the artifact and install it in the target directory
											install -> execute the "package" phase and install the artifact in the repository
											
										Difference between <plugins> and <pluginManagement>	
										
											pluginManagement is only a way to share the same configuration across all our project modules
											is an element that is seen along side plugins.However this only configures plugins that are actually referenced within the plugins element in the children.
											The children have the every right to override pluginManagement definitions.
											
										https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html

										Default lifecycle:
											validate
											initialize(set properties , create directories)
											generate-sources generate any source for inclusion in compilation
											process-sources filter any values on source code
											generate-resources
											process-resources
											compile
											process-classes post-process the generated files from compilation(byte code enhancement on Java classes)
											generate-test-sources
											process-test-sources
											generate-test-resources
											process-test-resources
											test-compile
											process-test-classes
											test
											prepare-package
											package
											pre-integration-test
											integration-test
											post-integration-test
											verify
											install
											deploy
											
											
											DEFAULT LIFECYCLE BINDINGS ejb ejb3 war jar rar
											process-resources -> resources:resources
											compile - > compiler:compile
											test    - > surefire:test
											...
											
											POM
												Super POM
													defines remote Maven repository
													can be overriden by custom settings.xml
													It disables SNAPSHOT artifacts on the central Maven repository.If we need to use a SNAPSHOT repository we need to customize repository settings in our
													POM of settings.xml
													The central Maven repository is the default plugin repository.
													Build element sets the defaults values for directories in the Maven standard directory layout
													Default versions are provided in the super POM.
											
											Snapshot versions
												Maven versions can contain a string literal to signify that a project is currently under active development. 
												If a version contains the string "SNAPSHOT" then Maven will expand this token to a date and time value converted to UTC when you install or release this component.
												If our project has a version of “1.0-SNAPSHOT” and you deploy this project's artifacts to a Maven repository, Maven would expand this version to
												"1.0-20080207-230803-1" if you were to deploy a release at 11:08 PM on February 7th, 2008 UTC.
												Why would you use this? SNAPSHOT versions are used for projects under active development. If your project depends on a software component that is under active
												development, you can depend on a SNAPSHOT release, and Maven will periodically attempt to download the latest snapshot from a repository when you
												run a build. Similarly, if the next release of your system is going to have a version "1.4", your project would have a version "1.4-SNAPSHOT" version until it was
												formally released.
												As a default setting, Maven will not check for SNAPSHOT releases on remote repositories, to depend on SNAPSHOT releases, users must explicitly enable the
												ability to download snapshots using a repository or pluginRepository element in the POM.
												
											Properties references
												${project.groupId}
												Maven provides three implicit variables which can be used to access environment variables, POM information, and Maven Settings:
													env
													project
													settings
													Arbitrary
														<properties>
															<foo>bar</foo>
														</properties>
														${bar}
														
												Scopes
													compile(default)
													provided
													test
													runtime
													system
												Dependency Version Ranges
													<version>[3.8,4.0)</version>
													
											Conflict Resolution
											
												There will be times when you need to exclude a transitive dependency, such as when you are depending on a project that depends on another project, but you
												would like to either exclude the dependency altogether or replace the transitive dependency with another dependency that provides the same functionality.
												
												<dependency>
													<groupId>org.sonatype.mavenbook</groupId>
													<artifactId>project-a</artifactId>
													<version>1.0</version>
													<exclusions>
														<exclusion>
														<groupId>org.sonatype.mavenbook</groupId>
														<artifactId>project-b</artifactId>
														</exclusion>
													</exclusions>
												</dependency>
												
											DependencyManagement
												You'll usually see the dependencyManagement element in a top-level parent POM for an organization or project. Using the dependencyManagement element in a pom.xml 
												allows you to reference a dependency in a child project without having to explicitly list the version. Maven will walk up the parent-child hierarchy until it finds a 
												project with a dependencyManagement element, it will then use the version specified in this dependencyManagement element.
												Dependency management in a top-level POM is different from just defining a dependency on a widely shared parent POM. For starters, all dependencies are
												inherited. If mysql-connector-java were listed as a dependency of the top-level parent project, every single project in the hierarchy would have a reference to this
												dependency. Instead of adding in unnecessary dependencies, using dependencyManagement allows you to consolidate and centralize the management
												of dependency versions without adding dependencies which are inherited by all children. In other words, the dependencyManagement element is equivalent to an
												environment variable which allows you to declare a dependency anywhere below a project without specifying a version number.
												
												Multi-module projects are projects which contain a list of modules to build. A multi-module project always has a packaging of pom, and rarely produces an
												artifact. A multi-module project exists only to group projects together in a build.

												THERE ARE THREE STANDARD LIFECYCLES IN MAVEN :
													CLEAN
													DEFAULT(BUILD)
													SITE
													
													Running mvn clean invokes the clean lifecycle that consists of three lifecycles phases
														pre-clean
														clean
														post-clean
														
															The Clean plugin's clean goal clean:clean is bound to the clean phase in the clean lifecycle.
															When we execute the clean:clean goal we do not do so by executing the goal directly with mvn clean:clean , we do so by executing the clean phase
															of the clean lifecycle.
															
															Process Resources
																The process-resources phase PROCESSES resources and copies them to the output directory.
																In addition to copying the resources to the output directory,Maven can also apply a filter to the resources that allows us to replace TOKENS
																WITHIN resources file!!!
																Just like variables are referenced in a POM using ${...} notation, you can reference variables in your project's resources using the same syntax.
																
																
								TOKENS (JWT) vs COOKIES
									https://auth0.com/blog/cookies-vs-tokens-definitive-guide/
									https://stormpath.com/blog/beginners-guide-jwts-in-java
									
								Software Enginner
									https://www.toptal.com/software/single-responsibility-principle
									
								REACT
								
									Javascript tools
										JSBin
										CodePen
										JSFiddle
									https://stormpath.com/blog/crud-application-react-spring-boot-user-authentication
									
									EVENT LOOP JAVASCRIPT
										https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop
									
									New ES6 features
										const
										let(lexical variable scoping)
											Create block scopes
										Template Strings
											IMPORTANT ---> Template literals are enclosed by the back-tick (` `)  (grave accent) character instead of double or single quotes!!!!
										Default Parameters
										Arrow Functions
									Transpiling 
										Is the process of convert ES6 code to ES5 code!!!
										We can transpile Javascript directly in the browser using the inline Babel transpiler.
										Include the browser.js and any scripts with type="babel/script" will be converted.
										This approach means that the browser does the transpiling at runtime.This is not a good idea for production because it will slow our application down a lot.
										
										Destructuring 
											http://untangled.io/in-depth-es6-destructuring-with-assembled-avengers/
										Object Literal Enhancement -> Opposite of Destructuring 
											http://www.benmvp.com/learning-es6-enhanced-object-literals/
										Spread Operator
										Promises(Asynch behaviour)
											https://developers.google.com/web/fundamentals/primers/promises
										Classes and inheritance -> JUST SUGAR SYNTAX!!!
										Modules
											https://medium.com/sungthecoder/javascript-module-module-loader-module-bundler-es6-module-confused-yet-6343510e7bde
											https://spring.io/understanding/javascript-modules
												Inline Scripts
													Lack of code reusability
													Lack of dependency resolution
													Pollution of global namespace
												Script tags
													Lack of dependency resolution
														Order of the files
													Pollution of global namespace
													
												Module Object and IIFE(Module Pattern)
													We expose only one object to the global scope.The single object contains all the methods and values we need in our application.
													Like the JQuery object "$" do.
													Lack of Dependency Resolution: 
														The order of the files are still important. myApp.js file must come before any other files. And main.js file must come after all other library files.
													Pollution of global namespace: 
														Number of global variable is now 1, but is not zero yet.
												CommonJS
													Is not a Javascript library.It is a standardization organization!!!
													It is like ECMA or W3C.ECMA defines the language specification for Javascript.
													W3C defines Javascript wen API,such as DOM and DOM events.
													The goal of CommonJS is to define common APIs for web server,desktop and command line applications.
													
													CommonJS also defines APIs for module.Since there is no HTML page and no <script> tag on server application,it makes sense to have some clear APIs for modules.
													
													The problem with CommonJs style module definition is that it is synchronous. 
													When you call 'var add=require('add');', the system will be on halt until the module is ready. 
													This mean this line of code will freeze the browser while all the modules are being loaded. 
													So this may not be the best way to define modules for browser side application.
													To transfer module syntax from server usage to browser usage, CommonJS proposed several module formats, "Module/Transfer". 
													One of the proposals, "Module/Transfer/C" later become Asynchronous Module Definition (AMD).
													
													define(['add', 'reduce'], function(add, reduce){
													  return function(){...};
													});
													
													This "define" function is defined on the require.js file !!!!
													The "define" function takes a list of dependencies and a callback function as arguments.The arguments for the callback function WILL BE THE SAME ORDER OF 
													DEPENDENCIES IN THE ARRAY!!!This is equivalent to importing modules and the CALLBACK FUNTION RETURNS A VALUE,WHICH IS THE VALUE WE EXPORT.
													
													REQUIREJS
														RequireJS is a JavaScript library and file loader which manages the dependencies between JavaScript files and in modular programming. 
														It also helps to improve the speed and quality of the code.
														WITH REQUIREJS WE CAN WRITE AMD STYLE MODULE!!!!
														
														In the html page we only use one <script> tag 
														<script data-main="main" src="require.js"/>
														-------------------------------------------------------------------------
														define(['sum'],function(sum){
															var values = [1,2,3,4];
															var answer = sum(values);
															document.getElementById("answer").innerHTML = answer;
														})
														------------------------------------------------------------------------- main.js
														-------------------------------------------------------------------------
														define(['add','reduce'],function(add,reduce){
															var sum = function(arr){
																return reduce(arr,add);
															}
															return sum;
														})
														-------------------------------------------------------------------------sum.js
														define([],function(){
															var add = function(a,b){
																return a + b;
															};
															return add;
														})
														-------------------------------------------------------------------------add.js
														
													The "data-main" attribute tells RequireJS to where is the starting point of our application.By default,it assumes that all files have .js extension.
													So it is ok to omit '.js' file extension.
													
													RequireJs and AMD solves all the problems we had before, however it creates other slightly less serious problems:
													
													AMD syntax is too verbose. Since everything is wrapped in "define" function, there are extra indentation for our code. 
													With a small files, it is not much problem, but for a large code base, it can be mentally taxing.
													List of dependencies in the array must match the list of arguments in the function. 
													If there are many dependencies, it can be hard to maintain the order of the dependencies. 
													If you have dozens of dependencies in your module, and later if you had to remove one in the middle, it can be difficult to find matching module and argument.
													With current browsers(HTTP 1.1), loading many small files can degrade the performance.
													
													Because of these reasons, some people want to use CommonJS syntax, instead. But CommonJS syntax is for server and synchronous, right? 
													Browserify is here to rescue you! With Browserify, you can use CommonJS module in browser application. Browserify is a module bundler. 
													Browserify traverse the dependency tree of your codes and bundle them up in a single file.
													Unlike RequireJS, Browserify is a command line tool. You will need NodeJS and NPM to install it.
													
												ES6 Module Syntax
													Browsers are not ready for this new syntax.
													There are tools available that allows us to use ES6 module syntax.
													1:WEBPACK
														Requires a little bit of bootstrapping and configuration, is a Javascript command line tool, need NodeJs and NPM.
													2:ROLLUP
													3:SYSTEMJS
													4:JSPM
													
									FUNCTIONAL PROGRAMMING WITH JAVASCRIPT
										Javascript supports functional programming because Javascript functions are first-class citizens.This means that functions can do the same things that variable can do.
										
										Core concepts
											Immutability
												Instead of changing the original data structures,we build changed copies of those data structures and use them instead.
											Pure Functions
												Returns a value that is computed based on its arguments.
												Pure functions take at least one argument and always return a value or another function.
												THEY DO NOT CAUSE SIDE EFFECTS,SET GLOBAL VARIABLES OR CHANGE ANYTHING ABOUT APPLICATION STATE.
												THEY TREAT ARGUMENTS AS IMMUTABLE DATA.
												
												const frederick = {
													name : "",
													canRead : true,
													canWrite : false
												}
												
												const selfEducated = person => (
													{
														...person,
														canRead : false,
														canWrite : false
													}
												)
												
												We can transform arrays with Array.map and Array.filter , we can combine Object.keys with Array.map to transform arrays into objects.
												To transform arrays into primitives and into another objects we will use reduce and reduceRight functions.
												MAP AND REDUCE ARE THE MAIN WEAPONS OF ANY FUNCTIONAL PROGRAMMER
												
											Recursion	
											Composition	
												Chaining is one of the composition techniques
												
												const both = date => appendAMPM(civilianHours(date));
												THIS SYNTAX IS HARD TO COMPREHEND AND THEREFORE TOUGH TO MAINTAIN OR SCALE.
												
												const both = compose(
													civilianHours,
													appendAMPM
												)
												
												both(new Date());
												
												const compose = (...fns) =>
													(arg) =>
														fns.reduce((composed,f)=>f(composed),arg)
														
										REACT
											React is a library that is designed to update the browser DOM for us.
											With react we do not interact with the DOM Api directly.Instead,we interact with a  virtual DOM.
											The virtual DOM is made up of React elements,which conceptually seem similar to HTML elements,but are actually Javascript objects.
											IT IS MUCH FASTER TO WORK DIRECTLY WITH JAVASCRIPT OBJECTS THAN IT IS TO WORK WITH THE DOM API!!!!
											
											React elements
												React.createElement("h1",null,"Baked Salmon")
													rendering -> <h1>Baked Salmon</h1>
													
												With properties
													React.createElement("h1",{id : "recipe-0",'data-type' : "title"},"Baked Salmon");
													<h1 data-reactroot id="recipe-0" data-type="title">Baked Salmon</h1>
													
													data-reactroot will always appear as an attribute of the root element of our React component.Prior to version 15,React IDs were added to each node
													that was part of our component.This helped with rendering and keeping track of which elements needed to be updated.
													So a React element is just a Javascript literal that tells React how to construct the DOM element.
													
													{
													  $$typeof : Symbol(React.element),
													  "type" : "h1",
													  "key"  : null,
													  "ref"  : null,
													  "props" : {"children" : "Baked Salmon"},
													  "_owner" : null,
													  "_store" : {}
													}
													
													ReactDOM contains the tools necessary to render React elements in the browser.
														var dish = React.createElement("h1",null,"Baked Salmon");
														ReactDOM.render(dish,document.getElemntById('react-container'))
														
														<body>
															<div id="react-container">
																<h1>Baked Salmon</h1>
															</div>
														</body>
														
													<ul>
														<li>1 lb Salmon</li>
														<li>1 cup Pine Nuts</li>
														<li>2 cups Butter Lettuce</li>
													</ul>
													
													React.createElement(
														"ul",
														null,
														React.createElement("li",null,"1 lb Salmon"),
														React.createElement("li",null,"1 cup Pine Nuts"),
														React.createElement("li",null,"2 cups Butter Lettuce")
													);
													
													{
														type:"ul",
														"props":{
															"children":[
																{type:"li",props:{"children":"1 lb Salmon"}},
																{type:"li",props:{"children":"1 cup Pine Nuts"}},
																{type:"li",props:{"children":"2 cups Butter Lettuce"}}
															]
														}
													}
													
													className
														ANY ELEMENT THAT HAS AN HTML CLASS ATTRIBUTE IS USING CLASSNAME FOR THAT PROPERTY INSTEAD OF CLASS!!!
														SINCE CLASS IS A RESERVED WORD IN JAVASCRIPT,WE HAVE TO USE CLASSNAME TO DEFINE THE CLASS ATTRIBUTE OF AN HTML ELEMENT.
														
												React Components
													Components allows us to reuse the same DOM structure for different sets of data.
													
													Create components
													
														When react was introduced in 2013,there was only one way to create a component:the createClass function.
														In the future this function could be deprecated.
														
														The following example is very important :
														
															 const ingredientsList = React.createClass({displayname : "IngredientsList",
																									   render(){
																										return React.createElement("ul",{className : "ingredients"},
																										this.props.items.map((ingredient,i)=> React.createElement("li",{key:i},ingredient))
																										)
																									   }
																									})
														   
														   The render function will be called on an object context , so we gonna use the THIS keyword.
														   
														   const items = ["First","Second","Third","Fourth"];
														   
														   ReactDOM.render(
															React.createElement(ingredientsList,{items},null),
															document.getElementById("react-container")
															);
															
															The object returned from "React.createElement(ingredientsList,{items},null)" has a prototype of the type ReactClassComponent
																{
																	$$typeof : Symbol(react.element),
																	type : function(props,context,updater)...
																			prototype -> ReactClassComponent
																	props:{Children:null,
																	       items : ["First","Second","Third","Fourth"]
																		   }		
																}
																
																We can only access the item property inside the render function because the 
																ingredientsList render function is called with the element in context.
																
																Example :
																	var first = {display : "displayTest",render(){console.log(this.props)}};
																	var second = function(obj1,props){
																		return {obj1: obj1 ,"props" : props};
																	}
																	 var third = second(first,"teste");
																	 third.obj1.render.apply(third); -> THIS WAY WE GET ACCESS TO THE "teste" value
																		IF WE JUST CALL ,  third.obj1.render() -> It will not have access to the "third" object!!!
																		
																		TREE
																			THIRD OBJECT
																				----------------------------------
																				|  OBJ1|render()   |      		  |
																				|      |           |              |
																				|      |___________|              |
																				|  PROPS                          |
																				|                                 |
																				|                                 |
																				|---------------------------------
																
																		In the image bellow we can see that the OBJ1 does not have access to the outer object!!!
																		Module pattern
																			var singleton = function(){
																				var privateVariable = 10;
																				
																				function privateFunction(){
																					return false;
																				}
																				
																				return {
																					publicProperty : true,
																					publicMethod : function(){
																						privateVariable++;
																						return privateFunction();
																					}
																				}
																			}();
																			
														THE COMPONENTS ARE OBJECTS , THEY CAN BE USED TO ENCAPSULATE CODE JUST LIKE CLASSES.
														When creating elements with components , we use the component class directly.(React.createElement(IngredientsList,{items},null))
														This is why IngredientsList is not surrounded in quotation marks,we are passing the class to createElement because it is a component.
														
													One of the key features in the ES6 spec is React.Component, an abstract class that we can use to build new React components.
													We can create custom components through inheritance by extending this class with ES6 syntax.
													
													class IngredientsList extends React.Component {
														renderListItem(ingredient,i){
															return React.createElement("li",{key : i},ingredient)
														}
														
														render(){
															return React.createElement("ul",{className : "ingredients"},
																	 this.props.items.map(this.renderListItem)
																)
														}
													}
													
													Stateless functional Components
														Stateless functional components are functions,not objects:therefore they do not have a "this" scope.
														Because they are simple,pure functions,we will use them as much as possible in our applications!!!!
														They take in properties and return DOM element.Stateless functional components are a good way to practice the 
														rules of functional programming.We should strive to make each Stateless Functional Component a pure function.
														They should take in props and return a DOM element without causing side effects
														
														const IngredientsList = (props) => 
															React.createElement("ul",{className : "ingredients"},
																props.items.map((ingredient,i)=> React.createElement("li",{key : i},ingredient)))
																
														Using destructuring
															const Ingredients = ({items}) = > ....
															
												FACTORIES
													Another way to create elements is to use FACTORIES.A factory is a special object that can be used to abstract aways the details of 
													instantiating objects.
														React.DOM.h1(null,"Baked Salmon");
														React.DOM.ul({"className":"ingredients"},
															React.DOM.li(null,"First"),
															React.DOM.li(null,"Second"),
															React.DOM.li(null,"Third"),
															React.DOM.li(null,"Fourth"));
															
															SEPARATE THE INGREDIENT DATA:
																var items = ["first","second","third","fourth"];
																var list = React.DOM.ul({className : "ingredients"},items.map((ingredient,key)=>React.DOM.li({key},ingredient))
																
													Using factories with components :
													
															const {render} = ReactDOM;
														const IngredientsList = ({list}) => React.createElement("ul",null,
															list.map((ingredient,i)=>React.createElement("li",{key:i},ingredient)))
															
															const Ingredients = React.createFactory(IngredientsList);
															
															const list = ["First","Second","Third","Fourth"];
															render(Ingredients({list}),document.getElementById('react-container'));
															
												REACT WITH JSX
													<ul>
														<li>First</li>
														<li>Second</li>
														<li>Third</li>
														<li>Fourth</li>
													</ul>
													
													JSX works with components as well!!!
														Define the component using the class name:
															React.createElement(IngredientsList,{list:[...]});
															<IngredientsList list={[...]}/>
																When we pass the array of ingredients to this components,we need to surround it with curly braces.This is called a Javascript expression.
																NESTED COMPONENTS
																<IngredientsList>
																	<Ingredient/>
																	<Ingredient/>
																	<Ingredient/>
																</IngredientsList>
																
														Javascript expressions
															<h1>{this.props.title}</h1>
															
													Mapping Arrays to JAVASCRIPT
														<h1>
															{this.props.ingredients.map((ingredient,i)=> <li key={i}>{ingredient}</li>)}
														</h1>
														
											Babel
												Transpiling
													<!DOCTYPE html>
													<html>
														<head>
															<meta charset="utf-8">
															<title></title>
														</head>
														<body>
															<div class="react-container"></div>
															
															<script src="https://unpkg.com/react@15.4.2/dist/react.js"></script>
															<script src="https://unpkg.com/react-dom@15.4.2/dist/react-dom.js"></script>
															<script src="https://cdnjs.cloudfare.com/ajax/libs/babel-core/5.8.29/browser.js"></script>
															<script type="babel/text">
																//JSX code here or link to separate Javascript file that contains JSX
															</script>
															
														</body>
													</html>
													
													
											const data = [{
												"name" : "First",
												"ingredients" : [{"name" : , "amount":,"measurement"}],
												"steps" : ["",""]
											}]

											const Recipe = ({name,ingredients,steps}) =>
												<section id={name.toLowerCase().replace(/ /g,"-")}>
													<h1>{name}</h1>
													<ul className="ingredients">
														ingredients.map((ingredient,i)=>
															<li key={i}>{ingredient.name}</li>)
													</ul>
													<section className="instructions">
														<h2>Cooking Instructions</h2>
														{steps.map((step,i)=>
															<p key={i}>{step}</p>)}
													</section>
												</section>
												
											const Menu = ({title,recipes})=>	
											
											ReactDOM.render(
												<Menu recipes={data} title="Delicious Recipes" />
											)
											
												WEBPACK(module bundler,bundling CommonJS modules)
													A module bundler takes all of our different files(Javascript,LESS,CSS,JSX,ES6 and so on) and turns them into a single file.
													
													WebPack loaders
														A loader is a function that handles the transformation that we want to put our code through during the build process.
														If our application uses ES6,JSX,CoffeeScript and other languages that can not be read natively by the browser we will specify the necessary
														loaders in the webpack.config.js file to do the work of converting the code into syntax that can be read natively by the browser.
														
												
											Property Validation
												React.PropTypes.array
												...
												
												const Summary = createClass({
													displayName : "Summary",
													propTypes : {
														ingredients : PropTypes.array.isRequired,
														steps : PropTypes.array,
														title : PropTypes.string,
													},
													getDefaultProps(){
														return {
															ingredients : 0,
															steps : 0,
															title : "[recipe]"
														}
													},
													render() {
														const {ingredients,steps,title} = this.props
														return(
															<div className="summary">
																<h1>{title}</h1>
																<p>
																	<span>{ingredients.length} Ingredients </span>
																	<span>{steps.length} Steps</span>
																</p>
															</div>	
															)
													}
												})
											
											Custom Property Validation
												propTypes : {
													ingredients : PropTypes.number,
													steps : PropTypes.number,
													title : (props,propName) => (typeof props[propName] !== 'string' ? new Error("...") : (props[propName].lenght > 20) ?new Error("...") : null)
												}
												
											REFS
												class AddColorForm extends Component{
													constructor(props){
														super(props)
														this.submit = this.submit.bind(this)
													}
													submit(e){
														const{_title,_color} = this.refs
														e.preventDefault();
														alert("New Color : ${_title.value} ${_color.value}")
														_title.value = '';
														_color.value = '#000000';
														_title.focus()
													}
													render(){
														return(
															<form onSubmit={this.submit}>
																<input ref="_title" type="text" placeHolder="color title..." required />
																<input ref="_color" type="color" required />
																<button>ADD</button>
															</form>
														)
													}
												}
												
												With ES6 component classes , we must bind the scope of the component to any methods that need to access that scope with THIS.
												WHEN USING  REACT.CREATECLASS TO CREATE OUR COMPONENTS,THERE IS NO NEED TO BIND THE THIS SCOPE TO OUR COMPONENT METHODS.
												REACT.CREATECLASS AUTOMATICALLY BINDS THE THIS SCOPE FOR US!!!
												
												INVERSE DATA FLOW
												
													A common solution to collect data from a React Component is INVERSE DATA FLOW.It is similar to and sometimes described as ,TWO-WAY DATA BINDING.
													It involves sending a callback function to the component as a property that the component can use to pass data back as arguments.
													It is called inverse data flow because we send the component a function as a property,and the component sends data back as function arguments.
													
													const logColor = (title,color) = > console.log("New Color ${title} ${color}")
													
													<AddColorForm onNewColor={logColor} />
													
													submit(){
														const {title,color} = this.refs
														this.props.onNewColor(_title.value,_color.value)
														_title.value = ''
														...
													}
													
													Refs can also be used in stateless functional components.THESE COMPONENTS DO NOT HAVE THIS,SO IT IS NOT POSSIBLE TO USE THIS.REFS
													
													const AddColorForm = ({onNewColor=f=f}) =>{
														let _title,_color
														const submit = e => {
															e.preventDefault()
															onNewColor(_title.value,_color.value)
															_title.value = ''
															_color.value = '#0000'
															_title.focus()
															
														}
														return (
															<form submit={submit}>
																<input ref={input => _title = input} type="text" required />
																<input ref={input => _color = input} type="color" required />
																<button>ADD</button>
														)
													}
													
													In this stateless functional component,refs are set with a callback function instead of s string.The callback function passes the element's instance as an
													argument.
													
													React State Management
													
													WE CANNOT USE STATE IN A STATELESS FUNCTIONAL COMPONENT !!!!
													STATELESS FUNCTIONAL COMPONENTS ARE MEANT TO BE THE CHILDREN OF MORE COMPLEX,STATEFUL COMPONENTS.
													
													Thus far we have only used properties to handle data in React components.Properties are immutable.Once rendered,a component's properties do not change.
													(The example that i was thinking was related with the onClick  in the refs example, but in that case the UI is not being rendered again)
													REACT STATE IS A BUILT IN OPTION FOR MANAGING DATA THAT WILL CHANGE WITHIN A COMPONENT.
													
													
													!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! A REFRESH ON THE MATTER !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
													
														The most and central important element in the react is the ELEMENT!!!!
														
														
													{
													  $$typeof : Symbol(React.element),
													  "type" : "h1",
													  "key"  : null,
													  "ref"  : null,
													  "props" : {"children" : "Baked Salmon"},
													  "_owner" : null,
													  "_store" : {}
													}
													
													Like we see , the element contains two important properties that we already use them :
														PROPS 
															  In this property is stored all the children of this element and all the parameters that are passed to it
															  in the form of an object !!!!
														REF
															Property that contains all the properties that are referenced by callback functions!!!!
														
														Than we have the COMPONENTS
															Could be created through three methods
																1 : createClass
																	When using this createClass function to create our components,there is no need to bind the THIS scope to our component methods.
																	React.createClass automatically binds the THIS scope for us.
																2 : class keyword
																	we will need to add a constructor to this ES6 component class when we use another functions besides the RENDER!!!
																	We must bind the scope of the component to any methods that need to access that scope with THIS!!!
																3 : stateless
																
																Components allow us to use data to build a reusable UI.In the render function,we can use the THIS keyword to refer to the
																COMPONENT instance.
																DATA CAN BE PASSED TO REACT COMPONENTS AS PROPERTIES:
																	React.createElement(IngredientsList,{item},null)
																	
														Validating Props with createClass
															
															const Summary = createClass({
																displayName: "Summary",
																render() {
																	const {ingredients, steps, title} = this.props
																	return (
																		<div className="summary">
																			<h1>{title}</h1>
																			<p>
																				<span>{ingredients.length} Ingredients</span> |
																				<span>{steps.length} Steps</span>
																			</p>
																	   </div>
																	)
																}
															})
															
													JSX ->  <Summary title="Peanut Butter and Jelly"
															   ingredients="peanut butter, jelly, bread" 
															   steps="spread peanut butter and jelly between bread" />
															   
													ES5 -> createElement(Summary,{title : "",ingredients : "",steps :},null)
													
													{
														props : {children : [],
														         title : "",
																 ingredients : "",
																 steps ""}
													}
																
										State can be expressed in React components with a single Javascript object.When the state of a component chnages,the components renders a new UI that reflects those
										changes
											
											const StarRating = createClass({
												displayName: 'StarRating',
												propTypes: {
													totalStars: PropTypes.number
												}, 
												getDefaultProps() {
													return {
														totalStars: 5
													}
												},
												getInitialState() {
													return {
														starsSelected: 0
													}
												}, 
												change(starsSelected) {
													this.setState({starsSelected})
												},
												render() {
													const {totalStars} = this.props
													const {starsSelected} = this.state
													return (<div className="star-rating">
														{[...Array(totalStars)].map((n, i) => 
															<Star key={i}
																  selected={i<starsSelected}
																  onClick={() => this.change(i+1)}
															/>
														)}
												   <p>{starsSelected} of {totalStars} stars</p>
												</div>
											)
										  }
										})
										
											If we wish to initialize the Component , we must use the Component life cycle methods !!!
													Mounting
													These methods are called when an instance of a component is being created and inserted into the DOM:
														constructor()
														componentWillMount()
														render()
														componentDidMount()
													Updating
													An update can be caused by changes to props or state. These methods are called when a component is being re-rendered:
														componentWillReceiveProps()
														shouldComponentUpdate()
														componentWillUpdate()
														render()
														componentDidUpdate()
													Unmounting
													This method is called when a component is being removed from the DOM:
														componentWillUnmount()
													Error Handling
													This method is called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.
														componentDidCatch()
													Other APIs
													Each component also provides some other APIs:
														setState()
														forceUpdate()
													Class Properties
														defaultProps
														displayName
													Instance Properties
														props
														state	
											IN THE EXAMPLE ABOVE WE WILL ADD THIS METHOD
												componentWillMount() {
													const { starsSelected } = this.props
													if (starsSelected) {
													  this.setState({starsSelected})
													}
												}
												
												State within the Component Tree
													All our React components can have their own state, but should they ?
													In many React applications,it is possible to group all state data in the root component.
													State data can be passed down the component tree via properties and data can be passed back up the tree to the root via two-way function binding.
													Two-way function binding:
														Send a callback function to the component as a property that the component can use to pass data back as argument.
														It is also called inverse data flow because we send the component a function as a property,and the component sends data back as function arguments.
														
													AGAIN -> THE RENDER METHOD IS INVOKED AFTER EVERY SETSTATE CALL!!!
													
													The new StarRating component will be stateless so we will use a Stateless functional Components
													
													const StarRating = ({starsSelected=0, totalStars=5, onRate=f=>f}) =>
														<div className="star-rating">
															{[...Array(totalStars)].map((n, i) =>
																<Star key={i}
																	  selected={i<starsSelected}
																	  onClick={() => onRate(i+1)}/>
															)}
															<p>{starsSelected} of {totalStars} stars</p>
														</div>
														
													const Color = ({title,color,rating=0,onRemove=f=>f,onRate=f=>f}) =>
														<section className="color">
															<h1>{title}</h1>
															<button onClick={onRemove}>X</button>
															<div className="color"
																 style={{ backgroundColor: color }}>
															</div>
															<div>
																<StarRating starsSelected={rating} onRate={onRate} />
															</div>
														</section>	
														
													const ColorList = ({ colors=[], onRate=f=>f, onRemove=f=>f }) =>
																		<div className="color-list">
																			{(colors.length === 0) ?
																				<p>No Colors Listed. (Add a Color)</p> :
																				colors.map(color =>
																					<Color key={color.id}
																						   {...color}
																						   onRate={(rating) => onRate(color.id, rating)}
																						   onRemove={() => onRemove(color.id)} />
																				)
																			}
																		</div>	
														
													class App extends Component {

														constructor(props) {
															super(props)
															this.state = {
																colors: []
															}
															this.addColor = this.addColor.bind(this)
															this.rateColor = this.rateColor.bind(this)
															this.removeColor = this.removeColor.bind(this)
														}

														addColor(title, color) {
															const colors = [
																...this.state.colors,
																{
																	id: v4(),
																	title,
																	color,
																	rating: 0
																}
															]
															this.setState({colors})
														}

														rateColor(id, rating) {
															const colors = this.state.colors.map(color =>
																(color.id !== id) ?
																 color :
																	{
																		...color,
																		rating
																	}
															)
															this.setState({colors})
														}

														removeColor(id) {
															const colors = this.state.colors.filter(
																color => color.id !== id
															)
															this.setState({colors})
														}

														render() {
															const { addColor, rateColor, removeColor } = this
															const { colors } = this.state
															return (
																<div className="app">
																	<AddColorForm onNewColor={addColor} />
																	<ColorList colors={colors}
																			   onRate={rateColor}
																			   onRemove={removeColor} />
																</div>
															)
														}

													}
													
												Once setState is called, the UI is rerendered with the new state data. All data that changes in this app is managed from a single component, App!!!
												ONCE OUR APPLICATION REACHES A CERTAIN SIZE,TWO WAY DATA BINDING AND EXPLICIYLY PASSING PROPERTIES CAN BECOME QUITE NUISANCE!!!
												THE FLUX DESIGN PATTERN AND FLUX LIBRARIES LIKE REDUX CAN BE USED TO MANAGE STATE AND REDUCE BOILERPLATE CODE.
												
											COMPONENTS LIFE CYCLE
												The component lifecycle consists of methods that are invoked in series when a component is mounted or updated. 
												These methods are invoked either before or after the component renders the UI. In fact, the render method itself is a part of the component lifecycle. 
												There are two primary lifecycles: the mounting lifecycle and the updating lifecycle.
												The mounting lifecycle consists of methods that are invoked when a component is mounted or unmounted. In other words, 
												these methods allow you to initially set up state, make API calls, start and stop timers, manipulate the rendered DOM, 
												initialize third-party libraries, and more. These methods allow you to incorporate JavaScript to assist in the initialization and destruction of a component.
												The mounting lifecycle is slightly different depending upon whether you use ES6 class syntax or React.createClass to create components. When you use createClass, 
												getDefaultProps is invoked first to obtain the component’s properties. Next, getInitialState is invoked to initialize the state.
												ES6 classes do not have these methods. Instead, default props are obtained and sent to the constructor as an argument. The constructor is where the
												state is initialized. Both ES6 class constructors and getInitialState have access to the properties and, if required, can use them to help define the initial state.
												
												ES6 class	          React.createClass()
																		getDefaultProps()
												constructor(props)		getInitialState()
												componentWillMount()	componentWillMount()---> Invoked before the component is initially rendered and can be used to initialize third-party libraries,
												render()				render()                 start animations,request data.IT IS POSSIBLE TO INVOKE SETSTATE TO CHANGE THE COMPONENT STATE JUST BEFORE
												componentDidMount()		componentDidMount()      THE COMPONENT IS INITIALLY RENDERED.
												componentWillUnmount()	componentWillUnmount()
												
												
												const getFakeMembers = count => new Promise((resolves, rejects) => {
																	const api = `https://api.randomuser.me/?nat=US&results=${count}`
																	const request = new XMLHttpRequest()
																	request.open('GET', api)
																	request.onload = () => (request.status == 200) ? 
																		resolves(JSON.parse(request.response).results) : 
																		reject(Error(request.statusText))
																	request.onerror = err => rejects(err)
																	request.send()
																})
																We will use this promise in the componentWillMount method in a MemberList component. 
																This component will use a Member component to display each user’s picture, name, email address, and location:

														const Member = ({ email, picture, name, location }) =>
															<div className="member">
																<img src={picture.thumbnail} alt="" />
																<h1>{name.first} {name.last}</h1>
																<p><a href={"mailto:" + email}>{email}</a></p>
																<p>{location.city}, {location.state}</p>
															</div>

														class MemberList extends Component {

															constructor() {
																super()
																this.state = {
																	members: [],
																	loading: false,
																	error: null
																}
															}
															
															 componentWillMount() {
																this.setState({loading: true})
																getFakeMembers(this.props.count).then(
																	members => {
																		this.setState({members, loading: false})
																	},
																	error => {
																		this.setState({error, loading: false})
																	}
																)
															}
														  
															componentWillUpdate() {
																console.log('updating lifecycle')
															}

															render() {
																const { members, loading, error } = this.state
																return (
																	<div className="member-list">
																		{(loading) ? 
																			<span>Loading Members</span> :
																			(members.length) ? 
																				members.map((user, i) =>
																					<Member key={i} {...user} />
																				) : 
																				<span>0 members loaded...</span>
																		}
																		{(error) ? <p>Error Loading Members: error</p> : ""}
															  </div>
															)
															}
															}
															
												Calling setState before the component has rendered will not kick off the updating lifecycle. Calling setState after the component has been rendered will 
												kick off the updating lifecycle. If you call setState inside an asynchronous callback defined within the componentWillMount method, it will be invoked after 
												the component has rendered and will trigger the updating lifecycle.

												Updating lifecycle
													componentWillReceiveProps(nextProps)
														Only invoked if new properties have been passed to the component. This is the only method where setState can be called.
													shouldComponentUpdate(nextProps, nextState)
														The update lifecycle’s gatekeeper — a predicate that can call off the update. This method can be used to improve performance by only allowing necessary updates.
													componentWillUpdate(nextProps, nextState)
														Invoked just before the component updates. Similar to componentWillMount, only it is invoked before each update occurs.
													componentDidUpdate(prevProps, prevState)
														Invoked just after the update takes place, after the call to render. Similar to componentDidMount, but it is invoked after each update.
														
											COMPONENTS THAT ARE RERENDERED ARE NOT RE-MOUNTED,IF THEY ARE ALREADY THERE,AN UPDATE OCCURS INSTEAD.

													class HiddenMessage extends Component {

														constructor(props) {
															super(props)
															this.state = { 
																hidden: (props.hide) ? props.hide : true 
															} }

														render() {
															const { children } = this.props
															const { hidden } = this.state
															return (
																<p>
																	{(hidden) ? 
																		children.replace(/[a-zA-Z0-9]/g, "x") : 
																		children
																	}
																</p>
															)
														}

													}
													The problem occurs when the parent component changes the hide property. That change does not automatically cause the state of HiddenMessage to change.
													The componentWillReceiveProps lifecycle method was created for these scenarios. It will be invoked when the properties have been changed by the parent, 
													and those changed properties can be used to modify the state internally:
												
												 constructor(props) {
														super(props)
														this.state = { 
															hidden: (props.hide) ? props.hide : true 
														}
													}
												  
													componentWillReceiveProps(nextProps) {
														this.setState({hidden: nextProps.hide})
													}

													render() {
														const { children } = this.props
														const { hidden } = this.state
														return (
															<p>
																{(hidden) ? 
																	children.replace(/[a-zA-Z0-9]/g, "x") : 
																	children
																}
															</p>
														)
													}

												}
												
												React.Children
													React.Children provides a way of working with the children of a particular component. It allows you to count, map, loopover, or convert props.children to an array.
													In the functional stateless component , in this example , we pass the argument children 
													
														const Display = ({ ifTruthy=true, children }) => 
															(ifTruthy) ? Children.only(children) : null
															
														In this components the props are always passed , so through destruction we want access to the children property!!!
														
														WE CAN INTEGRATE JUST ABOUT ANY JAVASCRIPT LIBRARY WITH REACT.THE LIFECYCLE FUNCTIONS ARE THE PLACE WHERE OTHER JAVASCRIPT CAN PICK UP
														WHERE REACT LEAVES OFF.HOWEVER,WE SHOULD AVOID ADDING LIBRARIES THAT MANAGE THE UI:THAT IS REACT'S JOB!!!

												HIGH ORDER COMPONENTS
													SIMPLY A FUNCTION THAT TAKES REACT COMPONENTS AS AN ARGUMENT AND RETURNS ANOTHER REACT COMPONENT!!!
													
												MANAGING STATE OUTSIDE OF REACT
													One of the benefits of managing state outside of React is that it will reduce the need for many, if any, class components.
													You should only need to create a class when you need lifecycle functions, and even then you can isolate class functionality to HOCs and keep 
													components that only contain UI stateless. Stateless functional components are easier to understand and easier to test. They are pure functions, 
													so they fit into strictly functional applications quite nicely.
													Managing state outside of React simply means not using React state or setState in your applications.
													
												TWO WAY DATA BINDING AND MVS VS FLUX DESIGN PATTERN
													http://www.thesoftwaresimpleton.com/blog/2013/03/23/client-side-mvc/
													https://www.stackchief.com/blog/Flux%20vs%20MVC%3A%20Best%20Explanation
													https://medium.com/hacking-and-gonzo/flux-vs-mvc-design-patterns-57b28c0f71b7
													
													Arrow functions , a must read tutorial
														https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions
													Overview ES6
														https://www.sitepoint.com/es6-arrow-functions-new-fat-concise-syntax-javascript/
													
												VIEWS
												
													Let's begin by looking at the view, a React stateless component. Flux will manage our application state, so unless you need a lifecycle function you will not 
													need class components.
													
													Just receive parameters
														const Countdown = ({count, tick, reset}) => {
  
																	  if (count) {
																		setTimeout(() => tick(), 1000)
																	  }
																	  
																	  return (count) ? 
																		  <h1>{count}</h1> :
																		  <div onClick={() => reset(10)}>
																			  <span>CELEBRATE!!!</span> 
																			  <span>(click to start over)</span>
																		  </div>     
																	  
														}
												ACTIONS		
														
														const countdownActions = dispatcher =>
																	({
																		tick(currentCount) {
																			dispatcher.handleAction({ type: 'TICK' })
																		},
																		reset(count) {
																			dispatcher.handleAction({
																				type: 'RESET',
																				count
																			})  
																		}
																	})
																	
												DISPATCHER
													import Dispatcher from 'flux'

														class CountdownDispatcher extends Dispatcher {
														  
															handleAction(action) {
																console.log('dispatching action:', action)
																this.dispatch({
																	source: 'VIEW_ACTION',
																	action
																})
															}

														}
												STORES
													import { EventEmitter } from 'events'

														class CountdownStore extends EventEmitter {
														  
															constructor(count=5, dispatcher) {
																super()
																this._count = count
																this.dispatcherIndex = dispatcher.register(
																	this.dispatch.bind(this)
																)
															}
														  
															get count() {
																return this._count
															}
															
															dispatch(payload) {
																const { type, count } = payload.action
																switch(type) {
																
																	case "TICK":
																		this._count = this._count - 1
																		this.emit("TICK", this._count)
																		return true

																	case "RESET":
																		this._count = count
																		this.emit("RESET", this._count)
																		return true
																	}
														}  
													  
													}
											
													const appDispatcher = new CountdownDispatcher()
													const actions = countdownActions(appDispatcher)
													const store = new CountdownStore(10, appDispatcher)

													const render = count => ReactDOM.render(
														<Countdown count={count} {...actions} />,
														document.getElementById('react-container')
													)  

													store.on("TICK", () => render(store.count))
													store.on("RESET", () => render(store.count))
													render(store.count)
													
													Flow :
														Render The stateless component
														The stateless component has a reference to the action
														The action has a reference to the dispatcher
														The dispatcher has reference to the store
														The store emits an new action to rerender the stateless component
														
												REDUX
													We have mentioned that Redux is Flux-like, but it is not exactly Flux. It has actions, action creators, a store, and action objects that are used to change state. 
													Redux simplifies the concepts of Flux a bit by removing the dispatcher, and representing application state with a single immutable object. 
													Redux also introduces reducers, which are not a part of the Flux pattern. Reducers are pure functions that return a new state based on the current state 
													and an action: (state, action) => newState.
													
												We’ll look at a social media app that has state spread out across different components :
												
													APP
														state :
															user { name : "anonymous" }
															
															Messages - state :
																		  messages : [{
																						state
																						editing : false,
																						expanded : true},{...}}]
																						
															Posts - state :
																		  posts : [{
																						state
																						seen : false},{...}}]

													With Redux :
														REDUX STORE :
															state
																	{user : { name : "Marcus",
																			  isLoggedIn : true},
																	 messages : [{},{},{}],
																	 editMessages : 23,
																	 expandedMessages : [2,14,15,17],
																	 posts : [{},{},{}],
																	 postsSeen : [4]
																 }
																 
														APP :
															Messages
															Posts
															
													With Redux, we pull state management away from React entirely. Redux will manage the state.
													When building Redux apps, the first thing you need to think about is state. Try to define it in a single object. It is usually a good idea to draft a JSON sample 
													of your state tree with some placeholder data.

														{
															colors: [
																{
																	"id": "8658c1d0-9eda-4a90-95e1-8001e8eb6036",
																	"title": "Ocean Blue",
																	"color": "#0070ff",
																	"rating": 3,
																	"timestamp": "Sat Mar 12 2016 16:12:09 GMT-0800 (PST)"
																},
																{
																	"id": "f9005b4e-975e-433d-a646-79df172e1dbb",
																	"title": "Tomato",
																	"color": "#d10012",
																	"rating": 2,
																	"timestamp": "Fri Mar 11 2016 12:00:00 GMT-0800 (PST)"
																}, sort: "SORTED_BY_DATE"
														}
														
														ACTIONS
															Redux rule: application state should be stored in a single immutable object. Immutable means this state object doesn’t change. 
															We will eventually update this state object by replacing it entirely.
															Actions are the only way to update the state of a Redux application.
															Once you identify the actions, you can list them in a file called constants.js :
																const constants = {
																	SORT_COLORS: "SORT_COLORS",
																	ADD_COLOR: "ADD_COLOR",
																	RATE_COLOR: "RATE_COLOR",
																	REMOVE_COLOR: "REMOVE_COLOR"
																}
																
																Action are Javascript literals
																	{  
																	   type: "ADD_COLOR",
																	   color: "#FFFFFF",
																	   title: "Bright White",
																	   rating: 0,
																	   id: "b5685c39-3bdc-4727-9188-6c9a33df7f52",
																	   timestamp: "Sat Mar 12 2016 16:12:09 GMT-0800 (PST)"
																	}
														REDUCERS
															Reducers are functions that take the current state along with an action as arguments and use them to create and return a new state. 
															Reducers are designed to update specific parts of the state tree, either leaves or branches. 
															We can then compose reducers into one reducer that can handle updating the entire state of our app given any action.
																export const color = (state = {}, action) => {
																	switch (action.type) {
																		case C.ADD_COLOR:
																			return {
																				id: action.id,
																				title: action.title,
																				color: action.color,
																				timestamp: action.timestamp,
																				rating: 0
																			}
																		case C.RATE_COLOR:
																			return (state.id !== action.id) ?
																				state :
																				{
																					...state,
																					rating: action.rating
																				}
																		default :
																			return state
																	}
																}
																
																export const colors = (state = [], action) => {
																	switch (action.type) {
																		case C.ADD_COLOR :
																			return [
																				...state,
																				color({}, action)
																			]
																		case C.RATE_COLOR :
																			return state.map(
																				c => color(c, action)
																			)
																		case C.REMOVE_COLOR :
																			return state.filter(
																				c => c.id !== action.id
																			)
																		default:
																			return state
																	}
																}
																
														NO SIDE EFFECTS IN REDUCERS
															Reducers should be predictable. They are used to simply manage the state data. 
															In the previous example, notice that the timestamp and IDs are generated prior to sending the action to the reducer. 
															Generating random data, calling APIs, and other asynchronous processes should be handled outside of reducers. 
															Avoiding state mutations and side effects is always recommended.
															
																export const sort = (state = "SORTED_BY_DATE", action) => {
																	switch (action.type) {
																		case C.SORT_COLORS:
																			return action.sortBy
																		default :
																			return state
																	}
																}
																
														STORE
															In Redux, the store is what holds the application’s state data and handles all state updates.5 
															While the Flux design pattern allows for many stores that each focus on a specific set of data, Redux only has one store.
															The store handles state updates by passing the current state and action through a single reducer. 
															We will create this single reducer by combining and composing all of our reducers.
															Redux has a function for doing just that, combineReducers, which combines all of the reducers into a single reducer. These reducers are used to build your state tree.
															
															const store = createStore(
																combineReducers({ colors, sort }), 
																initialState
															)
															
															The only way to change the state of your application is by dispatching actions through the store. The store has a dispatch method 
															that is ready to take actions as an argument. When you dispatch an action through the store, the action is sent through the reducers and 
															the state is updated:
															
															store.dispatch({
															  type: "ADD_COLOR",
															  id: "2222e1p5-3abl-0p523-30e4-8001l8yf2222",
															  title: "Party Pink",
															  color: "#F142FF",
															  timestamp: "Thu Mar 10 2016 01:11:12 GMT-0800 (PST)"
															})
															
															Stores allow you to subscribe handler functions that are invoked every time the store completes dispatching an action. In the following example, 
															we will log the count of colors in the state
															Action creators are where we should put any logic for communicating with backend APIs. With an action creator, 
															we can perform asynchronous logic like requesting data or making an API call.
															
															Compose
																Redux also comes with a compose function that you can use to compose several functions into a single function.
																const print = compose(
																	list => console.log(list),
																	titles => titles.join(", "),
																	map => map(c=>c.title),
																	colors => colors.map.bind(colors),
																	state => state.colors
																)
															
														Middleware
															Redux also has middleware. It acts on the store’s dispatch pipeline. In Redux, middleware consists of a series of functions that are executed in a row in the process of dispatching 
															an action.
															These higher-order functions allow you to insert functionality before or after actions are dispatched and state is updated. Each middleware function is executed sequentially.
														  Applying Middleware to the Store
															
															import { createStore, 
																	 combineReducers, 
																	 applyMiddleware } from 'redux'
															import { colors, sort } from './reducers'
															import stateData from './initialState'

															const logger = store => next => action => {
																let result
																console.groupCollapsed("dispatching", action.type)
																console.log('prev state', store.getState())
																console.log('action', action)
																result = next(action)
																console.log('next state', store.getState())
																console.groupEnd()
															}
															
															const saver = store => next => action => {
																let result = next(action)
																localStorage['redux-store'] = JSON.stringify(store.getState())
																return result
															}

															const storeFactory = (initialState=stateData) =>
																applyMiddleware(logger, saver)(createStore)(
																	combineReducers({colors, sort}),
																	(localStorage['redux-store']) ?
																		JSON.parse(localStorage['redux-store']) :
																		stateData
																)

															export default storeFactory
															
														logger and saver are middleware functions, they are curried functions , functions that returns another function.
														
														NOW WE MUST GLUE THE REACT AND THE REDUX FRAMEWORKS!!!
														
														export default class App extends Component {

															constructor(props) {
																super(props)
																this.state = {
																	colors: [
																		{
																			"id": "8658c1d0-9eda-4a90-95e1-8001e8eb6036",
																			"title": "Ocean Blue",
																			"color": "#0070ff",
																			"rating": 3
																		}
																		 ]
																}
																this.addColor = this.addColor.bind(this)
																this.rateColor = this.rateColor.bind(this)
																this.removeColor = this.removeColor.bind(this)
															}
															
															 addColor(title, color) {
																...
															}

															rateColor(id, rating) {
																...
															}

															removeColor(id) {
																...
															}

															render() {
																const { addColor, rateColor, removeColor } = this
																const { colors } = this.state
															 return (
																	<div className="app">
																		<AddColorForm onNewColor={addColor} />
																		<ColorList colors={colors}
																				   onRate={rateColor}
																				   onRemove={removeColor} />
																	</div>
																)
															}

														}
									
											The App component is the component that holds state. State is passed down to child components as properties. Specifically, the colors are passed from the App component’s 
											state to the ColorList component as a property. When events occur, data is passed back up the component tree to the App component via callback function properties
											
											
											App    setState() ------------------------>  {state}
														 /\									\/
									   ColorList   onRate(index,rating)                  {props}
														 /\   								\/
									   Color       onRate(rating)                        {props}
														 /\									\/
									   StarRating  onRate(rating)                        {props}
													     /\
									   Start       onClick()                             
															
											The process of passing data all the way down and back up the tree introduces complexity that libraries like Redux are designed to alleviate. Instead of passing data
											up the tree through two-way function binding, we can dispatch actions directly from child components to update application state.
											
										Explicitly Passing the Store

											import React from 'react'
											import ReactDOM from 'react-dom'
											import App from './components/App'
											import storeFactory from './store'

											const store = storeFactory()

											const render = () =>
												ReactDOM.render(
													<App store={store}/>,
													document.getElementById('react-container')
												)

											store.subscribe(render)
											render()
											
											Every time the store changes, the render function will be invoked, which efficiently updates the UI with new state data.
											
											import AddColorForm from './AddColorForm'
											import SortMenu from './SortMenu'
											import ColorList from './ColorList'

											const App = ({ store }) =>
												<div className="app">
													<SortMenu store={store} />
													<AddColorForm store={store} />
													<ColorList store={store} />
												</div>

											export default App
											
											import { PropTypes, Component } from 'react'
											import { addColor } from '../actions'

											const AddColorForm = ({store}) => {

												let _title, _color
												 const submit = e => {

												e.preventDefault()
												store.dispatch( addColor(_title.value, _color.value) )
												_title.value = ''
												_color.value = '#000000'
												_title.focus()
											}

											return (
												<form className="add-color" onSubmit={submit}>
													<input ref={input => _title = input}
														   type="text"
														   placeholder="color title..." required/>
													<input ref={input => _color = input}
														   type="color" required/>
													<button>ADD</button>
												</form>
											)

										}

										AddColorForm.propTypes = {
											store: PropTypes.object
										}

										export default AddColorForm
										
										import { PropTypes } from 'react'
										import Color from './Color'
										import { rateColor, removeColor } from '../actions'
										import { sortFunction } from '../lib/array-helpers'

										const ColorList = ({ store }) => {
											const { colors, sort } = store.getState()
											const sortedColors = [...colors].sort(sortFunction(sort))
											return (
												<div className="color-list">
													{(colors.length === 0) ?
														<p>No Colors Listed. (Add a Color)</p> :
														sortedColors.map(color =>
															<Color key={color.id}
																{...color}
																onRate={(rating) =>
																	store.dispatch(
																		rateColor(color.id, rating)
																	)
																}
																onRemove={() =>
																	store.dispatch(
																		removeColor(color.id)
																	)
																} />
														)
													}
												</div>
											)
										}
										
										ColorList.propTypes = {
										store: PropTypes.object
									}

									export default ColorList
															
								Passing the Store via Context															
									Similarly, we can take advantage of a React feature called context that allows us to pass variables to components without having to explicitly pass them down through the tree
									as properties. 
									Any child component can access these context variables!!!!!So THEY MUST BE CHILDS !!!!
									
									If we were to pass the store using context in our color organizer app, the first step would be to refactor the App component to hold context. 
									The App component will also need to listen to the store so that it can trigger a UI update every time the state changes:
									
										import { PropTypes, Component } from 'react'
										import SortMenu from './SortMenu'
										import ColorList from './ColorList'
										import AddColorForm from './AddColorForm'
										import { sortFunction } from '../lib/array-helpers'

										class App extends Component {

											getChildContext() {
												return {
													store: this.props.store
												}
											}

											componentWillMount() {
												this.unsubscribe = store.subscribe( () => this.forceUpdate()
															)
														}

											componentWillUnmount() {
												this.unsubscribe()
											}

											render() {
													const { colors, sort } = store.getState()
													const sortedColors = [...colors].sort(sortFunction(sort))
													return (
														<div className="app">
															<SortMenu />
															<AddColorForm />
															<ColorList colors={sortedColors} />
														</div>
													)
												}

											}

											App.propTypes = {
												store: PropTypes.object.isRequired
											}

											App.childContextTypes = {
												store: PropTypes.object.isRequired
											}

											export default App
																
											At this point, any children of the App component will have access to the store via the context!!!!!
											
											const AddColorForm = (props, { store }) => {

												let _title, _color

												const submit = e => {
													e.preventDefault()
													store.dispatch(addColor(_title.value, _color.value))
													_title.value = ''
													_color.value = '#000000'
													_title.focus()
												}

												return (
													<form className="add-color" onSubmit={submit}>
														<input ref={input => _title = input}
															   type="text"
															   placeholder="color title..." required/>
														<input ref={input => _color = input}
														type="color" required/>
														<button>ADD</button>
													</form>
												)

											}

											AddColorForm.contextTypes = {
												store: PropTypes.object
											}
											
											The context object is passed to stateless functional components as the second argument, after props!!!
											
											import { PropTypes, Component } from 'react'
											import StarRating from './StarRating'
											import TimeAgo from './TimeAgo'
											import FaTrash from 'react-icons/lib/fa/trash-o'
											import { rateColor, removeColor } from '../actions'

											class Color extends Component {

												render() {
													const { id, title, color, rating, timestamp } = this.props
													const { store } = this.context
													return (
														<section className="color" style={this.style}>
															<h1 ref="title">{title}</h1>
															<button onClick={() =>
																store.dispatch( removeColor(id)
																)
															}>
																<FaTrash />
															</button>
															<div className="color"
																 style={{ backgroundColor: color }}>
															</div>
															<TimeAgo timestamp={timestamp} />
															<div>
																<StarRating starsSelected={rating}
																			onRate={rating =>
																				store.dispatch(
																					rateColor(id, rating)
																				)
																			} />
															</div>
														</section>
													)
												}

											}

											Color.contextTypes = {
												store: PropTypes.object
											}

											Color.propTypes = {
												id: PropTypes.string.isRequired,
												title: PropTypes.string.isRequired,
												color: PropTypes.string.isRequired,rating: PropTypes.number
											}

											Color.defaultProps = {
												rating: 0
											}

											export default Color
											
									Presentational Versus Container Components

											In the last example, the Color component retrieved the store via context and used it to dispatch RATE_COLOR and REMOVE_COLOR actions directly. 
											Before that, the ColorList component retrieved the store via context to read the current list of colors from state. In both examples, these 
											components rendered UI elements by interacting directly with the Redux store. We can improve the architecture of our application by decoupling 
											the store from components that render the UI.Presentational components are components that only render UI elements.4 They do not tightly couple with any data architecture. 
											Instead, they receive data as props and send data to their parent component via callback function properties. They are purely concerned with the UI and can be reused 
											across applications that contain different data. Every component that we created in Chapter 6, with the exception of the App component, is a presentational component.
											Container components are components that connect presentational components to the data. In our case, container components will retrieve the store via context 
											and manage any interactions with the store. They render presentational components by mapping properties to state and callback function properties to the store’s 
											dispatch method. Container components are not concerned with UI elements; they are used to connect presentational components to data.
														
														
													

													
										Web Workers
										Web Storage
											
											
											
				EXTJS
					Component Model
						Dictates how UI widgets are instantiated , rendered and destroyed in what's known as the component life cycle.
					Container Model
						Controls how widgets can manage(or contain) other child widgets.
						
							EXTJS Core
								Web Remoting
								Utilities
								Drag & Drop
								Ui components
								Data Services
								Draw & Charts
								
								
								CONTAINERS ARE WIDGETS THAT CAN MANAGE ONE OR MORE CHILD ITEMS.A CHILD ITEM IS GENERALLY ANY WIDGET OR COMPONENT THAT IS MANAGED BY A CONTAINER OR PARENT,THUS 
								THE PARENT CHILD PARADIGM.
								LAYOUTS ARE IMPLEMENTED BY A CONTAINER TO VISUALLY ORGANIZE THE CHILD ITEMS IN THE CONTAINER'S CONTENT BODY.
								FOR INSTANCE : PANEL AND WINDOW ARE TWO SUBCLASSES OF CONTAINERS.
								
								DATA BOUNDS VIEWS !!!
									Data services portion of the framework is responsible for the loading and parsing of the data.ExtJS has a lot of widgets that are bound to data stores.known as views.
									Many of the views that you’ll deploy include the data view, grid panel, and tree panel.
									Tree Panel is an exception in that it does not consume data from a data store.Instead,it consumes hierarchical data via the use of the TreeStore class!!!!
									
									New to ExtJs 4.0
										Ext JS 4.0 comes with an entirely new class system that includes features such as dependency injection and on-the-fly class loading.
										Along with dynamic class loading comes the concept of mixins, a modern objectoriented programming pattern that allows for multiple inheritance.
										
										Data package
											Association \  	 /Validation
														Model
													     |
											Reader---- Proxy--Writer
														 |
														Store
														/ |  \
												Sorter    |    Grouper
                                                          |
                                                       Filter	

													   
									Layouts are broken up into two main areas of functionality: component and container layouts.
									
									New CSS styling architecture
										ExtJs uses SASS
										
							INIT EXTJS 
								Ext.onReady
									Accepts three parameters: the method to invoke, the scope from which to call the method, and any options to pass to the method.
									All of your Ext JS–based JavaScript code can be anywhere below (after) the inclusion of the Ext JS script. This positioning is important because JavaScript files are requested
									and loaded synchronously. Trying to call any Ext JS methods before Ext JS is defined in the namespace will cause an exception.
									
									Managing DOM elements with Ext.Element
										The heart of Ext JS, known as the Ext.Element class, which is a robust, cross-browser, DOM element-management suite. You’ll learn to use Ext.Element to add
										nodes to and remove them from the DOM.
										The traditional method to reference a DOM node by ID is as follows:
											var myDiv = document.getElementById('someDivId');
											
											The Ext.Element class is a full DOM element-management suite, which includes a treasure chest of utilities, enabling the framework to work its magic on the DOM and
											provide the robust UI.
											
												Creating Child nodes
													
													myDiv1.createChild('Child from a string');
													myDiv1.createChild('<div>Element from a string</div>');
														Configuration Object
															
															myDiv1.createChild({
																tag : 'div',
																html : 'Child from a config object'
															});
															myDiv1.createChild({
																tag : 'div',
																id : 'nestedDiv',
																style : 'border: 1px dashed; padding: 5px;',
																children : {
																	tag : 'div',
																	html : '...a nested div',
																	34 CHAPTER 2 DOM manipulation
																	style : 'color: #EE0000; border: 1px solid'
																}
															});
											CSS selectors
												<div id='div1' class="myDiv">
													<div id='child1'>Child 1</div>
													<div class='child2'>Child 2</div>
													<div class='child3'>Child 3</div>
													<div id='child4'>Child 4 </div>
													<div>Child 5</div>
												</div>
											
												var myDiv1 = Ext.get('div1');
												var firstChild = myDiv1.down('div:first-child');
												firstChild.remove();
												
											Using Ajax with Ext.Element
												Ext.getBody().load({
													url : 'htmlFragment.html',
													scripts : true
												});
												
											Using templates and xtemplates
												The Ext.Template class is a powerful core utility that allows we to create an entire DOM hierarchy with slots that can be filled in later with data.
												
													var myTpl = Ext.create('Ext.Template' , "<div>Hello {0}.</div>");
													myTpl.append(document.body, ['Marjan']);
													myTpl.append(document.body, ['Michael']);
													myTpl.append(document.body, ['Sebastian']);
													
													var myTpl = Ext.create('Ext.Template', [
													'<div style="background-color: {color}; margin: 10px;">',
													'<b> Name :</b> {name}<br />',
													'<b> Age :</b> {age}<br />',
													'<b> DOB :</b> {dob}<br />',
													'</div>'
													]);
													myTpl.compile();
													myTpl.append(document.body,{
													color : "#E9E9FF",
													name : 'John Smith',
													age : 20,
													dob : '10/20/89'
													});
													myTpl.append(document.body,{
													color : "#FFE9E9",
													name : 'Naomi White',
													age : 25,
													dob : '03/17/84'
													});
													
											Looping with XTemplates	
												var myTpl = Ext.create('Ext.XTemplate', [
														'<tpl for=".">',
														'<div style="background-color: {color}; margin: 10px;">',
														'<b> Name :</b> {name}<br />',
														'<b> Age :</b> {age}<br />',
														'<b> DOB :</b> {dob}<br />',
														'<b> Cars : </b>',
														'<tpl for="cars">',
														'{.}',
														'<tpl if="this.isCamry(values)">',
														'<b> (same car)</b>',
														'</tpl>',
														'{[ (xindex < xcount) ? ", " : "" ]}',
														'</tpl>',
														'<br />',
														'</div>',
														'</tpl>',
														{
														isCamry : function(car) {
															return car === 'Camry';	
														}
														}
														]);
														
													myTpl.compile();
													myTpl.append(document.body, tplData);
													
													
									COMPONENT MODEL
										The Ext JS Component model is a centralized model that provides many of the essential component-related tasks, including a set of rules, known as the component life
										cycle, that dictate how the component instantiates, renders, and is destroyed.
										All UI widgets are subclasses of Ext.Component, which means that all of the widgets conform to the rules dictated by the model.
										http://docs.sencha.com/extjs/6.5.3/guides/core_concepts/components.html
										
										
										An Ext JS application's UI is made up of one or many widgets called Components. All Components are subclasses of the Ext.Component class which allows them to 
										participate in automated lifecycle management including instantiation, rendering, sizing and positioning, and destruction. Ext JS provides a wide range of useful 
										Components out of the box, and any Component can easily be extended to create a customized Component.
										A Container is a special type of Component that can contain other Components.
										Child Components are added to a Container using the Container's items configuration property.
										
											var childPanel1 = Ext.create('Ext.panel.Panel', {
												title: 'Child Panel 1',
												html: 'A Panel'
											});

											var childPanel2 = Ext.create('Ext.panel.Panel', {
												title: 'Child Panel 2',
												html: 'Another Panel'
											});

											Ext.create('Ext.container.Viewport', {
												items: [ childPanel1, childPanel2 ]
											});
											
										Containers use Layout Managers to size and position their child Components!!!	
										
										XTypes and ComponentManager
										
											Every Component has a symbolic name called an xtype. For example Ext.panel.Panel has an xtype of 'panel'. The above example showed how to add already instantiated 
											Components to a Container. In a large application, however, this is not ideal since not all of the Components need to be instantiated right away, 
											and some Components might never be instantiated depending on how the application is used. For example an application that uses a Tab Panel will only 
											need the contents of each tab to be rendered if and when each tab is clicked on by the user. This is where xtypes come in handy by allowing a Container's children to 
											be configured up front, but not instantiated until the Container determines it is necessary.
											
											Creating Custom Components
												When creating a new UI class, the decision must be made whether that class should own an instance of a Component, or to extend that Component.
												It is recommended to extend the nearest base class to the functionality required. This is because of the automated lifecycle management Ext JS provides which includes automated rendering when needed, 
												automatic sizing and positioning of Components when managed by an appropriate layout manager, and automated destruction on removal from a Container.
												It is easier to write a new class which is a Component and can take its place in the Component hierarchy rather than a new class which has an Ext JS Component, and then has 
												to render and manage it from outside.
												
												Subclassing

													The Class System makes it easy to extend any part of the Ext JS framework.
													Ext.Base is the building block of all Ext JS classes, and the prototype and static members of this class are inherited by all other classes.
													While we can certainly begin adding functionality at the lowest possible level via Ext.Base, in many cases developers want to start a bit higher in the 
													inheritance chain.

														The following example creates a subclass of Ext.Component:

															Ext.define('My.custom.Component', {
																extend: 'Ext.Component',

																newMethod : function() {
																   //...
																}
															});
															
															Template Methods
															
															https://dzone.com/articles/design-patterns-template-method

															Ext JS uses the Template method pattern to delegate to subclasses, behaviour which is specific only to that subclass.
															This means each class in the inheritance chain may "contribute" an extra piece of logic to certain phases in the Component's lifecycle. 
															Each class implements its own special behaviour while allowing the other classes in the inheritance chain to continue to contribute their own logic.
															
															
															Component ----------->render---|
																BoxComponent               |      onRender
																	Container              |      onRender
																		Panel              |      onRender
																		 MyPanelClass      |----->onRender--1 calls superclass
																		 
																		 
															Ext.define('My.custom.Component', {
																extend: 'Ext.Component',
																onRender: function() {
																	this.callParent(arguments); // call the superclass onRender method

																	// perform additional rendering tasks here.
																}
															});	

															Because JavaScript is a classless, prototype-oriented language, one of its most powerful features is flexibility. There are multiple solutions to any problem 
															using many different coding styles and techniques. However, this comes with the cost of being unpredictable. Without a unified structure, JavaScript code can 
															be difficult to understand, maintain, and re-use.
															Class-based programming, on the other hand, is still the most popular model of Object Oriented Programming. Class-based languages usually 
															requires strong-typing, encapsulation, and standard coding conventions. By making developers adhere to a large set of principles, code is more likely 
															to be predictable, extensible, and scalable over time. However, this model doesn't have JavaScript's dynamic capability.
															Each approach has pros and cons, but can we keep the good parts of both while hiding the bad parts? The answer is yes, and you can 
															find the solution with Ext JS.
															
															We may use a single method for class creation: Ext.define. Its basic syntax is as follows:

															Ext.define(className, members, onClassCreated);
																className: The class name
																members is an object that represents a collection of class members in key-value pairs
																onClassCreated is an optional function callback that is invoked when all dependencies of the defined class are ready and the class itself is 
																fully created. Due to the asynchronous nature of class creation, this callback can be useful in many situations.
																
																Ext.define('My.sample.Person', {
																	name: 'Unknown',

																	constructor: function(name) {
																		if (name) {
																			this.name = name;
																		}
																	},

																	eat: function(foodType) {
																		alert(this.name + " is eating: " + foodType);
																	}
																});

																var bob = Ext.create('My.sample.Person', 'Bob');

																bob.eat("Salad"); // alert("Bob is eating: Salad");
																
															Configuration

														There is also a dedicated config property that gets processed by the powerful Ext.Class pre-processors before the class is created. 
														Features include:

															Configurations are completely encapsulated from other class members
															Getter and setter methods for every config property are automatically generated into the class prototype during class creation if methods are not 
															already defined.
															The auto-generated setter method calls the apply method (if defined on the class) internally before setting the value. We may override 
															the apply method for a config property if we need to run custom logic before setting the value. If your apply method does not return a value, 
															the setter will not set the value. The update method (if defined) will also be called when a different value is set. 
															Both the apply and update methods are passed the new value and the old value as params.
															For Ext classes that use the configs, we don't need to call initConfig() manually. 
															However, for your own classes that extend Ext.Base, initConfig() still needs to be called.

																Ext.define('My.own.Window', {
																   extend: 'Ext.Component',
																   /** @readonly */
																   isWindow: true,

																   config: {
																	   title: 'Title Here',

																	   bottomBar: {
																		   height: 50,
																		   resizable: false
																	   }
																   },

																   applyTitle: function(title) {
																	   if (!Ext.isString(title) || title.length === 0) {
																		   alert('Error: Title must be a valid non-empty string');
																	   }
																	   else {
																		   return title;
																	   }
																   },

																   applyBottomBar: function(bottomBar) {
																	   if (bottomBar) {
																		   if (!this.bottomBar) {
																			   return Ext.create('My.own.WindowBottomBar', bottomBar);
																		   }
																		   else {
																			   this.bottomBar.setConfig(bottomBar);
																		   }
																	   }
																   }
																});

																/** A child component to complete the example. */
																Ext.define('My.own.WindowBottomBar', {
																   config: {
																	   height: undefined,
																	   resizable: true
																   }
																});
																
																Statics

																	Static members can be defined using the statics config

																	Ext.define('Computer', {
																		statics: {
																			instanceCount: 0,
																			factory: function(brand) {
																				// 'this' in static methods refer to the class itself
																				return new this({brand: brand});
																			}
																		},

																		config: {
																			brand: null
																		}
																	});
																	
																	
															XType again

																var myPanel = {
																	xtype : 'panel',
																	height : 100,
																	width : 100,
																	html : 'Hello!'
																};
																
															Here myPanel is an XType configuration object that would be used to configure an
															Ext.Panel widget. This works because just about every widget is registered to the
															Ext.ComponentManager class with a unique string key and a reference to that class,
															which is then referred to as an XType. In each UI class in the framework, you’ll find an
															alias declaration that is prefixed with 'widget.'—the Ext JS class system automatically
															registers the widget’s XType with ComponentManager because of the prefix.
															Here’s what it would look like to register an XType for a custom class:

																Ext.define('MyApp.CustomClass', {
																extend: 'Ext.panel.Panel',
																alias: 'widget.myCustomComponent'
																});
																
															Once registration is complete, we can specify your custom component as an XType:
															new Ext.Panel({
															...
															items : {
															xtype : 'myCustomComponent',
															...
															}
															});

															Component Rendering
																Direct and Lazy render models
																	Direct
																		var myPanel = Ext.create('Ext.panel.Panel',{
																			renderTo : document.body,
																			height : 50,
																			width : 150,
																			title : 'Panel rendered immediately',
																			frame : true
																		});
																		
															If we want to defer the rendering of the component, omit the renderTo and applyTo attributes and call the component’s 
															render method when we deem it necessary:	

																	var myPanel = Ext.create('Ext.panel.Panel',{
																	height : 50,
																	width : 150,
																	title : 'Lazy rendered Panel',
																	frame : true
																	});
																	// ... some business logic...
																	myPanel.render(document.body);

															We never specify applyTo or renderTo when the component is a child of another. Components that contain other components
															have a parent-child relationship, which is known as the Container model. If a component is a child of another component, it’s specified in 
															the items attribute of the configuration object, and its parent will manage the call to its render method when required. 
															This is known as lazy or deferred rendering.
															
														The component life cycle
															The class Ext.Component class provides a layer of abstraction from the underlying HTML.
															The Ext.Component class generates HTML for us :
																
																var simpleComponent = Ext.create('Ext.Component',{html : 'Ext JS Essentials',
																												  renderTo : Ext.getBody()});
																												  
																HTML Rendered :
																	<div class="x-component x-component-default x-border-box" id="ext-comp-1010">
																		Ext JS Essentials!
																	</div>
															
																This generated HTML is created and managed by Ext.dom.Element class,which wraps a DOM element and its children.
																	AFTER IT IS RENDERED,EACH EXT.COMPONENT INSTANCE HAS THE ELEMENT INSTANCE STORED IN ITS EL PROPERTY.
																	WE CAN THEN USE THIS PROPERTY TO MANIPULATE THE UNDERLYING HTML THAT REPRESENTS THE COMPONENT.
																	
																Initialization Phase
																	Configuration applied
																	Base Event Registration
																	Id assigned or auto generated
																	Pre Init Component plugs ins constructed
																	initComponent
																		This where a lot of work occurs for subclasses of Component, like registration of subclass-specific events,
																		references to data stores, and creation of child components. initComponent is used as a supplement to the constructor and 
																		is typically used as the main pointto extending Component or any subclass thereof.
																	Component Registered with Component Manager
																		Each component that’s instantiated is registered with the ComponentManager class with a unique Ext JS–generated string ID.
																	Base Mixin contructers are called 
																	Component reseize event initialized as state event
																	Plugs ins are initialize
																	Component Loader Class bootstrapped
																	Render Phase Begins
																Render Phase
																	beforerender event is fired
																	Components element is cached
																	Component is registered with floating
																	The Container is set
																		A component needs a place to live, and that place is known as its container.
																	onRender
																		This is a crucial step for subclasses of Component, where all of the DOM elements are inserted to get the component rendered and
																		painted onscreen. Each subclass is expected to call its superclass’s onRender first when extending Ext.Component or any subclass thereafter, 
																		which ensures that the Ext.Component base class can insert the core DOM elements needed to render a component.
																	visibilityMode is configured
																	overCls
																	renderEventIsfired
																	The component’s contents are initialized. 
																		If a component is configured with contentEl, html, and/or a combination of tpl (Template) and data properties,
																		it’ll render that content as children of its own element. AbstractComponent is modeled so that you can use one, two, or all three if you wish. 
																		html will get rendered first, contentEl second, tpl third, and data last.
																		afterRender is executed. afterRender is a crucial postrender method that’s
																		automatically called by the render method. This method is responsible for
																		configuring the size of the component, aligning and positioning the component,
																		and adding some styling to the HTML content. It’s also responsible for
																		initializing an instance of Resizable (if configured), setting the component’s
																		element to scroll (if configured via autoScroll), and making the component
																		draggable if it’s configured as such. Finally, if the component is configured
																		for Accessible Rich Internet Applications (ARIA) compliancy, the widget is initialized
																		as such. It’s important to note that all subclasses of Component that
																		have their own afterRender method are expected to call their superclass’s
																		afterRender method.
																	The afterrender event is fired.
																	The afterRenderEvents are hooked.
																	The component’s element is initialized for focus.
																	The component is hidden.
																	The component is disabled.
																Destruction Phase
																	As in real life, the death of a component is a crucial phase in its life. Destruction of a component performs critical tasks, such as 
																	removing itself and any children from the DOM tree, de-registration of the component from the ComponentManager class, and
																	de-registration of event listeners.
																	
																	1beforedestroy is fired. This, like many before<action> events, is a cancelable event, preventing the component’s destruction if its event handler 
																	returns false.
																	2 beforeDestroy is called. This method is first to be called within the component’s
																	destroy method and is the perfect opportunity to remove any noncomponent
																	items, such as toolbars or buttons. Any subclass of Component is expected to call
																	its superclass’s beforeDestroy method.
																	3 The component is de-registered from floating. If a component is floating, it’s de-registered
																	with FloatingManager.
																	4 The component is removed from the parent container. If a component is a child of a
																	parent container, it’s removed from its parent.
																	5 onDestroy is called. The onDestroy method is charged with quite a few tasks.
																	The first is the destruction of any configured drag-and-drop proxy, immediately
																	followed by the destruction of a Resizer if it’s configured. Next, if a focus
																	DelayedTask is registered, it’s removed from the component. If the component
																	is configured to monitor the browser’s resize event, the resize event handler is
																	removed. Finally, the ComponentLayout, the loadMask, and any floating child
																	items are destroyed if the component is configured with the same.
																	6 Registered plug-ins are destroyed. At this point in the destruction phase all registered
																	plug-ins are looped through, each with its destroy method being called.
																	7 Element and Element listeners are purged. If a component has been rendered, any
																	handlers registered to its Element are removed and the Element is removed
																	from the DOM.
																	8 The destroy event is fired. Any registered event handlers are triggered by this
																	event, which signals that the component is no longer in the DOM.
																	9 The component is unregistered from ComponentManager. The reference for this component
																	in the ComponentManager class is removed.
																	10 The state mixin is destroyed. Here the state mixin is called upon to be destroyed,
																	de-registering any state-specific component events.
																	11 The component’s event handlers are purged. All event handlers are de-registered
																	from the component.
															Containers
																	Container is a behind-the-curtains class that provides a foundation for components to manage their child items, and it’s often overlooked by developers.
																	This class provides a suite of utilities, which includes add, insert, and remove methods, along with some child query, bubble, and 
																	cascade utility methods. These methods are used by most of the subclasses, including Panel, Viewport, and Window. It’s also common to use these
																	methods in your application.

																Querying for components 
																	Ext JS 4.0 comes with a new ComponentQuery class that has a selector engine similar to that of the browser’s selector engine.
																	
																The viewport container
																	The Viewport class is the foundation on which all web applications that depend solely on Ext JS are built. It manages 100% of the browser’s—you guessed 
																	it—viewport, or display area.
																The panel 
																	Panel, a subclass of Container, is considered a workhorse of the framework because it’s what many developers use to present UI widgets.
																	Recall that Panel is also a subclass of Component, which means that it follows the component life cycle.
																	
															The Dock layout is exclusively used by the Panel class and is responsible for rendering one or more components on either side of the panel’s content body.
																Use the weight property
																	With the Dock layout, the components with the most weight will be rendered closer to the content body and be sized smaller, giving the lighter 
																	docked items higher priority in sizing.
																	each quadrant where items are docked has a default weight. Top is 1, left is 3, right is 5, and bottom is 7. We use 10 because it’s a nice 
																	round number that’s larger than 7 (bottom dock).
																	
															The window UI widget builds on the panel, providing  with the ability to float UI components above all the other content on the page.
															
															Exploring Layouts
																Layout management schemes are responsible for the visual organization of widgets on screen.
																The layout managers are divided into two groups: component and container layouts.
																	Auto Layout(default)
																		It places items on the screen, one on top of another.
																		Although the Auto layout doesn’t explicitly resize child items, a child’s width may conform to the container’s content body if it isn’t constrained.
																	Anchor Layout
																		The Anchor layout is similar to other container layouts in that it stacks child items one on top of another, but it adds dynamic sizing into 
																		the mix using an anchor parameter specified on each child.
																	Absolute Layout
																	Fit Layout
																		The Fit layout forces a container's single child to "fit" to its body element.
																		The Fit layout is a great solution for a seamless look when a container has one child.
																	The Accordion layout
																		The Accordion layout, shown in the following listing, is a direct subclass of the VBox layout. It’s useful when we want to display multiple 
																		panels vertically stacked, where only a single item can be expanded or contracted.
																		It’s important to note that the Accordion layout can only function well with an Ext.panel.Panel and two of its subclasses, 
																		Ext.grid.Panel and Ext.tree.Panel.
																		If we need anything else inside an Accordion layout, such as a tab panel, wrap a panel around it and add 
																		that panel as a child of the container that has the Accordion layout.
																		Although the Accordion layout is a good solution for having more than one panel onscreen, it has limitations. For instance, what if we 
																		needed to have 10 components in a particular container? The sum of the heights of the title bars for each item would
																		take up a lot of valuable screen space. The Card layout is perfect for this requirement, because it allows we to show and hide 
																		or flip through child components.
																	The Card Layout
																		The Card layout ensures that its children conform to the size of the container. Unlike the Fit layout, the Card layout 
																		can have multiple children under its control.
																	The Column layout	
																		
																	
															
															
										
											
											
										
											
										
											
									
										
															
															
														
														
												
													

																
																	
																	
																
																
															
															
													
													
													
												
												
														
															
														
														
														
															
											
										
										
											
									
									
														
														
																	
																	
															
														
														
														
														
															  
															  
												
											
											

															 
																		
																																										
																																								
																			
																	
												
																											
													
												
								
							
							