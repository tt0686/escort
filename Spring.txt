Lightweight and minimally invasive development with POJOs -> Other frameworks (Struts,EJB 2.1) lock us by forcing us to extend one of their classes or implement one of their interfaces.
Loose coupling through DI and interface orientation
Declarative programming through aspects and common conventions
Eliminating boilerplate code with aspects and templates

Dependency Injection
	Traditionally each object is responsible for obtaining its own references to the objects it collaborates with(its dependencies).
	
	package com.springinaction.knights;
	public class DamselRescuingKnight implements Knight {
		private RescueDamselQuest quest;
		
		public DamselRescuingKnight() {
			this.quest = new RescueDamselQuest();
		}
		
		public void embarkOnQuest() {
			quest.embark();
		}
	}
	
	DamselRescuingKnight creates its own quest, a RescueDamselQuest, in the constructor. This makes a DamselRescuingKnight tightly coupled to a Rescue-DamselQuest and severely limits the knight’s quest-embarking repertoire.
	With DI, objects are given their dependencies at creation time by some third party that coordinates each object in the system.
	
	public class BraveKnight implements Knight {
		private Quest quest;
			public BraveKnight(Quest quest) {
				this.quest = quest;
			}
			public void embarkOnQuest() {
				quest.embark();
			}
	}
	
	As you can see, BraveKnight, unlike DamselRescuingKnight, doesn’t create his own quest. Instead, he’s given a quest at construction time as a constructor argument. This is a type of DI known as constructor injection.
	
	How wiring components together ?
		XML
			<?xml version="1.0" encoding="UTF-8"?>
				<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans
							http://www.springframework.org/schema/beans/spring-beans.xsd">
					<bean id="knight" class="com.springinaction.knights.BraveKnight">
						<constructor-arg ref="quest" />
					</bean>
					<bean id="quest" class="com.springinaction.knights.SlayDragonQuest">
						<constructor-arg value="#{T(System).out}" />
					</bean>
				</beans>
		JAVA
			@Configuration
			public class KnightConfig {
				@Bean
				public Knight knight() {
					return new BraveKnight(quest());
				}
				@Bean
				public Quest quest() {
					return new SlayDragonQuest(System.out);
				}
			}
			
			In Spring application,an APPLICATION CONTEXT loads bean definitions and wires them together!!!
			Several implementations of its application context,eac primarily differing only in how it loads its configuration.
				ClassPathXmlApplicationContext -> LOADS ONE OR MORE XML FILES LOCATED IN THE APPLICATION CLASSPATH!!!
				
				public class KnightMain {
					public static void main(String[] args) throws Exception {
					ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("META-INF/spring/knight.xml");
					Knight knight = context.getBean(Knight.class);
					knight.embarkOnQuest();
					context.close();
					}
				}
				
				AOP
				
				public class Minstrel {
					private PrintStream stream;
					public Minstrel(PrintStream stream) {
						this.stream = stream;
					}
					public void singBeforeQuest() {
						stream.println("Fa la la, the knight is so brave!");
					}
					public void singAfterQuest() {
						stream.println("Tee hee hee, the brave knight " +"did embark on a quest!");
					}
				}
				
				<?xml version="1.0" encoding="UTF-8"?>
				<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans
							http://www.springframework.org/schema/beans/spring-beans.xsd">
					<bean id="knight" class="com.springinaction.knights.BraveKnight">
						<constructor-arg ref="quest" />
					</bean>
					<bean id="quest" class="com.springinaction.knights.SlayDragonQuest">
						<constructor-arg value="#{T(System).out}" />
					</bean>
					
					<bean id="minstrel" class="com.springinaction.knights.Minstrel">
						<constructor-arg value="#{T(System).out}" />
					</bean>
					
					<aop:config>
						<aop:aspect ref="minstrel">
							<aop:pointcut id="embark" expression="execution(* *.embarkOnQuest(..))"/>
							<aop:before pointcut-ref="embark" method="singBeforeQuest"/>
							<aop:after pointcut-ref="embark" method="singAfterQuest"/>
						</aop:aspect>
					</aop:config>
				</beans>
				
				IN A SPRING-BASED APPLICATION, YOUR APPLICATION OBJECTS LIVE IN THE SPRING CONTAINER!!!!!!
				Spring container implementation can be catagorized into two distinct types :
					1 BEAN FACTORIES
					2 APPLICATION CONTEXTS
						AnnotationConfigApplicationContext
							If we'd rather load your application context from a Java configuration :
									ApplicationContext context = new AnnotationConfigApplicationContext(com.springinaction.knights.config.KnightConfig.class);
						AnnotationConfigWebApplicationContext
						ClassPathXmlApplicationContext
							ApplicationContext context = new ClassPathXmlApplicationContext("knight.xml");
						FileSystemXmlApplicationContext
							ApplicationContext context = new FileSystemXmlApplicationContext("c:/knight.xml");
						XmlWebApplicationContext
						
					Bean Lifecycle
						Instantiate
						Populate properties
						BeanNameAware (if bean implement BeanNameAware interface) the method setBeanName is called
							setBeanName() -> Spring passes the bean's ID
						BeanFactoryAware
							setBeanFactory -> Passes bean factory itseld
						ApplicationContextAware
							setApplicationContext()
						BeanPostProcessor
							postProcessBeforeInitialization
						InitializingBean
							afterPropertiesSet()
							IF THE BEAN WAS DECLARED WITH AN initMethod THEN THE SPECIFIED INITIALIZATION IS CALLED
						BeanPostProcessor
							postProcessorAfterInitialization()
						---------------------------------------------->BEAN READY TO USE<----------------------------------------------------------------------
						DisposableBean
							destroy()
							IF THE BEAN WAS DECLARED WITH AN destroy-method THEN THE SPECIFIED METHOD IS CALLED
							
				SPRING WIRING OPTIONS
					XML
					JAVA
					AUTOMATIC WIRING
						@Component(@Named) -> Identifies a class as a component and serves as a clue to Spting that a bean should be created for the class.
						
						@Configuration
						@ComponentScan()packages to be scanned ->("soundsystem") || (basePacjages={"soudsystem","video"}) || basePackageClasses={CDPlayer.class,DVDPlayer.class}
										We could create an empty marker interface in the packages to be scanned.
							public class CDPlayerConfig {
						}
						
							@ComponentScan will default to scanning the same package as the configuration class!!!
							In XML 
									<context:component-scan base-package="soundsystem" />
									
									
						@Autowired(required=false) || @Inject
						
						@Component
						public class CDPlayer implements MediaPlayer {
							private CompactDisc cd;
							
							@Autowired
							public CDPlayer(CompactDisc cd) {
								this.cd = cd;
							}
							public void play() {
								cd.play();
							}
						}
						
						IF WE WANT TO WIRE COMPONENTS FROM SOME THIRD-PARTY LIBRARY INTO OUR APPLICATION ,BECAUSE WE DO NOT HAVE THE SOURCE CODE FOR THAT LIBRARY , THERE IS NO OPPORTUNITY TO ANNOTATE ITS CLASSES
						WITH @COMPONENT AND @AUTOWIRED.
						
						JAVA EXPLICIT CONFIG
							@Configuration
							public class CDPlayerConfig {
								@Bean(name="otherName")
								public CompactDisc sgtPeppers() {
									return new SgtPeppers();
								}
								
								@Bean
								public CDPlayer anotherCDPlayer() {
									return new CDPlayer(sgtPeppers());   IMPORTANT : The sgtPeppers() method will return the same instance(BY DEFAULT,ALL BEANS IN SPRING ARE SINGLETONS AND THERE IS NO REASON WE
								}												     NEED TO CREATE A DUPLICATE INSTANCE, SO SPRING INTERCEPTS THE CALL TO sgtPeppers() AND MAKES SURE THAT WHAT IS RETURNED IS THE 
							                                                         SPRING BEAN THAT WAS CREATED WHEN SPRING ITSELF CALLED sgtPeppers() TO CREATE THE CompactDisc BEAN)
							
								//Alternative
								@Bean
								public CDPlayer cdPlayer(CompactDisc compactDisc) {
									return new CDPlayer(compactDisc);                -> Best choice because it does not depend on the CompactDisc bean being declared in the same configuration class.It could be 
								}                                                       discovered by component scanning or declared in XML
								
								//Setter method
								@Bean
								public CDPlayer cdPlayer(CompactDisc compactDisc) {
									CDPlayer cdPlayer = new CDPlayer(compactDisc);
									cdPlayer.setCompactDisc(compactDisc);
									return cdPlayer;
								}
							
							}
						XML
							<bean class="soundsystem.SgtPeppers" />
							<bean id="compactDisc" class="soundsystem.SgtPeppers" />
								Constructor Injection
									1:The <constructor-arg> element
									2:Using the c-namespace introduced in Spring 3.0
									
									<bean id="cdPlayer" class="soundsystem.CDPlayer">
										<constructor-arg ref="compactDisc" />
									</bean>
									<bean id="cdPlayer" class="soundsystem.CDPlayer" c:cd-ref="compactDisc" /> (cd -> constructor argument name |-ref -> naming convention that indicates to Spring that we are wiring 
									                                                                                                             a reference to a bean)
									Alternative
									<bean id="cdPlayer" class="soundsystem.CDPlayer" c:_0-ref="compactDisc" />
									<bean id="cdPlayer" class="soundsystem.CDPlayer"c:_-ref="compactDisc" /> -> JUST ONE CONSTRUCTOR ARGUMENT
									
							LITERAL VALUES
								
								public class BlankDisc implements CompactDisc {
									private String title;
									private String artist;
									
									public BlankDisc(String title, String artist) {
										this.title = title;
										this.artist = artist;
									}
									public void play() {
										System.out.println("Playing " + title + " by " + artist);
									}
								}
							
								<bean id="compactDisc" class="soundsystem.BlankDisc">
									<constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" />   -> INSTEAD OF "REF" WE USE THE "VALUE" ATTRIBUTE
									<constructor-arg value="The Beatles" />
								</bean>
								
								<bean id="compactDisc" class="soundsystem.BlankDisc" c:_title="Sgt. Pepper's Lonely Hearts Club Band" c:_artist="The Beatles" />
									<bean id="compactDisc" class="soundsystem.BlankDisc" c:_0="Sgt. Pepper's Lonely Hearts Club Band" c:_1="The Beatles" />
							
							WIRING COLLECTIONS
								public class BlankDisc implements CompactDisc {
									private String title;
									private String artist;
									private List<String> tracks;
									
									public BlankDisc(String title, String artist, List<String> tracks) {
										this.title = title;
										this.artist = artist;
										this.tracks = tracks;
									}
									
									public void play() {
										System.out.println("Playing " + title + " by " + artist);
										for (String track : tracks) {
											System.out.println("-Track: " + track);
										}
									}
								}
								
								<bean id="compactDisc" class="soundsystem.BlankDisc">
									<constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" />
									<constructor-arg value="The Beatles" />
									<constructor-arg>
										<list>
											<value>Sgt. Pepper's Lonely Hearts Club Band</value>  -> IF WE WANT TO REFERENCE A BEAN <ref bean="" /> INSTEAD
											<value>With a Little Help from My Friends</value>
											<value>Lucy in the Sky with Diamonds</value>
											<value>Getting Better</value>
											<value>Fixing a Hole</value>
										</list>
									</constructor-arg>
								</bean>
								
								SETTING PROPERTIES
									public class CDPlayer implements MediaPlayer {
										private CompactDisc compactDisc;
										
										@Autowired
										public void setCompactDisc(CompactDisc compactDisc) {
											this.compactDisc = compactDisc;
										}
										public void play() {
											compactDisc.play();
										}
									}
									
									<bean id="cdPlayer" class="soundsystem.CDPlayer">
										<property name="compactDisc" ref="compactDisc" />
									</bean>
									
									<bean id="cdPlayer" class="soundsystem.CDPlayer" p:compactDisc-ref="compactDisc" />
									
									PROPERTIES THROUGH LITERAL VALUES
										public class BlankDisc implements CompactDisc {
											private String title;
											private String artist;
											private List<String> tracks;
											
											public void setTitle(String title) {
												this.title = title;
											}
											
											public void setArtist(String artist) {
												this.artist = artist;
											}
											
											public void setTracks(List<String> tracks) {
												this.tracks = tracks;
											}
											
											public void play() {
												System.out.println("Playing " + title + " by " + artist);
												for (String track : tracks) {
													System.out.println("-Track: " + track);
												}
											}
										}

										<bean id="compactDisc" class="soundsystem.BlankDisc">
											<property name="title" value="Sgt. Pepper's Lonely Hearts Club Band" />
											<property name="artist" value="The Beatles" />
											<property name="tracks">
												<list>
												<value>Sgt. Pepper's Lonely Hearts Club Band</value>
												<value>With a Little Help from My Friends</value>
												<value>Lucy in the Sky with Diamonds</value>
												<value>Getting Better</value>
												<value>Fixing a Hole</value>
												</list>
											</property>
										</bean>
									
										TO USE THE C:NAMESPACE OR P:NAMESPACE WITH LIST USE THE UTIL-NAMESPACE WHICH CREATES A LIST BEAN!!!
										
								MIXING CONFIGURATION
									@Configuration
									public class CDConfig {
										@Bean
										public CompactDisc compactDisc() {
											return new SgtPeppers();
										}
									}
									
									@Configuration
									@Import(CDConfig.class)
									public class CDPlayerConfig {
										@Bean
										public CDPlayer cdPlayer(CompactDisc compactDisc) {
											return new CDPlayer(compactDisc);
										}
									}
									
															OR
															
									@Configuration
									@Import({CDPlayerConfig.class, CDConfig.class})
									public class SoundSystemConfig {
									}


									ONE OF THE CONFIGURATIONS ARE IN XML
										<bean id="compactDisc" class="soundsystem.BlankDisc" c:_0="Sgt. Pepper's Lonely Hearts Club Band" c:_1="The Beatles">
											<constructor-arg>
											<list>
												<value>Sgt. Pepper's Lonely Hearts Club Band</value>
												<value>With a Little Help from My Friends</value>
												<value>Lucy in the Sky with Diamonds</value>
												<value>Getting Better</value>
												<value>Fixing a Hole</value>
											</list>
											</constructor-arg>
										</bean>
										
										@Configuration
										@Import(CDPlayerConfig.class)
										@ImportResource("classpath:cd-config.xml")
										public class SoundSystemConfig {
										}
										
										FROM XML
											<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c"
													xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
												<import resource="cd-config.xml" />
												<bean id="cdPlayer" class="soundsystem.CDPlayer" c:cd-ref="compactDisc" />
											</beans>
											
											<?xml version="1.0" encoding="UTF-8"?>
											<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c"
													xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
												<bean class="soundsystem.CDConfig" />
												<bean id="cdPlayer" class="soundsystem.CDPlayer" c:cd-ref="compactDisc" />
											</beans>
											
											Because the <import> element only works to import other XML configuration files and there is not an XML element whose job it is to import JavaConfig classes we use
											the <bean> element!!!
											
								PROFILES
									We can develop three different DataSource beans to three different environments(Dev/QA/PRD)
									One way is to configure each bean in a separate configuration class(or XML) and them make a a build-time decision(perhaps using Maven profiles) about which to compile.
									Using PROFILE BEANS
									
									@Configuration
									@Profile("dev")
									public class DevelopmentProfileConfig {
										@Bean(destroyMethod="shutdown")
										public DataSource dataSource() {
										return new EmbeddedDatabaseBuilder()
											.setType(EmbeddedDatabaseType.H2)
											.addScript("classpath:schema.sql")
											.addScript("classpath:test-data.sql")
											.build();
										}
									}
									
									@Configuration
									public class DataSourceConfig {
										@Bean(destroyMethod="shutdown")                        -> METHOD LEVEL
										@Profile("dev")
										public DataSource embeddedDataSource() {
										return new EmbeddedDatabaseBuilder()
										.setType(EmbeddedDatabaseType.H2)
										.addScript("classpath:schema.sql")
										.addScript("classpath:test-data.sql")
										.build();
										}
										
									XML
									 ...profile="dev">
									 
									ACTIVATING PROFILES
										spring.profiles.active
										spring.profiles.default
										
											There are several ways to set these properties:
												As initialization parameters on DispatcherServlet
												As context parameters of a web application
												As JNDI entries
												As environment variables
												As JVM system properties
												Using the @ActiveProfiles annotation on an integration test class
									
									CONDITIONAL BEANS
										@Bean
										@Conditional(MagicExistsCondition.class)
										public MagicBean magicBean() {
											return new MagicBean();
										}
										
											public interface Condition {
												boolean matches(ConditionContext ctxt,AnnotatedTypeMetadata metadata);
											}
											
											public class MagicExistsCondition implements Condition {
												public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
													Environment env = context.getEnvironment();
													return env.containsProperty("magic");
												}
											}
											
											public interface ConditionContext {
												BeanDefinitionRegistry getRegistry(); -> Check for bean definitions
												ConfigurableListableBeanFactory getBeanFactory(); -> Check for the presence of beans, and even dig into bean properties
												Environment getEnvironment(); -> Check for the presence and values of environment variables
												ResourceLoader getResourceLoader(); -> Read and inspect the contents of resources loaded via the ResourceLoader
												ClassLoader getClassLoader(); -> Load and check for the presence of classes via the ClassLoader
											}
											
											public interface AnnotatedTypeMetadata {
												boolean isAnnotated(String annotationType);
												Map<String, Object> getAnnotationAttributes(String annotationType);
												Map<String, Object> getAnnotationAttributes(
												String annotationType, boolean classValuesAsString);
												MultiValueMap<String, Object> getAllAnnotationAttributes(
												String annotationType);
												MultiValueMap<String, Object> getAllAnnotationAttributes(
												String annotationType, boolean classValuesAsString);
											}
											
											The class given to @Conditional can be any type that implements the Condition interface.
											
											@Primary
											primary="true"
											
											The @Qualifier annotation is the main way to work with qualifiers. It can be applied alongside @Autowired or @Inject at the point of injection to specify which
											bean you want to be injected.
											
											@Autowired
											@Qualifier("iceCream")
											public void setDessert(Dessert dessert) {
												this.dessert = dessert;
											}
											
											Problem is that you specified a qualifier on setDessert() that is tightly coupled to the class name of the bean being injected.
											Instead of relying on the bean ID as the qualifier, you can assign your own qualifier to a bean.
											
											@Component
											@Qualifier("cold")
											public class IceCream implements Dessert { ... }
											
											@Target({ElementType.CONSTRUCTOR, ElementType.FIELD,ElementType.METHOD, ElementType.TYPE})
											@Retention(RetentionPolicy.RUNTIME)
											@Qualifier
											public @interface Cold { }
											
									SCOPING BEANS
										By default, all beans created in the Spring application context are created as singletons.
										That is to say, no matter how many times a given bean is injected into other beans, it’s always the same instance that is injected each time.
											Singleton : One instance of the bean is created for the entire application.
											Prototype : One instance of the bean is created every time the bean is injected into or retrieved from the Spring application context.
											Session : In a web application, one instance of the bean is created for each session.
											Request : In a web application, one instance of the bean is created for each request.
											
											@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
												scope="prototype"/>
												
											@Scope(value=WebApplicationContext.SCOPE_SESSION,proxyMode=ScopedProxyMode.INTERFACES)
											
												Problem:
													@Component
													public class StoreService {
													
														@Autowired
														public void setShoppingCart(ShoppingCart shoppingCart) {
														this.shoppingCart = shoppingCart;
														}
														...
													}
													
													ShoppingCart is a session scope bean.
													Because StoreService is a singleton bean, it will be created as the Spring application context is loaded. 
													As it's created, Spring will attempt to inject ShoppingCart into the setShoppingCart() method. But the ShoppingCart bean, being session scoped,
													doesn't exist yet. There won't be an instance of ShoppingCart until a user comes along and a session is created.
													Moreover, there will be many instances of ShoppingCart: one per user. You don't want Spring to inject just any single instance of ShoppingCart into StoreService. 
													You want StoreService to work with the ShoppingCart instance for whichever session happens to be in play when StoreService needs to work with the shopping cart.
													Instead of injecting the actual ShoppingCart bean into StoreService, Spring should inject a proxy to the ShoppingCart bean. 
													This proxy will expose the same methods as ShoppingCart so that for all StoreService knows, it is the shopping cart. 
													But when StoreService calls methods on ShoppingCart, the proxy will lazily resolve it and delegate the call to the actual session-scoped Shopping-Cart bean.
													As configured, proxyMode is set to ScopedProxyMode.INTERFACES, indicating that the proxy should implement the ShoppingCart interface and delegate to the implementation bean.
													This is fine (and the most ideal proxy mode) as long as ShoppingCart is an interface and not a class. But if ShoppingCart is a concrete class, there’s no way Spring can
													create an interface-based proxy. Instead, it must use CGLib to generate a class-based proxy. 
													So, if the bean type is a concrete class, you must set proxyMode to ScopedProxy- Mode.TARGET_CLASS to indicate that the proxy should be generated as an extension of
													the target class.
											
											  XML
												scope="session">
											    <aop:scoped-proxy />
											    <aop:scoped-proxy proxy-target-class="false" />
												
											AVOID HARD-CODED VALUES
												Placeholders
												SPEL
												
												@PropertySource("classpath:/com/soundsystem/app.properties") -> Declare a property source
												
												@Autowired
												Environment env;
												
												env.getProperty("disc.title")
												
												XML PLACEHOLDERS
												<bean id="sgtPeppers" class="soundsystem.BlankDisc" c:_title="${disc.title}" c:_artist="${disc.artist}" />
												
												COMPONENT-SCANNING
													public BlankDisc(@Value("${disc.title}") String title,@Value("${disc.artist}") String artist) {
														this.title = title;
														this.artist = artist;
													}
												
												In order to use placeholder values, you must configure either a PropertyPlaceholder- Configurer bean or a PropertySourcesPlaceholderConfigurer bean.
												
												@Bean
												public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {
													return new PropertySourcesPlaceholderConfigurer();
												}
												
												WHY IS A BEAN DECLARED STATIC ?
													SPECIAL CONSIDERATION MUST BE TAKEN for @Bean methods that return Spring BeanFactoryPostProcessor types!!
													BFPP objects must be instantiated very early in the container lifecycle,they can interfere with processing of annotations such as 
													@Autowire ,@Value .By making these methods as static,it can be invoked without causing instantiation of its declaring @Configuration class,
													thus avoiding the above-mentioned lifecycle conflits!!!
													
												In XML 
													<context:property-placeholder />
													
												SPEL
													public BlankDisc(@Value("#{systemProperties['disc.title']}") String title,@Value("#{systemProperties['disc.artist']}") String artist) {
														this.title = title;
														this.artist = artist;
													}
													
													<bean id="sgtPeppers" class="soundsystem.BlankDisc" c:_title="#{systemProperties['disc.title']}" c:_artist="#{systemProperties['disc.artist']}" />
													
													Call methods
														#{artistSelector.selectArtist()}
														To guard against a NullPointerException, you can use the type-safe operator:
														#{artistSelector.selectArtist()?.toUpperCase()}
														
														The key to working with class-scoped methods and constants in SpEL is to use the T() operator.
															T(java.lang.Math)
														The result of the T() operator, as shown here, is a Class object that represents java.lang.Math.
														
															#{jukebox.songs.?[artist eq 'Aerosmith']}
															#{jukebox.songs.^[artist eq 'Aerosmith']}
															#{jukebox.songs.![title]}
															
										AOP
											Spring ascpects types
												Before
												After
												After-Returning
												After-Throwing
												Around
											
											Introductions
												An introduction allows us to add new methods or attributes to existing classes.
											Weaving
												Is the process of applying aspects to a target object to create a new proxied object.The aspects are woven into the target object at the specified join points.
													Compile Time : Requires special compiler(Aspect's weaving compiler)
													Class Load time : Special ClassLoader
													RunTime : Aspects we woven in sometime during the execution of the application.
													
													Spring’s support for AOP comes in four styles:
														Classic Spring proxy-based AOP
														Pure-POJO aspects
														@AspectJ annotation-driven aspects
														Injected AspectJ aspects (available in all versions of Spring)
														
													Spring AOP is built around dynamic proxies. Consequently, Spring’s AOP support is limited to method interception.
													
													execution(* concert.Performance.perform(..))
													          |           |           |      |->Taking any arguments
															  |           |           |->The method
															  |           |->The type that the method belongs to
															  |->Return any type
															  
													execution(* concert.Performance.perform(..)) && within(concert.*)) LIMIT THE MATCH TO ONLY THE CONCERT PACKAGE
													
													@Aspect
													public class Audience {
														@Pointcut("execution(** concert.Performance.perform(..))")
														public void performance() {}
														
														@Before("performance()")
														public void silenceCellPhones() {
															System.out.println("Silencing cell phones");
														}
														
														@Before("performance()")
														public void takeSeats() {
															System.out.println("Taking seats");
														}
														
														@AfterReturning("performance()")
														public void applause() {
															System.out.println("CLAP CLAP CLAP!!!");
														}
														
														@AfterThrowing("performance()")
														public void demandRefund() {
															System.out.println("Demanding a refund");
														}
													}
													
													@Bean
													public Audience audience() {
														return new Audience();
													}
													
													JAVA CONFIG
														@Configuration
														@EnableAspectJAutoProxy
														@ComponentScan
														public class ConcertConfig {
														
															@Bean
															public Audience audience() {
																return new Audience();
															}
														}
														
													XML
														
															<context:component-scan base-package="concert" />
															<aop:aspectj-autoproxy />
															<bean class="concert.Audience" />
														</beans>
														
														In XML
												<aop:config>
													<aop:aspect ref="audience">
														<aop:before pointcut="execution(** concert.Performance.perform(..))" method="silenceCellPhones"/>
														<aop:before pointcut="execution(** concert.Performance.perform(..))" method="takeSeats"/>
														<aop:after-returning pointcut="execution(** concert.Performance.perform(..))" method="applause"/>
														<aop:after-throwing pointcut="execution(** concert.Performance.perform(..))" method="demandRefund"/>
													</aop:aspect>
												</aop:config>
												
												THIS MAKES SPRING'S XML CONFIGURATION FOR AOP A HANDY WAY TO USE TYPES DEFINED IN THIRD-PARTY LIBRARIES AS ADVICE, EVEN THOUGH WE CAN'T ANNOTATE THEM WITH ASPECTJ ASPECTS.
												
												<aop:config>
													<aop:aspect ref="audience">
														<aop:pointcut id="performance" expression="execution(** concert.Performance.perform(..))" />
														<aop:before pointcut-ref="performance" method="silenceCellPhones"/>
														<aop:before pointcut-ref="performance" method="takeSeats"/>
														<aop:after-returning pointcut-ref="performance" method="applause"/>
														<aop:after-throwing pointcut-ref="performance" method="demandRefund"/>
													</aop:aspect>
												</aop:config>
														
												REWRITING WITH AROUND
													@Aspect
													public class Audience {
														@Pointcut("execution(** concert.Performance.perform(..))")
														public void performance() {}
														
														@Around("performance()")
														public void watchPerformance(ProceedingJoinPoint jp) {
															try {
																System.out.println("Silencing cell phones");
																System.out.println("Taking seats");
																jp.proceed();
																System.out.println("CLAP CLAP CLAP!!!");
															} catch (Throwable e) {
																System.out.println("Demanding a refund");
															}
														}
													}
													
													Example with arguments
														@Pointcut(
									"execution(* soundsystem.CompactDisc.playTrack(int)) && args(trackNumber)")
									public void trackPlayed(int trackNumber) {}
									
									INTRODUCTIONS
										
											Adding new methods to Spring Beans.
											When a method on the introduced interface is called, the proxy delegates the call to some other object that provides the implementation of the new
											interface. Effectively, this gives you one bean whose implementation is split across multiple classes.
											
											@Aspect
											public class EncoreableIntroducer {
												@DeclareParents(value="concert.Performance+",defaultImpl=DefaultEncoreable.class)
												public static Encoreable encoreable;
											}
											
											
											
							SPRING MVC FRAMEWORK
							
								Request ------> DISPATCH SERVLET ----> HANDLER MAPPING ----> CONTROLLER -> MODEL & LOGICAL VIEW NAME ---> VIEW RESOLVER  -----> VIEW ---> RESPONSE
								
								
								Like most Javabased web frameworks, Spring MVC funnels requests through a single front controller servlet. A front controller is a common web application pattern where a single servlet
								delegates responsibility for a request to other components of an application to perform actual processing. In the case of Spring MVC, DispatcherServlet is the front controller.
								The DispatcherServlet’s job is to send the request on to a Spring MVC controller.
								A controller is a Spring component that processes the request. But a typical application may have several controllers, and DispatcherServlet needs some help deciding
								which controller to send the request to. So the DispatcherServlet consults one or more handler mappings C to figure out where the request’s next stop will be. The
								handler mapping pays particular attention to the URL carried by the request when making its decision.
								Once an appropriate controller has been chosen, DispatcherServlet sends the request on its merry way to the chosen controller D. At the controller, the request
								drops off its payload (the information submitted by the user) and patiently waits while the controller processes that information. (Actually, a well-designed controller performs
								little or no processing itself and instead delegates responsibility for the business logic to one or more service objects.)
								The logic performed by a controller often results in some information that needs to be carried back to the user and displayed in the browser. This information is
								referred to as the model. But sending raw information back to the user isn’t sufficient— it needs to be formatted in a user-friendly format, typically HTML. 
								For that, the information needs to be given to a view, typically a JavaServer Page (JSP).
								One of the last things a controller does is package up the model data and identify the name of a view that should render the output. It then sends the request, along
								with the model and view name, back to the DispatcherServlet. So that the controller doesn’t get coupled to a particular view, the view name.
								The DispatcherServlet consults a view resolver to map the logical view name to a specific view implementation, which may or may not be a JSP.
								
								Configure DispatchServlet in Java instead of the traditional web.xml
									Using the Servlet 3.0 specification , the servlet container looks for any classes in the classpath that implements the javax.servlet.ServletContainerInitializer interface,
									if they are found,they are used to configure the servlet container.
									Spring supplies an implementation of that interface called SpringServletContainerInitializer that,in turn,seeks out any classes that implement WebApplicationInitializer and 
									delegates to them for configuration.
									
									IN SPRING MVC THERE ARE TWO APPLICATION CONTEXT
										DispatcherServlet is expected to load beans containing web components such as controllers, view resolvers, and handler mappings, ContextLoaderListener is
										expected to load the other beans in your application. These beans are typically the middle-tier and data-tier components that drive the back end of the application.
										Under the covers, AbstractAnnotationConfigDispatcherServletInitializer creates both a DispatcherServlet and a ContextLoaderListener. The @Configuration
										classes returned from getServletConfigClasses() will define beans for DispatcherServlet’s application context. Meanwhile, the @Configuration class’s returned 
										getRootConfigClasses() will be used to configure the application context created by ContextLoaderListener.
										
										@Configuration
										@EnableWebMvc
										@ComponentScan("spitter.web")
										public class WebConfig extends WebMvcConfigurerAdapter {
										
											@Bean
											public ViewResolver viewResolver() {
												InternalResourceViewResolver resolver = new InternalResourceViewResolver();
												resolver.setPrefix("/WEB-INF/views/");
												resolver.setSuffix(".jsp");
												resolver.setExposeContextBeansAsAttributes(true);
												return resolver;
											}
											
											@Override
											public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
												configurer.enable();
											}
										}
										
										WebConfig class extends WebMvcConfigurerAdapter and overrides its configureDefaultServletHandling() method. By calling enable() on the given
										DefaultServletHandlerConfigurer, you’re asking DispatcherServlet to forward requests for static resources to the servlet container’s default servlet and not to try to
										handle them itself.
										
										@Component ===== @Controller
										
										@Controller
										public class HomeController {
											@RequestMapping(value="/", method=GET)
											public String home() {
												return "home";
											}
										}
										
										TEST SPRING MVC CONTROLLERS
											public class HomeControllerTest {
												@Test
												public void testHomePage() throws Exception {
													HomeController controller = new HomeController();
													MockMvc mockMvc = standaloneSetup(controller).build();
													mockMvc.perform(get("/")).andExpect(view().name("home"));
												}
											}
											
											@Test
											public void shouldShowRecentSpittles() throws Exception {
												List<Spittle> expectedSpittles = createSpittleList(20);
												SpittleRepository mockRepository = mock(SpittleRepository.class);
												when(mockRepository.findSpittles(Long.MAX_VALUE, 20)).thenReturn(expectedSpittles);
												SpittleController controller = new SpittleController(mockRepository);
												SpittleController controller = new SpittleController(mockRepository);
												MockMvc mockMvc = standaloneSetup(controller).setSingleView(new InternalResourceView("/WEB-INF/views/spittles.jsp")).build();
												mockMvc.perform(get("/spittles")).andExpect(view().name("spittles")).andExpect(model().attributeExists("spittleList")).andExpect(model().attribute("spittleList",hasItems(expectedSpittles.toArray())));
											}
											
											@Controller
											@RequestMapping("/spittles")
											public class SpittleController {
												private SpittleRepository spittleRepository;
												@Autowired
												public SpittleController(SpittleRepository spittleRepository) {
													this.spittleRepository = spittleRepository;
												}
												
												@RequestMapping(method=RequestMethod.GET)
												public String spittles(Model model) {
													model.addAttribute(spittleRepository.findSpittles(Long.MAX_VALUE, 20));
													return "spittles";
												}
											}
											
											The Model is essentially a map (that is, a collection of key-value pairs) that will be handed off to the view so that the data can be rendered to the client. 
											When add-Attribute() is called without specifying a key, the key is inferred from the type of object being set as the value. In this case, because it’s a List<Spittle>, 
											the key will be inferred as spittleList.
											LIKEWISE, IF YOU’D PREFER TO WORK WITH A NON-SPRING TYPE, YOU CAN ASK FOR A JAVA .UTIL.MAP INSTEAD OF MODEL!!!
											
											Here’s another way to write the spittles() method:
											@RequestMapping(method=RequestMethod.GET)
											public List<Spittle> spittles() {
												return spittleRepository.findSpittles(Long.MAX_VALUE, 20));
											}
											
											When a handler method returns an object or a collection like this, the value returned is put into the model, and the model key is inferred from its type.
											As for the logical view name, it’s inferred from the request path. Because this method handles GET requests for /spittles, the view name is spittles (chopping off the leading slash).
											Now that there’s data in the model, how does the JSP access it? As it turns out, when the view is a JSP, the model data is copied into the request as request attributes.
											Therefore, the spittles.jsp file can use JavaServer Pages Standard Tag Library’s (JSTL).
											
											Spring MVC provides several ways that a client can pass data into a controller’s handler method. These include
												Query parameters
													@RequestMapping(method=RequestMethod.GET)
													public List<Spittle> spittles(@RequestParam(value="max",defaultValue=MAX_LONG_AS_STRING) long max,@RequestParam(value="count", defaultValue="20") int count) {
														return spittleRepository.findSpittles(max, count);
													}
												Form parameters
													<form method="POST">
														First Name: <input type="text" name="firstName" /><br/>
													...
													
													Notice that the <form> tag doesn’t have an action parameter set. Because of that, when this form is submitted, it will be posted back to the same 
													URL path that displayed it.
													
													@RequestMapping(value="/register", method=POST)
													public String processRegistration(Spitter spitter) {
														spitterRepository.save(spitter);
														return "redirect:/spitter/" + spitter.getUsername();
													}
													
														When InternalResourceViewResolver sees the redirect: prefix on the view specification, it knows to interpret it as a redirect specification instead of as a view name. 
														In this case, it will redirect to the path for a user’s profile page. For example, if the Spitter.username property is jbauer, then the view will redirect 
														to /spitter/jbauer.
														It’s worth noting that in addition to redirect:, InternalResourceViewResolver also recognizes the forward: prefix. When it sees a view specification prefixed with
														forward:, the request is forwarded to the given URL path instead of redirected.
														
														SPRING MVC supports JAVA Validation API
														
														@NotNull
														@Size(min=5, max=16 , message="{username.size}")
														private String username;
														
														public String processRegistration(@Valid Spitter spitter,Errors errors) {
															if (errors.hasErrors()) {
															return "registerForm";
														}
													
													
												Path variables
													Resource-oriented controllers
													The resource being identified (the Spittle) would be identified by the URL path, not by query parameters.
													A GET request for /spittles/12345 is better than one for /spittles/show?spittle_id=12345.
													To accommodate these path variables, Spring MVC allows for placeholders in an @RequestMapping path.
																										
													@RequestMapping(value="/{spittleId}", method=RequestMethod.GET)
													public String spittle(@PathVariable("spittleId") long spittleId,Model model) {
														model.addAttribute(spittleRepository.findOne(spittleId)); ---> MODEL KEY WILL BE "spittle" inferred by the type passed in to addAttribute();
														return "spittle";
													}
													
													The data in the Spittle object can then be rendered in the view by referring to the request attribute whose key is spittle (the same as the model key).
														<div class="spittleMessage"><c:out value="${spittle.message}" /></div>
													
													Because the method parameter name happens to be the same as the placeholder name, you can optionally omit the value parameter on @PathVariable.
													
											VIEW RESOLUTION
												
												public interface ViewResolver {
													View resolveViewName(String viewName, Locale locale)
												throws Exception;
												}

												public interface View {
													String getContentType();
													void render(Map<String, ?> model,HttpServletRequest request,HttpServletResponse response) throws Exception;
												}
												
												Views Implementations
													BeanNameViewResolver
													ContentNegotiatingViewResolver
													FreeMarkerViewResolver
													InternalResourceViewResolver
													JasperReportsViewResolver
													ResourceBundleViewResolver
													TilesViewResolver
													UrlBasedViewResolver
													VelocityLayoutViewResolver
													VelocityViewResolver
													XmlViewResolver
													XsltViewResolver
													
												But if those JSP files are using JSTL tags for formatting or messages, then you may want to configure InternalResourceViewResolver to resolve a JstlView instead.
												JSTL’s formatting tags need a Locale to properly format locale-specific values such as dates and money. And its message tags can use a Spring message source and a
												Locale to properly choose messages to render in HTML. By resolving JstlView, the JSTL tags will be given the Locale and any message source configured in Spring.	
													
												@Bean
												public ViewResolver viewResolver() {
													InternalResourceViewResolver resolver = new InternalResourceViewResolver();
													resolver.setPrefix("/WEB-INF/views/");
													resolver.setSuffix(".jsp");
													resolver.setViewClass(org.springframework.web.servlet.view.JstlView.class);
													return resolver;
												}
												
												<%@ taglib uri="http://www.springframework.org/tags/form" prefix="sf" %>
												<sf:form method="POST" commandName="spitter"> ---->  commandName attribute -> There must be an object in the model whose key is "spitter".
													First Name: <sf:input path="firstName" /><br/>
													Last Name: <sf:input path="lastName" /><br/>
													Email: <sf:input path="email" /><br/>
													Username: <sf:input path="username" /><br/>
													Password: <sf:password path="password" /><br/>
													<input type="submit" value="Register" />
												</sf:form>
												
												Displaying errors
													<sf:form method="POST" commandName="spitter">
														First Name: <sf:input path="firstName" />
														<sf:errors path="firstName" /><br/>
														
														
														<sf:errors path="*" element="div" cssClass="errors" />
														<sf:label path="firstName" cssErrorClass="error">First Name</sf:label>:
														<sf:input path="firstName" cssErrorClass="error" /><br/>
												
											Message Properties
												@Bean
												public MessageSource messageSource() {
													ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
													messageSource.setBasename("messages");
													return messageSource;
												}

												@Bean
												public MessageSource messageSource() {
													ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource();
													messageSource.setBasename("file:///etc/spittr/messages");
													messageSource.setCacheSeconds(10);
													return messageSource;
												}

												The
												basename property can be set to look for messages in the classpath (with a classpath: prefix), in the filesystem (with a file: prefix), or at the root of the web application
												(with no prefix). Here, it’s configured to look for messages in properties files in the /etc/spittr directory of the server’s filesystem and with a base filename of “messages”.

												create the default properties
												file named messages.properties.

												If, for example, you wanted to show the welcome message in Spanish for anyone whose language settings are set to Spanish, you’d need to create another properties
												file named messages_es.properties
												
												In its simplest form, <s:url> takes a servlet-context-relative URL and renders it with the servlet context path prepended. For example, consider this basic use of
												<s:url>:
												
													<a href="<s:url href="/spitter/register" />">Register</a>

												If the application’s servlet context is named spittr, then the following HTML will be rendered in the response:
													<a href="/spittr/spitter/register">Register</a>
												This enables you to create URLs without worrying about what the servlet context path will be.
												
											<s:url href="/spitter/{username}" var="spitterUrl">
												<s:param name="username" value="jbauer" />
											</s:url>
												When the href value is a placeholder that matches a parameter specified by <s:param>, the parameter is inserted into the placeholder’s spot. 
												If the <s:param> parameter doesn’t match any placeholders in href, then the parameter is used as a query parameter.
												
										APACHE TILES
											Layout engine such as Apache Tiles to define a common page layout that will be applied to all pages.
											In order to use Tiles with Spring, you’ll have to configure a couple of beans. You need a TilesConfigurer bean whose job is to locate and load tile definitions and generally
											coordinate Tiles. In addition, you need a TilesViewResolver bean to resolve logical view names to tile definitions.
											
											@Bean
											public TilesConfigurer tilesConfigurer() {
												TilesConfigurer tiles = new TilesConfigurer();
												tiles.setDefinitions(new String[] {"/WEB-INF/layout/tiles.xml"});
												tiles.setCheckRefresh(true);
												return tiles;
											}
											
											@Bean
											public ViewResolver viewResolver() {
												return new TilesViewResolver();
											}
											
											<tiles-definitions>
												<definition name="base" template="/WEB-INF/layout/page.jsp">
													<put-attribute name="header" value="/WEB-INF/layout/header.jsp" />
													<put-attribute name="footer" value="/WEB-INF/layout/footer.jsp" />
												</definition>

												<definition name="home" extends="base">
													<put-attribute name="body" value="/WEB-INF/views/home.jsp" />
												</definition>
												
												<definition name="registerForm" extends="base">
													<put-attribute name="body" value="/WEB-INF/views/registerForm.jsp" />
												</definition>
												
											<html>
												<head>
													<title>Spittr</title>
													<link rel="stylesheet" type="text/css" href="<s:url value="/resources/style.css" />" >
												</head>
												<body>
												<div id="header">
													<t:insertAttribute name="header" />
												</div>
												<div id="content">
													<t:insertAttribute name="body" />
												</div>
												<div id="footer">
													<t:insertAttribute name="footer" />
												</div>

										THYMELEAF
										
										@Bean
										public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {
											ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();
											viewResolver.setTemplateEngine(templateEngine);
											return viewResolver;
										}
										
										@Bean
										public TemplateEngine templateEngine(TemplateResolver templateResolver) {
											SpringTemplateEngine templateEngine = new SpringTemplateEngine();
											templateEngine.setTemplateResolver(templateResolver);
											return templateEngine;
										}
										
										@Bean
										public TemplateResolver templateResolver() {
											TemplateResolver templateResolver = new ServletContextTemplateResolver();
											templateResolver.setPrefix("/WEB-INF/templates/");
											templateResolver.setSuffix(".html");
											templateResolver.setTemplateMode("HTML5");
											return templateResolver;
										}
										
										<label th:class="${#fields.hasErrors('firstName')}? 'error'">First Name</label>:
										<input type="text" th:field="*{firstName}" th:class="${#fields.hasErrors('firstName')}? 'error'" /><br/>
										
										<form method="POST" th:object="${spitter}">
											<div class="errors" th:if="${#fields.hasErrors('*')}">
												<ul>
													<li th:each="err : ${#fields.errors('*')}" th:text="${err}">Input is incorrect</li>
												</ul>
											</div>
											<label th:class="${#fields.hasErrors('firstName')}? 'error'">
												First Name</label>:
												<input type="text" th:field="*{firstName}" th:class="${#fields.hasErrors('firstName')}? 'error'" /><br/>
												
										But what if you want to register additional servlets, filters, or listeners?
											Therefore, if you need to register any additional components into the web container, you need only create a new initializer class. 
											The easiest way to do this is by implementing Spring's WebApplicationInitializer interface.
											
												public class MyServletInitializer implements WebApplicationInitializer {
													@Override
													public void onStartup(ServletContext servletContext) throws ServletException {
														Dynamic myServlet = servletContext.addServlet("myServlet", MyServlet.class);
														myServlet.addMapping("/custom/**");
													}
												}
												
										XML
											web.xml
											
											<context-param>
												<param-name>contextConfigLocation</param-name>
												<param-value>/WEB-INF/spring/root-context.xml</param-value>
											</context-param>
											<listener>
											<listener-class>
												org.springframework.web.context.ContextLoaderListener
											</listener-class>
											</listener>
											<servlet>
												<servlet-name>appServlet</servlet-name>
												<servlet-class>org.springframework.web.servlet.DispatcherServlet
											</servlet-class>
											<load-on-startup>1</load-on-startup>
											</servlet>
											<servlet-mapping>
												<servlet-name>appServlet</servlet-name>
												<url-pattern>/</url-pattern>
											</servlet-mapping>
											
												ContextLoaderListener and DispatcherServlet each load a Spring application context. The contextConfigLocation context parameter
												specifies the location of the XML file that defines the root application context loaded by ContextLoaderListener. 
												The root context is loaded with bean definitions in /WEB-INF/spring/root-context.xml.
												DispatcherServlet loads its application context with beans defined in a file whose name is based on the servlet name. 
												The servlet is named appServlet. Therefore, DispatcherServlet loads its application context from an XML file at /WEB-INF/appServlet-context.xml.
												
										JAVA CONFIGURATION
										
											<context-param>
												<param-name>contextClass</param-name>
											<param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
											</context-param>
											<context-param>
												<param-name>contextConfigLocation</param-name>
												<param-value>com.habuma.spitter.config.RootConfig</param-value>
											</context-param>
											<listener>
												<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
											</listener>
											<servlet>
												<servlet-name>appServlet</servlet-name>
												<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
													<init-param>
													<param-name>contextClass</param-name>
													<param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
												</init-param>
												<init-param>
													<param-name>contextConfigLocation</param-name>
													<param-value>com.habuma.spitter.config.WebConfigConfig</param-value>
												</init-param>
												<load-on-startup>1</load-on-startup>
											</servlet>
											<servlet-mapping>
												<servlet-name>appServlet</servlet-name>
												<url-pattern>/</url-pattern>
											</servlet-mapping>
											
											MultiPart Form Data
												DispatcherServlet doesn’t implement any logic for parsing the data in a multipart request. Instead, it delegates to an implementation of Spring’s MultipartResolver
												strategy interface to resolve the content in a multipart request.
												
												AUTOMATIC
													@Bean
													public MultipartResolver multipartResolver() throws IOException {
														return new StandardServletMultipartResolver();
													}
													
													If you’re configuring DispatcherServlet in a servlet initializer class that implements WebApplicationInitializer
												
													DispatcherServlet ds = new DispatcherServlet();
													Dynamic registration = context.addServlet("appServlet", ds);
													registration.addMapping("/");
													registration.setMultipartConfig(new MultipartConfigElement("/tmp/spittr/uploads"));
													
													If you’ve configured DispatcherServlet in a servlet initializer class that extends AbstractAnnotationConfigDispatcherServletInitializer or 
													AbstractDispatcherServletInitializer, you don’t create the instance of DispatcherServlet or register it with the servlet context directly.
													
													@Override
													protected void customizeRegistration(Dynamic registration) {
														registration.setMultipartConfig(new MultipartConfigElement("/tmp/spittr/uploads"));
													}
													
													XML
														<servlet>
															<servlet-name>appServlet</servlet-name>
															<servlet-class>
																	org.springframework.web.servlet.DispatcherServlet
															</servlet-class>
															<load-on-startup>1</load-on-startup>
															<multipart-config>
																<location>/tmp/spittr/uploads</location>
																<max-file-size>2097152</max-file-size>
																<max-request-size>4194304</max-request-size>
															</multipart-config>
														</servlet>
														
													Handling MultiPart Request
														@RequestMapping(value="/register", method=POST)
														public String processRegistration(@RequestPart("profilePicture") byte[] profilePicture,@Valid Spitter spitter,Errors errors) {
															...
														}
														
														WORKING WITH THE UPLOADED FILE’S RAW BYTES IS SIMPLE BUT LIMITING. THEREFORE, SPRING ALSO OFFERS MULTIPARTFILE AS A WAY TO GET A RICHER OBJECT!!!
														
													Exceptions
													
														@ResponseStatus(value=HttpStatus.NOT_FOUND,reason="Spittle Not Found")
														public class SpittleNotFoundException extends RuntimeException {
														}
														
														@ExceptionHandler(DuplicateSpittleException.class)
														public String handleDuplicateSpittle() {
															return "error/duplicate";
														}
														
														What’s especially interesting about @ExceptionHandler methods is that they handle their exceptions from any handler method in the same controller.
														
														@ControllerAdvice
														public class AppWideExceptionHandler {
															@ExceptionHandler(DuplicateSpittleException.class)
															public String duplicateSpittleHandler() {
																return "error/duplicate";
															}
														}
														
														Now, if a DuplicateSpittleException is thrown from any controller method, no matter which controller it’s in, this duplicateSpittleHandler() method will be called to
														handle the exception.
														
														CARRYING DATA ACROSS REDIRECT REQUESTS
														
																When a controller method returns a String whose value starts with redirect:, that String isn’t used to look up a view, but is instead 
																used as a path to redirect the browser to.
																
																	Passing data as path variables and/or query parameters using URL templates
																		@RequestMapping(value="/register", method=POST)
																		public String processRegistration(Spitter spitter, Model model) {
																			spitterRepository.save(spitter);
																			model.addAttribute("username", spitter.getUsername());
																			model.addAttribute("spitterId", spitter.getId());
																			return "redirect:/spitter/{username}";
																		}
																		
																		Because the spitterId attribute from the model doesn’t map to any URL placeholders in the redirect, it’s tacked on to the redirect automatically as a query parameter.
																		If the username attribute is habuma and the spitterId attribute is 42, then the resulting redirect path will be /spitter/habuma?spitterId=42.
																	
																	Sending data in flash attributes
																		Spring offers a way to set flash attributes via RedirectAttributes, a sub-interface of Model
																		@RequestMapping(value="/register", method=POST)
																		public String processRegistration(Spitter spitter, RedirectAttributes model) {
																			spitterRepository.save(spitter);
																			model.addAttribute("username", spitter.getUsername());
																			model.addFlashAttribute("spitter", spitter);
																			return "redirect:/spitter/{username}";
																		}
																		
																		Before the redirect takes place, all flash attributes are copied into the session. After the redirect, the flash attributes stored 
																		in the session are moved out of the session and into the model. The method that handles the redirect request can then access the
																		Spitter from the model, just like any other model object.
																	
																		@RequestMapping(value="/{username}", method=GET)
																		public String showSpitterProfile(@PathVariable String username, Model model) {
																			if (!model.containsAttribute("spitter")) {
																				model.addAttribute(spitterRepository.findByUsername(username));
																			}
																			return "profile";
																		}
																		
																		
											SECURITY
												Spring Security employs several servlet filters to provide various aspects of security.
												DelegatingFilterProxy is a special servlet filter that, by itself, doesn’t do much.
												Instead, it delegates to an implementation of javax.servlet.Filter that’s registered as a <bean> in the Spring application context		
													
												JAVA
													If you'd rather configure DelegatingFilterProxy in Java with a WebApplication-
													Initializer, then all you need to do is create a new class that extends AbstractSecurityWebApplicationInitializer:

													public class SecurityWebInitializer extends AbstractSecurityWebApplicationInitializer {}
													
													AbstractSecurityWebApplicationInitializer implements WebApplicationInitializer, so it will be discovered by Spring and be used to register 
													DelegatingFilterProxy with the web container.
													
													WHETHER YOU CONFIGURE DELEGATINGFILTERPROXY IN WEB.XML OR BY SUBCLASSING ABSTRACTSECURITYWEBAPPLICATIONINITIALIZER, IT WILL INTERCEPT REQUESTS COMING
													INTO THE APPLICATION AND DELEGATE THEM TO A BEAN WHOSE ID IS SPRINGSECURITYFILTERCHAIN.
													
													@Configuration
													@EnableWebSecurity
													public class SecurityConfig extends WebSecurityConfigurerAdapter {
													}
													
													Spring Security must be configured in a bean that implements WebSecurityConfigurer or (for convenience) extends WebSecurityConfigurerAdapter. 
													Any bean in the Spring application context that implements WebSecurityConfigurer can contribute to Spring Security configuration, but it’s often most
													convenient for the configuration class to extend WebSecurityConfigurerAdapter.
													
													We should consider using @EnableWebMvcSecurity
													
													@Configuration
													@EnableWebMvcSecurity
													public class SecurityConfig extends WebSecurityConfigurerAdapter {
													}
													
													Among other things, the @EnableWebMvcSecurity annotation configures a Spring MVC argument resolver so that handler methods can receive the authenticated user’s
													principal (or username) via @AuthenticationPrincipal-annotated parameters. It also configures a bean that automatically adds a hidden cross-site request forgery
													(CSRF) token field on forms using Spring’s form-binding tag library.
													
													You can configure web security by overriding WebSecurityConfigurerAdapter’s three configure() methods.
													
													configure(WebSecurity) Override to configure Spring Security’s filter chain.
													configure(HttpSecurity) Override to configure how requests are secured by interceptors.
													configure(AuthenticationManagerBuilder)
													
													
													Database Users
													
													@Autowired
													DataSource dataSource;
													
													@Override
													protected void configure(AuthenticationManagerBuilder auth)throws Exception {
														auth.jdbcAuthentication().dataSource(dataSource).usersByUsernameQuery("select username, password, true from Spitter where username=?").
														authoritiesByUsernameQuery("select username, 'ROLE_USER' from Spitter where username=?");
													}
													
													LDAP Users
													
													@Override
													protected void configure(AuthenticationManagerBuilder auth) throws Exception {
														auth.ldapAuthentication().userSearchFilter("(uid={0})").groupSearchFilter("member={0}");
													}
													
													The key to fine-tuning security for each request is to override the configure (HttpSecurity) method
													@Override
													protected void configure(HttpSecurity http) throws Exception {
														http.authorizeRequests().antMatchers("/spitters/me").authenticated().antMatchers(HttpMethod.POST, "/spittles").authenticated().anyRequest().permitAll();
													}
													
													Securing with Spring Expressions
														What if you wanted to restrict access to certain roles only on Tuesday?
														Using the access() method, you can also use SpEL as a means for declaring access requirements
														
													Preventing cross-site request forgery
														If you’re using Thymeleaf for your page template, you’ll get the hidden _csrf field automatically, as long as the <form> tag’s
														action attribute is prefixed to come from the Thymeleaf namespace:
						
														<form method="POST" th:action="@{/spittles}">
															...
														</form>
														
														If you’re using JSP for page templates, you can do something very similar:
														
														<input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}" />
														
														Even better, if you’re using Spring’s form-binding tag library, the <sf:form> tag will automatically add the hidden CSRF token tag for you.
														
												
												
												Form-based authentication is ideal for human users of an application. Later we’ll see how to turn some of your web application’s pages into a RESTful API.
												When the user of the application is another application, prompting for login with a form just won’t do.
												HTTP Basic authentication is one way to authenticate a user to an application directly in the HTTP request itself. You may have seen HTTP Basic authentication before.
												
													protected void configure(HttpSecurity http) throws Exception {
															http.formLogin().loginPage("/login")
															.and()
															.httpBasic().realmName("Spittr")
															.and()...
															
											SPRING BACKEND

												All Spring JDBC exceptions are rooted with DataAccessException and what makes this Exception special is that it is an UNCHECKED EXCEPTION!!!!
												
												Templating data access 
													Spring use the Template Method Pattern
													
												JNDI datasources
													XML
														<jee:jndi-lookup id="dataSource" jndi-name="/jdbc/SpitterDS" resource-ref="true" />
													Java Config
														 @Bean
														public JndiObjectFactoryBean dataSource() {
															JndiObjectFactoryBean jndiObjectFB = new JndiObjectFactoryBean();
															jndiObjectFB.setJndiName("jdbc/SpittrDS");
															jndiObjectFB.setResourceRef(true);
															jndiObjectFB.setProxyInterface(javax.sql.DataSource.class);
															return jndiObjectFB;
														}
														
												Pooled DataSource
													XML
														<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" p:driverClassName="org.h2.Driver"
															p:url="jdbc:h2:tcp://localhost/~/spitter" p:username="sa" p:password="" p:initialSize="5" p:maxActive="10" />
													Java Config
														@Bean
														public BasicDataSource dataSource() {
															BasicDataSource ds = new BasicDataSource();
															ds.setDriverClassName("org.h2.Driver");
															ds.setUrl("jdbc:h2:tcp://localhost/~/spitter");
															ds.setUsername("sa");
															ds.setPassword("");
															ds.setInitialSize(5);
															ds.setMaxActive(10);
															return ds;
														}
														
												JDBC Driver-Based 		
													Spring offers three such data-source classes to choose from :
														 DriverManagerDataSource—Returns a new connection every time a connection is requested. Unlike DBCP’s BasicDataSource, the connections provided by DriverManagerDataSource aren’t pooled.
														 SimpleDriverDataSource—Works much the same as DriverManagerDataSource except that it works with the JDBC driver directly to overcome class loading issues that may arise in certain environments, such as in an OSGi container.
														 SingleConnectionDataSource—Returns the same connection every time a connection is requested. Although SingleConnectionDataSource isn’t exactly a pooled data source, you can think of it as a data source with a pool of exactly one connection.	
												
												
												
													
													
												JDBC TEMPLATE
													@Bean
													public JdbcTemplate jdbcTemplate(DataSource dataSource) {
														return new JdbcTemplate(dataSource);
													}
													
													@Repository
													public class JdbcSpitterRepository implements SpitterRepository {
														private JdbcOperations jdbcOperations;
														
														@Inject
														public JdbcSpitterRepository(JdbcOperations jdbcOperations) {
															this.jdbcOperations = jdbcOperations;
														}
														...
													}

													@Bean
													public SpitterRepository spitterRepository(JdbcTemplate jdbcTemplate) {
														return new JdbcSpitterRepository(jdbcTemplate);
													}
													
													SELECT STATEMENT
													
														public Spitter findOne(long id) {
															return jdbcOperations.queryForObject(SELECT_SPITTER_BY_ID, new SpitterRowMapper(),id);
														}
														
														private static final class SpitterRowMapper implements RowMapper<Spitter> {
															public Spitter mapRow(ResultSet rs, int rowNum) throws SQLException {
																return new Spitter(
																	rs.getLong("id"),
																	rs.getString("username"),
																	rs.getString("password"),
																	rs.getString("fullName"),
																	rs.getString("email"),
																	rs.getBoolean("updateByEmail"));
															}
														}
														
														Because the RowMapper interface only declares the addRow() method, it fits the bill for a functional interface. This means that if you’re developing your application using
														Java 8, you can express the RowMapper implementation with a lambda instead of with a concrete class implementation.
														
														public Spitter findOne(long id) {
															return jdbcOperations.queryForObject(SELECT_SPITTER_BY_ID,
															(rs, rowNum) -> {
																return new Spitter(
																rs.getLong("id"),
																rs.getString("username"),
																rs.getString("password"),
																rs.getString("fullName"),
																rs.getString("email"),
																rs.getBoolean("updateByEmail"));
															},
															id);
														}
														
														Alternatively, you can use Java 8 method references to define the mapping in a separate method:
														public Spitter findOne(long id) {
															return jdbcOperations.queryForObject(SELECT_SPITTER_BY_ID, this::mapSpitter, id);
															}
															
														private Spitter mapSpitter(ResultSet rs, int row) throws SQLException {
															return new Spitter(
															rs.getLong("id"),
															rs.getString("username"),
															rs.getString("password"),
															rs.getString("fullName"),
															rs.getString("email"),
															rs.getBoolean("updateByEmail"));
														}
														
											
										