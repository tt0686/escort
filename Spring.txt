Lightweight and minimally invasive development with POJOs -> Other frameworks (Struts,EJB 2.1) lock us by forcing us to extend one of their classes or implement one of their interfaces.
Loose coupling through DI and interface orientation
Declarative programming through aspects and common conventions
Eliminating boilerplate code with aspects and templates

Dependency Injection
	Traditionally each object is responsible for obtaining its own references to the objects it collaborates with(its dependencies).
	
	package com.springinaction.knights;
	public class DamselRescuingKnight implements Knight {
		private RescueDamselQuest quest;
		
		public DamselRescuingKnight() {
			this.quest = new RescueDamselQuest();
		}
		
		public void embarkOnQuest() {
			quest.embark();
		}
	}
	
	DamselRescuingKnight creates its own quest, a RescueDamselQuest, in the constructor. This makes a DamselRescuingKnight tightly coupled to a Rescue-DamselQuest and severely limits the knight’s quest-embarking repertoire.
	With DI, objects are given their dependencies at creation time by some third party that coordinates each object in the system.
	
	public class BraveKnight implements Knight {
		private Quest quest;
			public BraveKnight(Quest quest) {
				this.quest = quest;
			}
			public void embarkOnQuest() {
				quest.embark();
			}
	}
	
	As you can see, BraveKnight, unlike DamselRescuingKnight, doesn’t create his own quest. Instead, he’s given a quest at construction time as a constructor argument. This is a type of DI known as constructor injection.
	
	How wiring components together ?
		XML
			<?xml version="1.0" encoding="UTF-8"?>
				<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans
							http://www.springframework.org/schema/beans/spring-beans.xsd">
					<bean id="knight" class="com.springinaction.knights.BraveKnight">
						<constructor-arg ref="quest" />
					</bean>
					<bean id="quest" class="com.springinaction.knights.SlayDragonQuest">
						<constructor-arg value="#{T(System).out}" />
					</bean>
				</beans>
		JAVA
			@Configuration
			public class KnightConfig {
				@Bean
				public Knight knight() {
					return new BraveKnight(quest());
				}
				@Bean
				public Quest quest() {
					return new SlayDragonQuest(System.out);
				}
			}
			
			In Spring application,an APPLICATION CONTEXT loads bean definitions and wires them together!!!
			Several implementations of its application context,eac primarily differing only in how it loads its configuration.
				ClassPathXmlApplicationContext -> LOADS ONE OR MORE XML FILES LOCATED IN THE APPLICATION CLASSPATH!!!
				
				public class KnightMain {
					public static void main(String[] args) throws Exception {
					ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("META-INF/spring/knight.xml");
					Knight knight = context.getBean(Knight.class);
					knight.embarkOnQuest();
					context.close();
					}
				}
				
				AOP
				
				public class Minstrel {
					private PrintStream stream;
					public Minstrel(PrintStream stream) {
						this.stream = stream;
					}
					public void singBeforeQuest() {
						stream.println("Fa la la, the knight is so brave!");
					}
					public void singAfterQuest() {
						stream.println("Tee hee hee, the brave knight " +"did embark on a quest!");
					}
				}
				
				<?xml version="1.0" encoding="UTF-8"?>
				<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans
							http://www.springframework.org/schema/beans/spring-beans.xsd">
					<bean id="knight" class="com.springinaction.knights.BraveKnight">
						<constructor-arg ref="quest" />
					</bean>
					<bean id="quest" class="com.springinaction.knights.SlayDragonQuest">
						<constructor-arg value="#{T(System).out}" />
					</bean>
					
					<bean id="minstrel" class="com.springinaction.knights.Minstrel">
						<constructor-arg value="#{T(System).out}" />
					</bean>
					
					<aop:config>
						<aop:aspect ref="minstrel">
							<aop:pointcut id="embark" expression="execution(* *.embarkOnQuest(..))"/>
							<aop:before pointcut-ref="embark" method="singBeforeQuest"/>
							<aop:after pointcut-ref="embark" method="singAfterQuest"/>
						</aop:aspect>
					</aop:config>
				</beans>
				
				IN A SPRING-BASED APPLICATION, YOUR APPLICATION OBJECTS LIVE IN THE SPRING CONTAINER!!!!!!
				Spring container implementation can be catagorized into two distinct types :
					1 BEAN FACTORIES
					2 APPLICATION CONTEXTS
						AnnotationConfigApplicationContext
							If we'd rather load your application context from a Java configuration :
									ApplicationContext context = new AnnotationConfigApplicationContext(com.springinaction.knights.config.KnightConfig.class);
						AnnotationConfigWebApplicationContext
						ClassPathXmlApplicationContext
							ApplicationContext context = new ClassPathXmlApplicationContext("knight.xml");
						FileSystemXmlApplicationContext
							ApplicationContext context = new FileSystemXmlApplicationContext("c:/knight.xml");
						XmlWebApplicationContext
						
					Bean Lifecycle
						Instantiate
						Populate properties
						BeanNameAware (if bean implement BeanNameAware interface) the method setBeanName is called
							setBeanName() -> Spring passes the bean's ID
						BeanFactoryAware
							setBeanFactory -> Passes bean factory itseld
						ApplicationContextAware
							setApplicationContext()
						BeanPostProcessor
							postProcessBeforeInitialization
						InitializingBean
							afterPropertiesSet()
							IF THE BEAN WAS DECLARED WITH AN initMethod THEN THE SPECIFIED INITIALIZATION IS CALLED
						BeanPostProcessor
							postProcessorAfterInitialization()
						---------------------------------------------->BEAN READY TO USE<----------------------------------------------------------------------
						DisposableBean
							destroy()
							IF THE BEAN WAS DECLARED WITH AN destroy-method THEN THE SPECIFIED METHOD IS CALLED
							
				SPRING WIRING OPTIONS
					XML
					JAVA
					AUTOMATIC WIRING
						@Component(@Named) -> Identifies a class as a component and serves as a clue to Spting that a bean should be created for the class.
						
						@Configuration
						@ComponentScan()packages to be scanned ->("soundsystem") || (basePacjages={"soudsystem","video"}) || basePackageClasses={CDPlayer.class,DVDPlayer.class}
										We could create an empty marker interface in the packages to be scanned.
							public class CDPlayerConfig {
						}
						
							@ComponentScan will default to scanning the same package as the configuration class!!!
							In XML 
									<context:component-scan base-package="soundsystem" />
									
									
						@Autowired(required=false) || @Inject
						
						@Component
						public class CDPlayer implements MediaPlayer {
							private CompactDisc cd;
							
							@Autowired
							public CDPlayer(CompactDisc cd) {
								this.cd = cd;
							}
							public void play() {
								cd.play();
							}
						}
						
						IF WE WANT TO WIRE COMPONENTS FROM SOME THIRD-PARTY LIBRARY INTO OUR APPLICATION ,BECAUSE WE DO NOT HAVE THE SOURCE CODE FOR THAT LIBRARY , THERE IS NO OPPORTUNITY TO ANNOTATE ITS CLASSES
						WITH @COMPONENT AND @AUTOWIRED.
						
						JAVA EXPLICIT CONFIG
							@Configuration
							public class CDPlayerConfig {
								@Bean(name="otherName")
								public CompactDisc sgtPeppers() {
									return new SgtPeppers();
								}
								
								@Bean
								public CDPlayer anotherCDPlayer() {
									return new CDPlayer(sgtPeppers());   IMPORTANT : The sgtPeppers() method will return the same instance(BY DEFAULT,ALL BEANS IN SPRING ARE SINGLETONS AND THERE IS NO REASON WE
								}												     NEED TO CREATE A DUPLICATE INSTANCE, SO SPRING INTERCEPTS THE CALL TO sgtPeppers() AND MAKES SURE THAT WHAT IS RETURNED IS THE 
							                                                         SPRING BEAN THAT WAS CREATED WHEN SPRING ITSELF CALLED sgtPeppers() TO CREATE THE CompactDisc BEAN)
							
								//Alternative
								@Bean
								public CDPlayer cdPlayer(CompactDisc compactDisc) {
									return new CDPlayer(compactDisc);                -> Best choice because it does not depend on the CompactDisc bean being declared in the same configuration class.It could be 
								}                                                       discovered by component scanning or declared in XML
								
								//Setter method
								@Bean
								public CDPlayer cdPlayer(CompactDisc compactDisc) {
									CDPlayer cdPlayer = new CDPlayer(compactDisc);
									cdPlayer.setCompactDisc(compactDisc);
									return cdPlayer;
								}
							
							}
						XML
							<bean class="soundsystem.SgtPeppers" />
							<bean id="compactDisc" class="soundsystem.SgtPeppers" />
								Constructor Injection
									1:The <constructor-arg> element
									2:Using the c-namespace introduced in Spring 3.0
									
									<bean id="cdPlayer" class="soundsystem.CDPlayer">
										<constructor-arg ref="compactDisc" />
									</bean>
									<bean id="cdPlayer" class="soundsystem.CDPlayer" c:cd-ref="compactDisc" /> (cd -> constructor argument name |-ref -> naming convention that indicates to Spring that we are wiring 
									                                                                                                             a reference to a bean)
									Alternative
									<bean id="cdPlayer" class="soundsystem.CDPlayer" c:_0-ref="compactDisc" />
									<bean id="cdPlayer" class="soundsystem.CDPlayer"c:_-ref="compactDisc" /> -> JUST ONE CONSTRUCTOR ARGUMENT
									
							LITERAL VALUES
								
								public class BlankDisc implements CompactDisc {
									private String title;
									private String artist;
									
									public BlankDisc(String title, String artist) {
										this.title = title;
										this.artist = artist;
									}
									public void play() {
										System.out.println("Playing " + title + " by " + artist);
									}
								}
							
								<bean id="compactDisc" class="soundsystem.BlankDisc">
									<constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" />   -> INSTEAD OF "REF" WE USE THE "VALUE" ATTRIBUTE
									<constructor-arg value="The Beatles" />
								</bean>
								
								<bean id="compactDisc" class="soundsystem.BlankDisc" c:_title="Sgt. Pepper's Lonely Hearts Club Band" c:_artist="The Beatles" />
									<bean id="compactDisc" class="soundsystem.BlankDisc" c:_0="Sgt. Pepper's Lonely Hearts Club Band" c:_1="The Beatles" />
							
							WIRING COLLECTIONS
								public class BlankDisc implements CompactDisc {
									private String title;
									private String artist;
									private List<String> tracks;
									
									public BlankDisc(String title, String artist, List<String> tracks) {
										this.title = title;
										this.artist = artist;
										this.tracks = tracks;
									}
									
									public void play() {
										System.out.println("Playing " + title + " by " + artist);
										for (String track : tracks) {
											System.out.println("-Track: " + track);
										}
									}
								}
								
								<bean id="compactDisc" class="soundsystem.BlankDisc">
									<constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" />
									<constructor-arg value="The Beatles" />
									<constructor-arg>
										<list>
											<value>Sgt. Pepper's Lonely Hearts Club Band</value>  -> IF WE WANT TO REFERENCE A BEAN <ref bean="" /> INSTEAD
											<value>With a Little Help from My Friends</value>
											<value>Lucy in the Sky with Diamonds</value>
											<value>Getting Better</value>
											<value>Fixing a Hole</value>
										</list>
									</constructor-arg>
								</bean>
								
								SETTING PROPERTIES
									public class CDPlayer implements MediaPlayer {
										private CompactDisc compactDisc;
										
										@Autowired
										public void setCompactDisc(CompactDisc compactDisc) {
											this.compactDisc = compactDisc;
										}
										public void play() {
											compactDisc.play();
										}
									}
									
									<bean id="cdPlayer" class="soundsystem.CDPlayer">
										<property name="compactDisc" ref="compactDisc" />
									</bean>
									
									<bean id="cdPlayer" class="soundsystem.CDPlayer" p:compactDisc-ref="compactDisc" />
									
									PROPERTIES THROUGH LITERAL VALUES
										public class BlankDisc implements CompactDisc {
											private String title;
											private String artist;
											private List<String> tracks;
											
											public void setTitle(String title) {
												this.title = title;
											}
											
											public void setArtist(String artist) {
												this.artist = artist;
											}
											
											public void setTracks(List<String> tracks) {
												this.tracks = tracks;
											}
											
											public void play() {
												System.out.println("Playing " + title + " by " + artist);
												for (String track : tracks) {
													System.out.println("-Track: " + track);
												}
											}
										}

										<bean id="compactDisc" class="soundsystem.BlankDisc">
											<property name="title" value="Sgt. Pepper's Lonely Hearts Club Band" />
											<property name="artist" value="The Beatles" />
											<property name="tracks">
												<list>
												<value>Sgt. Pepper's Lonely Hearts Club Band</value>
												<value>With a Little Help from My Friends</value>
												<value>Lucy in the Sky with Diamonds</value>
												<value>Getting Better</value>
												<value>Fixing a Hole</value>
												</list>
											</property>
										</bean>
									
										TO USE THE C:NAMESPACE OR P:NAMESPACE WITH LIST USE THE UTIL-NAMESPACE WHICH CREATES A LIST BEAN!!!
										
								MIXING CONFIGURATION
									@Configuration
									public class CDConfig {
										@Bean
										public CompactDisc compactDisc() {
											return new SgtPeppers();
										}
									}
									
									@Configuration
									@Import(CDConfig.class)
									public class CDPlayerConfig {
										@Bean
										public CDPlayer cdPlayer(CompactDisc compactDisc) {
											return new CDPlayer(compactDisc);
										}
									}
									
															OR
															
									@Configuration
									@Import({CDPlayerConfig.class, CDConfig.class})
									public class SoundSystemConfig {
									}


									ONE OF THE CONFIGURATIONS ARE IN XML
										<bean id="compactDisc" class="soundsystem.BlankDisc" c:_0="Sgt. Pepper's Lonely Hearts Club Band" c:_1="The Beatles">
											<constructor-arg>
											<list>
												<value>Sgt. Pepper's Lonely Hearts Club Band</value>
												<value>With a Little Help from My Friends</value>
												<value>Lucy in the Sky with Diamonds</value>
												<value>Getting Better</value>
												<value>Fixing a Hole</value>
											</list>
											</constructor-arg>
										</bean>
										
										@Configuration
										@Import(CDPlayerConfig.class)
										@ImportResource("classpath:cd-config.xml")
										public class SoundSystemConfig {
										}
										
										FROM XML
											<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c"
													xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
												<import resource="cd-config.xml" />
												<bean id="cdPlayer" class="soundsystem.CDPlayer" c:cd-ref="compactDisc" />
											</beans>
											
											<?xml version="1.0" encoding="UTF-8"?>
											<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c"
													xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
												<bean class="soundsystem.CDConfig" />
												<bean id="cdPlayer" class="soundsystem.CDPlayer" c:cd-ref="compactDisc" />
											</beans>
											
											Because the <import> element only works to import other XML configuration files and there is not an XML element whose job it is to import JavaConfig classes we use
											the <bean> element!!!
											
								PROFILES
									We can develop three different DataSource beans to three different environments(Dev/QA/PRD)
									One way is to configure each bean in a separate configuration class(or XML) and them make a a build-time decision(perhaps using Maven profiles) about which to compile.
									Using PROFILE BEANS
									
									@Configuration
									@Profile("dev")
									public class DevelopmentProfileConfig {
										@Bean(destroyMethod="shutdown")
										public DataSource dataSource() {
										return new EmbeddedDatabaseBuilder()
											.setType(EmbeddedDatabaseType.H2)
											.addScript("classpath:schema.sql")
											.addScript("classpath:test-data.sql")
											.build();
										}
									}
									
									@Configuration
									public class DataSourceConfig {
										@Bean(destroyMethod="shutdown")                        -> METHOD LEVEL
										@Profile("dev")
										public DataSource embeddedDataSource() {
										return new EmbeddedDatabaseBuilder()
										.setType(EmbeddedDatabaseType.H2)
										.addScript("classpath:schema.sql")
										.addScript("classpath:test-data.sql")
										.build();
										}
										
									XML
									 ...profile="dev">
									 
									ACTIVATING PROFILES
										spring.profiles.active
										spring.profiles.default
										
											There are several ways to set these properties:
												As initialization parameters on DispatcherServlet
												As context parameters of a web application
												As JNDI entries
												As environment variables
												As JVM system properties
												Using the @ActiveProfiles annotation on an integration test class
									
									CONDITIONAL BEANS
										@Bean
										@Conditional(MagicExistsCondition.class)
										public MagicBean magicBean() {
											return new MagicBean();
										}
										
											public interface Condition {
												boolean matches(ConditionContext ctxt,AnnotatedTypeMetadata metadata);
											}
											
											public class MagicExistsCondition implements Condition {
												public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
													Environment env = context.getEnvironment();
													return env.containsProperty("magic");
												}
											}
											
											public interface ConditionContext {
												BeanDefinitionRegistry getRegistry(); -> Check for bean definitions
												ConfigurableListableBeanFactory getBeanFactory(); -> Check for the presence of beans, and even dig into bean properties
												Environment getEnvironment(); -> Check for the presence and values of environment variables
												ResourceLoader getResourceLoader(); -> Read and inspect the contents of resources loaded via the ResourceLoader
												ClassLoader getClassLoader(); -> Load and check for the presence of classes via the ClassLoader
											}
											
											public interface AnnotatedTypeMetadata {
												boolean isAnnotated(String annotationType);
												Map<String, Object> getAnnotationAttributes(String annotationType);
												Map<String, Object> getAnnotationAttributes(
												String annotationType, boolean classValuesAsString);
												MultiValueMap<String, Object> getAllAnnotationAttributes(
												String annotationType);
												MultiValueMap<String, Object> getAllAnnotationAttributes(
												String annotationType, boolean classValuesAsString);
											}
											
											The class given to @Conditional can be any type that implements the Condition interface.
											
											@Primary
											primary="true"
											
											The @Qualifier annotation is the main way to work with qualifiers. It can be applied alongside @Autowired or @Inject at the point of injection to specify which
											bean you want to be injected.
											
											@Autowired
											@Qualifier("iceCream")
											public void setDessert(Dessert dessert) {
												this.dessert = dessert;
											}
											
											Problem is that you specified a qualifier on setDessert() that is tightly coupled to the class name of the bean being injected.
											Instead of relying on the bean ID as the qualifier, you can assign your own qualifier to a bean.
											
											@Component
											@Qualifier("cold")
											public class IceCream implements Dessert { ... }
											
											@Target({ElementType.CONSTRUCTOR, ElementType.FIELD,ElementType.METHOD, ElementType.TYPE})
											@Retention(RetentionPolicy.RUNTIME)
											@Qualifier
											public @interface Cold { }
											
									SCOPING BEANS
										By default, all beans created in the Spring application context are created as singletons.
										That is to say, no matter how many times a given bean is injected into other beans, it’s always the same instance that is injected each time.
											Singleton : One instance of the bean is created for the entire application.
											Prototype : One instance of the bean is created every time the bean is injected into or retrieved from the Spring application context.
											Session : In a web application, one instance of the bean is created for each session.
											Request : In a web application, one instance of the bean is created for each request.
											
											@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
												scope="prototype"/>
												
											@Scope(value=WebApplicationContext.SCOPE_SESSION,proxyMode=ScopedProxyMode.INTERFACES)
											
												Problem:
													@Component
													public class StoreService {
													
														@Autowired
														public void setShoppingCart(ShoppingCart shoppingCart) {
														this.shoppingCart = shoppingCart;
														}
														...
													}
													
													ShoppingCart is a session scope bean.
													Because StoreService is a singleton bean, it will be created as the Spring application context is loaded. 
													As it's created, Spring will attempt to inject ShoppingCart into the setShoppingCart() method. But the ShoppingCart bean, being session scoped,
													doesn't exist yet. There won't be an instance of ShoppingCart until a user comes along and a session is created.
													Moreover, there will be many instances of ShoppingCart: one per user. You don't want Spring to inject just any single instance of ShoppingCart into StoreService. 
													You want StoreService to work with the ShoppingCart instance for whichever session happens to be in play when StoreService needs to work with the shopping cart.
													Instead of injecting the actual ShoppingCart bean into StoreService, Spring should inject a proxy to the ShoppingCart bean. 
													This proxy will expose the same methods as ShoppingCart so that for all StoreService knows, it is the shopping cart. 
													But when StoreService calls methods on ShoppingCart, the proxy will lazily resolve it and delegate the call to the actual session-scoped Shopping-Cart bean.
													As configured, proxyMode is set to ScopedProxyMode.INTERFACES, indicating that the proxy should implement the ShoppingCart interface and delegate to the implementation bean.
													This is fine (and the most ideal proxy mode) as long as ShoppingCart is an interface and not a class. But if ShoppingCart is a concrete class, there’s no way Spring can
													create an interface-based proxy. Instead, it must use CGLib to generate a class-based proxy. 
													So, if the bean type is a concrete class, you must set proxyMode to ScopedProxy- Mode.TARGET_CLASS to indicate that the proxy should be generated as an extension of
													the target class.
											
											  XML
												scope="session">
											    <aop:scoped-proxy />
											    <aop:scoped-proxy proxy-target-class="false" />
												
											AVOID HARD-CODED VALUES
												Placeholders
												SPEL
												
												@PropertySource("classpath:/com/soundsystem/app.properties") -> Declare a property source
												
												@Autowired
												Environment env;
												
												env.getProperty("disc.title")
												
												XML PLACEHOLDERS
												<bean id="sgtPeppers" class="soundsystem.BlankDisc" c:_title="${disc.title}" c:_artist="${disc.artist}" />
												
												COMPONENT-SCANNING
													public BlankDisc(@Value("${disc.title}") String title,@Value("${disc.artist}") String artist) {
														this.title = title;
														this.artist = artist;
													}
												
												In order to use placeholder values, you must configure either a PropertyPlaceholder- Configurer bean or a PropertySourcesPlaceholderConfigurer bean.
												
												@Bean
												public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {
													return new PropertySourcesPlaceholderConfigurer();
												}
												
												WHY IS A BEAN DECLARED STATIC ?
													SPECIAL CONSIDERATION MUST BE TAKEN for @Bean methods that return Spring BeanFactoryPostProcessor types!!
													BFPP objects must be instantiated very early in the container lifecycle,they can interfere with processing of annotations such as 
													@Autowire ,@Value .By making these methods as static,it can be invoked without causing instantiation of its declaring @Configuration class,
													thus avoiding the above-mentioned lifecycle conflits!!!
													
												In XML 
													<context:property-placeholder />
													
												SPEL
													public BlankDisc(@Value("#{systemProperties['disc.title']}") String title,@Value("#{systemProperties['disc.artist']}") String artist) {
														this.title = title;
														this.artist = artist;
													}
													
													<bean id="sgtPeppers" class="soundsystem.BlankDisc" c:_title="#{systemProperties['disc.title']}" c:_artist="#{systemProperties['disc.artist']}" />
													
													Call methods
														#{artistSelector.selectArtist()}
														To guard against a NullPointerException, you can use the type-safe operator:
														#{artistSelector.selectArtist()?.toUpperCase()}
														
														The key to working with class-scoped methods and constants in SpEL is to use the T() operator.
															T(java.lang.Math)
														The result of the T() operator, as shown here, is a Class object that represents java.lang.Math.
														
															#{jukebox.songs.?[artist eq 'Aerosmith']}
															#{jukebox.songs.^[artist eq 'Aerosmith']}
															#{jukebox.songs.![title]}
															
										AOP
											Spring ascpects types
												Before
												After
												After-Returning
												After-Throwing
												Around
											
											Introductions
												An introduction allows us to add new methods or attributes to existing classes.
											Weaving
												Is the process of applying aspects to a target object to create a new proxied object.The aspects are woven into the target object at the specified join points.
													Compile Time : Requires special compiler(Aspect's weaving compiler)
													Class Load time : Special ClassLoader
													RunTime : Aspects we woven in sometime during the execution of the application.
													
													Spring’s support for AOP comes in four styles:
														Classic Spring proxy-based AOP
														Pure-POJO aspects
														@AspectJ annotation-driven aspects
														Injected AspectJ aspects (available in all versions of Spring)
														
													Spring AOP is built around dynamic proxies. Consequently, Spring’s AOP support is limited to method interception.
													
													execution(* concert.Performance.perform(..))
													          |           |           |      |->Taking any arguments
															  |           |           |->The method
															  |           |->The type that the method belongs to
															  |->Return any type
															  
													execution(* concert.Performance.perform(..)) && within(concert.*)) LIMIT THE MATCH TO ONLY THE CONCERT PACKAGE
													
													@Aspect
													public class Audience {
														@Pointcut("execution(** concert.Performance.perform(..))")
														public void performance() {}
														
														@Before("performance()")
														public void silenceCellPhones() {
															System.out.println("Silencing cell phones");
														}
														
														@Before("performance()")
														public void takeSeats() {
															System.out.println("Taking seats");
														}
														
														@AfterReturning("performance()")
														public void applause() {
															System.out.println("CLAP CLAP CLAP!!!");
														}
														
														@AfterThrowing("performance()")
														public void demandRefund() {
															System.out.println("Demanding a refund");
														}
													}
													
													@Bean
													public Audience audience() {
														return new Audience();
													}
													
													JAVA CONFIG
														@Configuration
														@EnableAspectJAutoProxy
														@ComponentScan
														public class ConcertConfig {
														
															@Bean
															public Audience audience() {
																return new Audience();
															}
														}
														
													XML
														
															<context:component-scan base-package="concert" />
															<aop:aspectj-autoproxy />
															<bean class="concert.Audience" />
														</beans>
														
														In XML
												<aop:config>
													<aop:aspect ref="audience">
														<aop:before pointcut="execution(** concert.Performance.perform(..))" method="silenceCellPhones"/>
														<aop:before pointcut="execution(** concert.Performance.perform(..))" method="takeSeats"/>
														<aop:after-returning pointcut="execution(** concert.Performance.perform(..))" method="applause"/>
														<aop:after-throwing pointcut="execution(** concert.Performance.perform(..))" method="demandRefund"/>
													</aop:aspect>
												</aop:config>
												
												THIS MAKES SPRING'S XML CONFIGURATION FOR AOP A HANDY WAY TO USE TYPES DEFINED IN THIRD-PARTY LIBRARIES AS ADVICE, EVEN THOUGH WE CAN'T ANNOTATE THEM WITH ASPECTJ ASPECTS.
												
												<aop:config>
													<aop:aspect ref="audience">
														<aop:pointcut id="performance" expression="execution(** concert.Performance.perform(..))" />
														<aop:before pointcut-ref="performance" method="silenceCellPhones"/>
														<aop:before pointcut-ref="performance" method="takeSeats"/>
														<aop:after-returning pointcut-ref="performance" method="applause"/>
														<aop:after-throwing pointcut-ref="performance" method="demandRefund"/>
													</aop:aspect>
												</aop:config>
														
												REWRITING WITH AROUND
													@Aspect
													public class Audience {
														@Pointcut("execution(** concert.Performance.perform(..))")
														public void performance() {}
														
														@Around("performance()")
														public void watchPerformance(ProceedingJoinPoint jp) {
															try {
																System.out.println("Silencing cell phones");
																System.out.println("Taking seats");
																jp.proceed();
																System.out.println("CLAP CLAP CLAP!!!");
															} catch (Throwable e) {
																System.out.println("Demanding a refund");
															}
														}
													}
													
													Example with arguments
														@Pointcut(
									"execution(* soundsystem.CompactDisc.playTrack(int)) && args(trackNumber)")
									public void trackPlayed(int trackNumber) {}
									
									INTRODUCTIONS
										
											Adding new methods to Spring Beans.
											When a method on the introduced interface is called, the proxy delegates the call to some other object that provides the implementation of the new
											interface. Effectively, this gives you one bean whose implementation is split across multiple classes.
											
											@Aspect
											public class EncoreableIntroducer {
												@DeclareParents(value="concert.Performance+",defaultImpl=DefaultEncoreable.class)
												public static Encoreable encoreable;
											}
											
											
											
							SPRING MVC FRAMEWORK
							
								Request ------> DISPATCH SERVLET ----> HANDLER MAPPING ----> CONTROLLER -> MODEL & LOGICAL VIEW NAME ---> VIEW RESOLVER  -----> VIEW ---> RESPONSE
								
								
								Like most Javabased web frameworks, Spring MVC funnels requests through a single front controller servlet. A front controller is a common web application pattern where a single servlet
								delegates responsibility for a request to other components of an application to perform actual processing. In the case of Spring MVC, DispatcherServlet is the front controller.
								The DispatcherServlet’s job is to send the request on to a Spring MVC controller.
								A controller is a Spring component that processes the request. But a typical application may have several controllers, and DispatcherServlet needs some help deciding
								which controller to send the request to. So the DispatcherServlet consults one or more handler mappings C to figure out where the request’s next stop will be. The
								handler mapping pays particular attention to the URL carried by the request when making its decision.
								Once an appropriate controller has been chosen, DispatcherServlet sends the request on its merry way to the chosen controller D. At the controller, the request
								drops off its payload (the information submitted by the user) and patiently waits while the controller processes that information. (Actually, a well-designed controller performs
								little or no processing itself and instead delegates responsibility for the business logic to one or more service objects.)
								The logic performed by a controller often results in some information that needs to be carried back to the user and displayed in the browser. This information is
								referred to as the model. But sending raw information back to the user isn’t sufficient— it needs to be formatted in a user-friendly format, typically HTML. 
								For that, the information needs to be given to a view, typically a JavaServer Page (JSP).
								One of the last things a controller does is package up the model data and identify the name of a view that should render the output. It then sends the request, along
								with the model and view name, back to the DispatcherServlet. So that the controller doesn’t get coupled to a particular view, the view name.
								The DispatcherServlet consults a view resolver to map the logical view name to a specific view implementation, which may or may not be a JSP.
								
								Configure DispatchServlet in Java instead of the traditional web.xml
									Using the Servlet 3.0 specification , the servlet container looks for any classes in the classpath that implements the javax.servlet.ServletContainerInitializer interface,
									if they are found,they are used to configure the servlet container.
									Spring supplies an implementation of that interface called SpringServletContainerInitializer that,in turn,seeks out any classes that implement WebApplicationInitializer and 
									delegates to them for configuration.
									
									IN SPRING MVC THERE ARE TWO APPLICATION CONTEXT
										DispatcherServlet is expected to load beans containing web components such as controllers, view resolvers, and handler mappings, ContextLoaderListener is
										expected to load the other beans in your application. These beans are typically the middle-tier and data-tier components that drive the back end of the application.
										Under the covers, AbstractAnnotationConfigDispatcherServletInitializer creates both a DispatcherServlet and a ContextLoaderListener. The @Configuration
										classes returned from getServletConfigClasses() will define beans for DispatcherServlet’s application context. Meanwhile, the @Configuration class’s returned 
										getRootConfigClasses() will be used to configure the application context created by ContextLoaderListener.
										
										@Configuration
										@EnableWebMvc
										@ComponentScan("spitter.web")
										public class WebConfig extends WebMvcConfigurerAdapter {
										
											@Bean
											public ViewResolver viewResolver() {
												InternalResourceViewResolver resolver = new InternalResourceViewResolver();
												resolver.setPrefix("/WEB-INF/views/");
												resolver.setSuffix(".jsp");
												resolver.setExposeContextBeansAsAttributes(true);
												return resolver;
											}
											
											@Override
											public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
												configurer.enable();
											}
										}
										
										WebConfig class extends WebMvcConfigurerAdapter and overrides its configureDefaultServletHandling() method. By calling enable() on the given
										DefaultServletHandlerConfigurer, you’re asking DispatcherServlet to forward requests for static resources to the servlet container’s default servlet and not to try to
										handle them itself.
										
										@Component ===== @Controller
										
										@Controller
										public class HomeController {
											@RequestMapping(value="/", method=GET)
											public String home() {
												return "home";
											}
										}
										
										TEST SPRING MVC CONTROLLERS
											public class HomeControllerTest {
												@Test
												public void testHomePage() throws Exception {
													HomeController controller = new HomeController();
													MockMvc mockMvc = standaloneSetup(controller).build();
													mockMvc.perform(get("/")).andExpect(view().name("home"));
												}
											}
											
											@Test
											public void shouldShowRecentSpittles() throws Exception {
												List<Spittle> expectedSpittles = createSpittleList(20);
												SpittleRepository mockRepository = mock(SpittleRepository.class);
												when(mockRepository.findSpittles(Long.MAX_VALUE, 20)).thenReturn(expectedSpittles);
												SpittleController controller = new SpittleController(mockRepository);
												SpittleController controller = new SpittleController(mockRepository);
												MockMvc mockMvc = standaloneSetup(controller).setSingleView(new InternalResourceView("/WEB-INF/views/spittles.jsp")).build();
												mockMvc.perform(get("/spittles")).andExpect(view().name("spittles")).andExpect(model().attributeExists("spittleList")).andExpect(model().attribute("spittleList",hasItems(expectedSpittles.toArray())));
											}
											
											@Controller
											@RequestMapping("/spittles")
											public class SpittleController {
												private SpittleRepository spittleRepository;
												@Autowired
												public SpittleController(SpittleRepository spittleRepository) {
													this.spittleRepository = spittleRepository;
												}
												
												@RequestMapping(method=RequestMethod.GET)
												public String spittles(Model model) {
													model.addAttribute(spittleRepository.findSpittles(Long.MAX_VALUE, 20));
													return "spittles";
												}
											}
											
											The Model is essentially a map (that is, a collection of key-value pairs) that will be handed off to the view so that the data can be rendered to the client. 
											When add-Attribute() is called without specifying a key, the key is inferred from the type of object being set as the value. In this case, because it’s a List<Spittle>, 
											the key will be inferred as spittleList.
											LIKEWISE, IF YOU’D PREFER TO WORK WITH A NON-SPRING TYPE, YOU CAN ASK FOR A JAVA .UTIL.MAP INSTEAD OF MODEL!!!
											
											Here’s another way to write the spittles() method:
											@RequestMapping(method=RequestMethod.GET)
											public List<Spittle> spittles() {
												return spittleRepository.findSpittles(Long.MAX_VALUE, 20));
											}
											
											When a handler method returns an object or a collection like this, the value returned is put into the model, and the model key is inferred from its type.
											As for the logical view name, it’s inferred from the request path. Because this method handles GET requests for /spittles, the view name is spittles (chopping off the leading slash).
											Now that there’s data in the model, how does the JSP access it? As it turns out, when the view is a JSP, the model data is copied into the request as request attributes.
											Therefore, the spittles.jsp file can use JavaServer Pages Standard Tag Library’s (JSTL).
											
											Spring MVC provides several ways that a client can pass data into a controller’s handler method. These include
												Query parameters
													@RequestMapping(method=RequestMethod.GET)
													public List<Spittle> spittles(@RequestParam(value="max",defaultValue=MAX_LONG_AS_STRING) long max,@RequestParam(value="count", defaultValue="20") int count) {
														return spittleRepository.findSpittles(max, count);
													}
												Form parameters
												Path variables
													Resource-oriented controllers
													The resource being identified (the Spittle) would be identified by the URL path, not by query parameters.
													A GET request for /spittles/12345 is better than one for /spittles/show?spittle_id=12345.
													To accommodate these path variables, Spring MVC allows for placeholders in an @RequestMapping path.
																										
													@RequestMapping(value="/{spittleId}", method=RequestMethod.GET)
													public String spittle(@PathVariable("spittleId") long spittleId,Model model) {
														model.addAttribute(spittleRepository.findOne(spittleId));
														return "spittle";
													}
													
													Because the method parameter name happens to be the same as the placeholder name, you can optionally omit the value parameter on @PathVariable.
												
												
													
											
										