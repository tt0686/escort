Lightweight and minimally invasive development with POJOs -> Other frameworks (Struts,EJB 2.1) lock us by forcing us to extend one of their classes or implement one of their interfaces.
Loose coupling through DI and interface orientation
Declarative programming through aspects and common conventions
Eliminating boilerplate code with aspects and templates

Dependency Injection
	Traditionally each object is responsible for obtaining its own references to the objects it collaborates with(its dependencies).
	
	package com.springinaction.knights;
	public class DamselRescuingKnight implements Knight {
		private RescueDamselQuest quest;
		
		public DamselRescuingKnight() {
			this.quest = new RescueDamselQuest();
		}
		
		public void embarkOnQuest() {
			quest.embark();
		}
	}
	
	DamselRescuingKnight creates its own quest, a RescueDamselQuest, in the constructor. This makes a DamselRescuingKnight tightly coupled to a Rescue-DamselQuest and severely limits the knight’s quest-embarking repertoire.
	With DI, objects are given their dependencies at creation time by some third party that coordinates each object in the system.
	
	public class BraveKnight implements Knight {
		private Quest quest;
			public BraveKnight(Quest quest) {
				this.quest = quest;
			}
			public void embarkOnQuest() {
				quest.embark();
			}
	}
	
	As you can see, BraveKnight, unlike DamselRescuingKnight, doesn’t create his own quest. Instead, he’s given a quest at construction time as a constructor argument. This is a type of DI known as constructor injection.
	
	How wiring components together ?
		XML
			<?xml version="1.0" encoding="UTF-8"?>
				<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans
							http://www.springframework.org/schema/beans/spring-beans.xsd">
					<bean id="knight" class="com.springinaction.knights.BraveKnight">
						<constructor-arg ref="quest" />
					</bean>
					<bean id="quest" class="com.springinaction.knights.SlayDragonQuest">
						<constructor-arg value="#{T(System).out}" />
					</bean>
				</beans>
		JAVA
			@Configuration
			public class KnightConfig {
				@Bean
				public Knight knight() {
					return new BraveKnight(quest());
				}
				@Bean
				public Quest quest() {
					return new SlayDragonQuest(System.out);
				}
			}
			
			In Spring application,an APPLICATION CONTEXT loads bean definitions and wires them together!!!
			Several implementations of its application context,eac primarily differing only in how it loads its configuration.
				ClassPathXmlApplicationContext -> LOADS ONE OR MORE XML FILES LOCATED IN THE APPLICATION CLASSPATH!!!
				
				public class KnightMain {
					public static void main(String[] args) throws Exception {
					ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("META-INF/spring/knight.xml");
					Knight knight = context.getBean(Knight.class);
					knight.embarkOnQuest();
					context.close();
					}
				}
				
				AOP
				
				public class Minstrel {
					private PrintStream stream;
					public Minstrel(PrintStream stream) {
						this.stream = stream;
					}
					public void singBeforeQuest() {
						stream.println("Fa la la, the knight is so brave!");
					}
					public void singAfterQuest() {
						stream.println("Tee hee hee, the brave knight " +"did embark on a quest!");
					}
				}
				
				<?xml version="1.0" encoding="UTF-8"?>
				<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans
							http://www.springframework.org/schema/beans/spring-beans.xsd">
					<bean id="knight" class="com.springinaction.knights.BraveKnight">
						<constructor-arg ref="quest" />
					</bean>
					<bean id="quest" class="com.springinaction.knights.SlayDragonQuest">
						<constructor-arg value="#{T(System).out}" />
					</bean>
					
					<bean id="minstrel" class="com.springinaction.knights.Minstrel">
						<constructor-arg value="#{T(System).out}" />
					</bean>
					
					<aop:config>
						<aop:aspect ref="minstrel">
							<aop:pointcut id="embark" expression="execution(* *.embarkOnQuest(..))"/>
							<aop:before pointcut-ref="embark" method="singBeforeQuest"/>
							<aop:after pointcut-ref="embark" method="singAfterQuest"/>
						</aop:aspect>
					</aop:config>
				</beans>
				
				IN A SPRING-BASED APPLICATION, YOUR APPLICATION OBJECTS LIVE IN THE SPRING CONTAINER!!!!!!
				Spring container implementation can be catagorized into two distinct types :
					1 BEAN FACTORIES
					2 APPLICATION CONTEXTS
						AnnotationConfigApplicationContext
							If we'd rather load your application context from a Java configuration :
									ApplicationContext context = new AnnotationConfigApplicationContext(com.springinaction.knights.config.KnightConfig.class);
						AnnotationConfigWebApplicationContext
						ClassPathXmlApplicationContext
							ApplicationContext context = new ClassPathXmlApplicationContext("knight.xml");
						FileSystemXmlApplicationContext
							ApplicationContext context = new FileSystemXmlApplicationContext("c:/knight.xml");
						XmlWebApplicationContext
						
					Bean Lifecycle
						Instantiate
						Populate properties
						BeanNameAware (if bean implement BeanNameAware interface) the method setBeanName is called
							setBeanName() -> Spring passes the bean's ID
						BeanFactoryAware
							setBeanFactory -> Passes bean factory itseld
						ApplicationContextAware
							setApplicationContext()
						BeanPostProcessor
							postProcessBeforeInitialization
						InitializingBean
							afterPropertiesSet()
							IF THE BEAN WAS DECLARED WITH AN initMethod THEN THE SPECIFIED INITIALIZATION IS CALLED
						BeanPostProcessor
							postProcessorAfterInitialization()
						---------------------------------------------->BEAN READY TO USE<----------------------------------------------------------------------
						DisposableBean
							destroy()
							IF THE BEAN WAS DECLARED WITH AN destroy-method THEN THE SPECIFIED METHOD IS CALLED
							
				SPRING WIRING OPTIONS
					XML
					JAVA
					AUTOMATIC WIRING
						@Component(@Named) -> Identifies a class as a component and serves as a clue to Spting that a bean should be created for the class.
						
						@Configuration
						@ComponentScan()packages to be scanned ->("soundsystem") || (basePacjages={"soudsystem","video"}) || basePackageClasses={CDPlayer.class,DVDPlayer.class}
										We could create an empty marker interface in the packages to be scanned.
							public class CDPlayerConfig {
						}
						
							@ComponentScan will default to scanning the same package as the configuration class!!!
							In XML 
									<context:component-scan base-package="soundsystem" />
									
									
						@Autowired(required=false) || @Inject
						
						@Component
						public class CDPlayer implements MediaPlayer {
							private CompactDisc cd;
							
							@Autowired
							public CDPlayer(CompactDisc cd) {
								this.cd = cd;
							}
							public void play() {
								cd.play();
							}
						}
						
						IF WE WANT TO WIRE COMPONENTS FROM SOME THIRD-PARTY LIBRARY INTO OUR APPLICATION ,BECAUSE WE DO NOT HAVE THE SOURCE CODE FOR THAT LIBRARY , THERE IS NO OPPORTUNITY TO ANNOTATE ITS CLASSES
						WITH @COMPONENT AND @AUTOWIRED.
						
						JAVA EXPLICIT CONFIG
							@Configuration
							public class CDPlayerConfig {
								@Bean(name="otherName")
								public CompactDisc sgtPeppers() {
									return new SgtPeppers();
								}
								
								@Bean
								public CDPlayer anotherCDPlayer() {
									return new CDPlayer(sgtPeppers());   IMPORTANT : The sgtPeppers() method will return the same instance(BY DEFAULT,ALL BEANS IN SPRING ARE SINGLETONS AND THERE IS NO REASON WE
								}												     NEED TO CREATE A DUPLICATE INSTANCE, SO SPRING INTERCEPTS THE CALL TO sgtPeppers() AND MAKES SURE THAT WHAT IS RETURNED IS THE 
							                                                         SPRING BEAN THAT WAS CREATED WHEN SPRING ITSELF CALLED sgtPeppers() TO CREATE THE CompactDisc BEAN)
							
								//Alternative
								@Bean
								public CDPlayer cdPlayer(CompactDisc compactDisc) {
									return new CDPlayer(compactDisc);                -> Best choice because it does not depend on the CompactDisc bean being declared in the same configuration class.It could be 
								}                                                       discovered by component scanning or declared in XML
								
								//Setter method
								@Bean
								public CDPlayer cdPlayer(CompactDisc compactDisc) {
									CDPlayer cdPlayer = new CDPlayer(compactDisc);
									cdPlayer.setCompactDisc(compactDisc);
									return cdPlayer;
								}
							
							}
						XML
							<bean class="soundsystem.SgtPeppers" />
							<bean id="compactDisc" class="soundsystem.SgtPeppers" />
								Constructor Injection
									1:The <constructor-arg> element
									2:Using the c-namespace introduced in Spring 3.0
									
									<bean id="cdPlayer" class="soundsystem.CDPlayer">
										<constructor-arg ref="compactDisc" />
									</bean>
									<bean id="cdPlayer" class="soundsystem.CDPlayer" c:cd-ref="compactDisc" /> (cd -> constructor argument name |-ref -> naming convention that indicates to Spring that we are wiring 
									                                                                                                             a reference to a bean)
									Alternative
									<bean id="cdPlayer" class="soundsystem.CDPlayer" c:_0-ref="compactDisc" />
									<bean id="cdPlayer" class="soundsystem.CDPlayer"c:_-ref="compactDisc" /> -> JUST ONE CONSTRUCTOR ARGUMENT
									
							LITERAL VALUES
								
								public class BlankDisc implements CompactDisc {
									private String title;
									private String artist;
									
									public BlankDisc(String title, String artist) {
										this.title = title;
										this.artist = artist;
									}
									public void play() {
										System.out.println("Playing " + title + " by " + artist);
									}
								}
							
								<bean id="compactDisc" class="soundsystem.BlankDisc">
									<constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" />   -> INSTEAD OF "REF" WE USE THE "VALUE" ATTRIBUTE
									<constructor-arg value="The Beatles" />
								</bean>
								
								<bean id="compactDisc" class="soundsystem.BlankDisc" c:_title="Sgt. Pepper's Lonely Hearts Club Band" c:_artist="The Beatles" />
									<bean id="compactDisc" class="soundsystem.BlankDisc" c:_0="Sgt. Pepper's Lonely Hearts Club Band" c:_1="The Beatles" />
							
							WIRING COLLECTIONS
								public class BlankDisc implements CompactDisc {
									private String title;
									private String artist;
									private List<String> tracks;
									
									public BlankDisc(String title, String artist, List<String> tracks) {
										this.title = title;
										this.artist = artist;
										this.tracks = tracks;
									}
									
									public void play() {
										System.out.println("Playing " + title + " by " + artist);
										for (String track : tracks) {
											System.out.println("-Track: " + track);
										}
									}
								}
								
								<bean id="compactDisc" class="soundsystem.BlankDisc">
									<constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" />
									<constructor-arg value="The Beatles" />
									<constructor-arg>
										<list>
											<value>Sgt. Pepper's Lonely Hearts Club Band</value>  -> IF WE WANT TO REFERENCE A BEAN <ref bean="" /> INSTEAD
											<value>With a Little Help from My Friends</value>
											<value>Lucy in the Sky with Diamonds</value>
											<value>Getting Better</value>
											<value>Fixing a Hole</value>
										</list>
									</constructor-arg>
								</bean>
								
								SETTING PROPERTIES
									public class CDPlayer implements MediaPlayer {
										private CompactDisc compactDisc;
										
										@Autowired
										public void setCompactDisc(CompactDisc compactDisc) {
											this.compactDisc = compactDisc;
										}
										public void play() {
											compactDisc.play();
										}
									}
									
									<bean id="cdPlayer" class="soundsystem.CDPlayer">
										<property name="compactDisc" ref="compactDisc" />
									</bean>
									
									<bean id="cdPlayer" class="soundsystem.CDPlayer" p:compactDisc-ref="compactDisc" />
									
									PROPERTIES THROUGH LITERAL VALUES
										public class BlankDisc implements CompactDisc {
											private String title;
											private String artist;
											private List<String> tracks;
											
											public void setTitle(String title) {
												this.title = title;
											}
											
											public void setArtist(String artist) {
												this.artist = artist;
											}
											
											public void setTracks(List<String> tracks) {
												this.tracks = tracks;
											}
											
											public void play() {
												System.out.println("Playing " + title + " by " + artist);
												for (String track : tracks) {
													System.out.println("-Track: " + track);
												}
											}
										}

										<bean id="compactDisc" class="soundsystem.BlankDisc">
											<property name="title" value="Sgt. Pepper's Lonely Hearts Club Band" />
											<property name="artist" value="The Beatles" />
											<property name="tracks">
												<list>
												<value>Sgt. Pepper's Lonely Hearts Club Band</value>
												<value>With a Little Help from My Friends</value>
												<value>Lucy in the Sky with Diamonds</value>
												<value>Getting Better</value>
												<value>Fixing a Hole</value>
												</list>
											</property>
										</bean>
									
										TO USE THE C:NAMESPACE OR P:NAMESPACE WITH LIST USE THE UTIL-NAMESPACE WHICH CREATES A LIST BEAN!!!
										
								MIXING CONFIGURATION
									@Configuration
									public class CDConfig {
										@Bean
										public CompactDisc compactDisc() {
											return new SgtPeppers();
										}
									}
									
									@Configuration
									@Import(CDConfig.class)
									public class CDPlayerConfig {
										@Bean
										public CDPlayer cdPlayer(CompactDisc compactDisc) {
											return new CDPlayer(compactDisc);
										}
									}
									
															OR
															
									@Configuration
									@Import({CDPlayerConfig.class, CDConfig.class})
									public class SoundSystemConfig {
									}


									ONE OF THE CONFIGURATIONS ARE IN XML
										<bean id="compactDisc" class="soundsystem.BlankDisc" c:_0="Sgt. Pepper's Lonely Hearts Club Band" c:_1="The Beatles">
											<constructor-arg>
											<list>
												<value>Sgt. Pepper's Lonely Hearts Club Band</value>
												<value>With a Little Help from My Friends</value>
												<value>Lucy in the Sky with Diamonds</value>
												<value>Getting Better</value>
												<value>Fixing a Hole</value>
											</list>
											</constructor-arg>
										</bean>
										
										@Configuration
										@Import(CDPlayerConfig.class)
										@ImportResource("classpath:cd-config.xml")
										public class SoundSystemConfig {
										}
										
										FROM XML
											<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c"
													xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
												<import resource="cd-config.xml" />
												<bean id="cdPlayer" class="soundsystem.CDPlayer" c:cd-ref="compactDisc" />
											</beans>
											
											<?xml version="1.0" encoding="UTF-8"?>
											<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c"
													xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
												<bean class="soundsystem.CDConfig" />
												<bean id="cdPlayer" class="soundsystem.CDPlayer" c:cd-ref="compactDisc" />
											</beans>
											
											Because the <import> element only works to import other XML configuration files and there is not an XML element whose job it is to import JavaConfig classes we use
											the <bean> element!!!
											
								PROFILES
									We can develop three different DataSource beans to three different environments(Dev/QA/PRD)
									One way is to configure each bean in a separate configuration class(or XML) and them make a a build-time decision(perhaps using Maven profiles) about which to compile.
									Using PROFILE BEANS
									
									@Configuration
									@Profile("dev")
									public class DevelopmentProfileConfig {
										@Bean(destroyMethod="shutdown")
										public DataSource dataSource() {
										return new EmbeddedDatabaseBuilder()
											.setType(EmbeddedDatabaseType.H2)
											.addScript("classpath:schema.sql")
											.addScript("classpath:test-data.sql")
											.build();
										}
									}
									
									@Configuration
									public class DataSourceConfig {
										@Bean(destroyMethod="shutdown")                        -> METHOD LEVEL
										@Profile("dev")
										public DataSource embeddedDataSource() {
										return new EmbeddedDatabaseBuilder()
										.setType(EmbeddedDatabaseType.H2)
										.addScript("classpath:schema.sql")
										.addScript("classpath:test-data.sql")
										.build();
										}
										
									XML
									 ...profile="dev">
									 
									ACTIVATING PROFILES
										spring.profiles.active
										spring.profiles.default
										
											There are several ways to set these properties:
												As initialization parameters on DispatcherServlet
												As context parameters of a web application
												As JNDI entries
												As environment variables
												As JVM system properties
												Using the @ActiveProfiles annotation on an integration test class
									
									CONDITIONAL BEANS
										@Bean
										@Conditional(MagicExistsCondition.class)
										public MagicBean magicBean() {
											return new MagicBean();
										}
										
											public interface Condition {
												boolean matches(ConditionContext ctxt,AnnotatedTypeMetadata metadata);
											}
											
											public class MagicExistsCondition implements Condition {
												public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
													Environment env = context.getEnvironment();
													return env.containsProperty("magic");
												}
											}
											
											public interface ConditionContext {
												BeanDefinitionRegistry getRegistry(); -> Check for bean definitions
												ConfigurableListableBeanFactory getBeanFactory(); -> Check for the presence of beans, and even dig into bean properties
												Environment getEnvironment(); -> Check for the presence and values of environment variables
												ResourceLoader getResourceLoader(); -> Read and inspect the contents of resources loaded via the ResourceLoader
												ClassLoader getClassLoader(); -> Load and check for the presence of classes via the ClassLoader
											}
											
											public interface AnnotatedTypeMetadata {
												boolean isAnnotated(String annotationType);
												Map<String, Object> getAnnotationAttributes(String annotationType);
												Map<String, Object> getAnnotationAttributes(
												String annotationType, boolean classValuesAsString);
												MultiValueMap<String, Object> getAllAnnotationAttributes(
												String annotationType);
												MultiValueMap<String, Object> getAllAnnotationAttributes(
												String annotationType, boolean classValuesAsString);
											}
											
											The class given to @Conditional can be any type that implements the Condition interface.
											
											@Primary
											primary="true"
											
											The @Qualifier annotation is the main way to work with qualifiers. It can be applied alongside @Autowired or @Inject at the point of injection to specify which
											bean you want to be injected.
											
											@Autowired
											@Qualifier("iceCream")
											public void setDessert(Dessert dessert) {
												this.dessert = dessert;
											}
											
											Problem is that you specified a qualifier on setDessert() that is tightly coupled to the class name of the bean being injected.
											Instead of relying on the bean ID as the qualifier, you can assign your own qualifier to a bean.
											
											@Component
											@Qualifier("cold")
											public class IceCream implements Dessert { ... }
											
											@Target({ElementType.CONSTRUCTOR, ElementType.FIELD,ElementType.METHOD, ElementType.TYPE})
											@Retention(RetentionPolicy.RUNTIME)
											@Qualifier
											public @interface Cold { }
											
									SCOPING BEANS
										By default, all beans created in the Spring application context are created as singletons.
										That is to say, no matter how many times a given bean is injected into other beans, it’s always the same instance that is injected each time.
											Singleton : One instance of the bean is created for the entire application.
											Prototype : One instance of the bean is created every time the bean is injected into or retrieved from the Spring application context.
											Session : In a web application, one instance of the bean is created for each session.
											Request : In a web application, one instance of the bean is created for each request.
											
											@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
												scope="prototype"/>
												
											@Scope(value=WebApplicationContext.SCOPE_SESSION,proxyMode=ScopedProxyMode.INTERFACES)
											
												Problem:
													@Component
													public class StoreService {
													
														@Autowired
														public void setShoppingCart(ShoppingCart shoppingCart) {
														this.shoppingCart = shoppingCart;
														}
														...
													}
													
													ShoppingCart is a session scope bean.
													Because StoreService is a singleton bean, it will be created as the Spring application context is loaded. 
													As it's created, Spring will attempt to inject ShoppingCart into the setShoppingCart() method. But the ShoppingCart bean, being session scoped,
													doesn't exist yet. There won't be an instance of ShoppingCart until a user comes along and a session is created.
													Moreover, there will be many instances of ShoppingCart: one per user. You don't want Spring to inject just any single instance of ShoppingCart into StoreService. 
													You want StoreService to work with the ShoppingCart instance for whichever session happens to be in play when StoreService needs to work with the shopping cart.
													Instead of injecting the actual ShoppingCart bean into StoreService, Spring should inject a proxy to the ShoppingCart bean. 
													This proxy will expose the same methods as ShoppingCart so that for all StoreService knows, it is the shopping cart. 
													But when StoreService calls methods on ShoppingCart, the proxy will lazily resolve it and delegate the call to the actual session-scoped Shopping-Cart bean.
													As configured, proxyMode is set to ScopedProxyMode.INTERFACES, indicating that the proxy should implement the ShoppingCart interface and delegate to the implementation bean.
													This is fine (and the most ideal proxy mode) as long as ShoppingCart is an interface and not a class. But if ShoppingCart is a concrete class, there’s no way Spring can
													create an interface-based proxy. Instead, it must use CGLib to generate a class-based proxy. 
													So, if the bean type is a concrete class, you must set proxyMode to ScopedProxy- Mode.TARGET_CLASS to indicate that the proxy should be generated as an extension of
													the target class.
											
											  XML
												scope="session">
											    <aop:scoped-proxy />
											    <aop:scoped-proxy proxy-target-class="false" />
												
											AVOID HARD-CODED VALUES
												Placeholders
												SPEL
												
												@PropertySource("classpath:/com/soundsystem/app.properties") -> Declare a property source
												
												@Autowired
												Environment env;
												
												env.getProperty("disc.title")
												
												XML PLACEHOLDERS
												<bean id="sgtPeppers" class="soundsystem.BlankDisc" c:_title="${disc.title}" c:_artist="${disc.artist}" />
												
												COMPONENT-SCANNING
													public BlankDisc(@Value("${disc.title}") String title,@Value("${disc.artist}") String artist) {
														this.title = title;
														this.artist = artist;
													}
												
												In order to use placeholder values, you must configure either a PropertyPlaceholder- Configurer bean or a PropertySourcesPlaceholderConfigurer bean.
												
												@Bean
												public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {
													return new PropertySourcesPlaceholderConfigurer();
												}
												
												WHY IS A BEAN DECLARED STATIC ?
													SPECIAL CONSIDERATION MUST BE TAKEN for @Bean methods that return Spring BeanFactoryPostProcessor types!!
													BFPP objects must be instantiated very early in the container lifecycle,they can interfere with processing of annotations such as 
													@Autowire ,@Value .By making these methods as static,it can be invoked without causing instantiation of its declaring @Configuration class,
													thus avoiding the above-mentioned lifecycle conflits!!!
													
												In XML 
													<context:property-placeholder />
													
												SPEL
													public BlankDisc(@Value("#{systemProperties['disc.title']}") String title,@Value("#{systemProperties['disc.artist']}") String artist) {
														this.title = title;
														this.artist = artist;
													}
													
													<bean id="sgtPeppers" class="soundsystem.BlankDisc" c:_title="#{systemProperties['disc.title']}" c:_artist="#{systemProperties['disc.artist']}" />
													
													Call methods
														#{artistSelector.selectArtist()}
														To guard against a NullPointerException, you can use the type-safe operator:
														#{artistSelector.selectArtist()?.toUpperCase()}
														
														The key to working with class-scoped methods and constants in SpEL is to use the T() operator.
															T(java.lang.Math)
														The result of the T() operator, as shown here, is a Class object that represents java.lang.Math.
														
															#{jukebox.songs.?[artist eq 'Aerosmith']}
															#{jukebox.songs.^[artist eq 'Aerosmith']}
															#{jukebox.songs.![title]}
															
										AOP
											Spring ascpects types
												Before
												After
												After-Returning
												After-Throwing
												Around
											
											Introductions
												An introduction allows us to add new methods or attributes to existing classes.
											Weaving
												Is the process of applying aspects to a target object to create a new proxied object.The aspects are woven into the target object at the specified join points.
													Compile Time : Requires special compiler(Aspect's weaving compiler)
													Class Load time : Special ClassLoader
													RunTime : Aspects we woven in sometime during the execution of the application.
													
													Spring’s support for AOP comes in four styles:
														Classic Spring proxy-based AOP
														Pure-POJO aspects
														@AspectJ annotation-driven aspects
														Injected AspectJ aspects (available in all versions of Spring)
														
													Spring AOP is built around dynamic proxies. Consequently, Spring’s AOP support is limited to method interception.
													
													execution(* concert.Performance.perform(..))
													          |           |           |      |->Taking any arguments
															  |           |           |->The method
															  |           |->The type that the method belongs to
															  |->Return any type
															  
													execution(* concert.Performance.perform(..)) && within(concert.*)) LIMIT THE MATCH TO ONLY THE CONCERT PACKAGE
													
													@Aspect
													public class Audience {
														@Pointcut("execution(** concert.Performance.perform(..))")
														public void performance() {}
														
														@Before("performance()")
														public void silenceCellPhones() {
															System.out.println("Silencing cell phones");
														}
														
														@Before("performance()")
														public void takeSeats() {
															System.out.println("Taking seats");
														}
														
														@AfterReturning("performance()")
														public void applause() {
															System.out.println("CLAP CLAP CLAP!!!");
														}
														
														@AfterThrowing("performance()")
														public void demandRefund() {
															System.out.println("Demanding a refund");
														}
													}
													
													@Bean
													public Audience audience() {
														return new Audience();
													}
													
													JAVA CONFIG
														@Configuration
														@EnableAspectJAutoProxy
														@ComponentScan
														public class ConcertConfig {
														
															@Bean
															public Audience audience() {
																return new Audience();
															}
														}
														
													XML
														
															<context:component-scan base-package="concert" />
															<aop:aspectj-autoproxy />
															<bean class="concert.Audience" />
														</beans>
														
														In XML
												<aop:config>
													<aop:aspect ref="audience">
														<aop:before pointcut="execution(** concert.Performance.perform(..))" method="silenceCellPhones"/>
														<aop:before pointcut="execution(** concert.Performance.perform(..))" method="takeSeats"/>
														<aop:after-returning pointcut="execution(** concert.Performance.perform(..))" method="applause"/>
														<aop:after-throwing pointcut="execution(** concert.Performance.perform(..))" method="demandRefund"/>
													</aop:aspect>
												</aop:config>
												
												THIS MAKES SPRING'S XML CONFIGURATION FOR AOP A HANDY WAY TO USE TYPES DEFINED IN THIRD-PARTY LIBRARIES AS ADVICE, EVEN THOUGH WE CAN'T ANNOTATE THEM WITH ASPECTJ ASPECTS.
												
												<aop:config>
													<aop:aspect ref="audience">
														<aop:pointcut id="performance" expression="execution(** concert.Performance.perform(..))" />
														<aop:before pointcut-ref="performance" method="silenceCellPhones"/>
														<aop:before pointcut-ref="performance" method="takeSeats"/>
														<aop:after-returning pointcut-ref="performance" method="applause"/>
														<aop:after-throwing pointcut-ref="performance" method="demandRefund"/>
													</aop:aspect>
												</aop:config>
														
												REWRITING WITH AROUND
													@Aspect
													public class Audience {
														@Pointcut("execution(** concert.Performance.perform(..))")
														public void performance() {}
														
														@Around("performance()")
														public void watchPerformance(ProceedingJoinPoint jp) {
															try {
																System.out.println("Silencing cell phones");
																System.out.println("Taking seats");
																jp.proceed();
																System.out.println("CLAP CLAP CLAP!!!");
															} catch (Throwable e) {
																System.out.println("Demanding a refund");
															}
														}
													}
													
													Example with arguments
														@Pointcut(
									"execution(* soundsystem.CompactDisc.playTrack(int)) && args(trackNumber)")
									public void trackPlayed(int trackNumber) {}
									
									INTRODUCTIONS
										
											Adding new methods to Spring Beans.
											When a method on the introduced interface is called, the proxy delegates the call to some other object that provides the implementation of the new
											interface. Effectively, this gives you one bean whose implementation is split across multiple classes.
											
											@Aspect
											public class EncoreableIntroducer {
												@DeclareParents(value="concert.Performance+",defaultImpl=DefaultEncoreable.class)
												public static Encoreable encoreable;
											}
											
											
											
							SPRING MVC FRAMEWORK
							
								Request ------> DISPATCH SERVLET ----> HANDLER MAPPING ----> CONTROLLER -> MODEL & LOGICAL VIEW NAME ---> VIEW RESOLVER  -----> VIEW ---> RESPONSE
								
								
								Like most Javabased web frameworks, Spring MVC funnels requests through a single front controller servlet. A front controller is a common web application pattern where a single servlet
								delegates responsibility for a request to other components of an application to perform actual processing. In the case of Spring MVC, DispatcherServlet is the front controller.
								The DispatcherServlet’s job is to send the request on to a Spring MVC controller.
								A controller is a Spring component that processes the request. But a typical application may have several controllers, and DispatcherServlet needs some help deciding
								which controller to send the request to. So the DispatcherServlet consults one or more handler mappings to figure out where the request’s next stop will be. The
								handler mapping pays particular attention to the URL carried by the request when making its decision.
								Once an appropriate controller has been chosen, DispatcherServlet sends the request on its merry way to the chosen controller. At the controller, the request
								drops off its payload (the information submitted by the user) and patiently waits while the controller processes that information. (Actually, a well-designed controller performs
								little or no processing itself and instead delegates responsibility for the business logic to one or more service objects.)
								The logic performed by a controller often results in some information that needs to be carried back to the user and displayed in the browser. This information is
								referred to as the model. But sending raw information back to the user isn’t sufficient— it needs to be formatted in a user-friendly format, typically HTML. 
								For that, the information needs to be given to a view, typically a JavaServer Page (JSP).
								One of the last things a controller does is package up the model data and identify the name of a view that should render the output. It then sends the request, along
								with the model and view name, back to the DispatcherServlet. So that the controller doesn’t get coupled to a particular view, the view name.
								The DispatcherServlet consults a view resolver to map the logical view name to a specific view implementation, which may or may not be a JSP.
								
								Configure DispatchServlet in Java instead of the traditional web.xml
									Using the Servlet 3.0 specification , the servlet container looks for any classes in the classpath that implements the javax.servlet.ServletContainerInitializer interface,
									if they are found,they are used to configure the servlet container.
									Spring supplies an implementation of that interface called SpringServletContainerInitializer that,in turn,seeks out any classes that implement WebApplicationInitializer and 
									delegates to them for configuration.
									
									IN SPRING MVC THERE ARE TWO APPLICATION CONTEXT
										DispatcherServlet is expected to load beans containing web components such as controllers, view resolvers, and handler mappings, ContextLoaderListener is
										expected to load the other beans in your application. These beans are typically the middle-tier and data-tier components that drive the back end of the application.
										Under the covers, AbstractAnnotationConfigDispatcherServletInitializer creates both a DispatcherServlet and a ContextLoaderListener. The @Configuration
										classes returned from getServletConfigClasses() will define beans for DispatcherServlet’s application context.
										Meanwhile, the @Configuration class’s returned  getRootConfigClasses() will be used to configure the application context created by ContextLoaderListener.
										
										@Configuration
										@EnableWebMvc
										@ComponentScan("spitter.web")
										public class WebConfig extends WebMvcConfigurerAdapter {
										
											@Bean
											public ViewResolver viewResolver() {
												InternalResourceViewResolver resolver = new InternalResourceViewResolver();
												resolver.setPrefix("/WEB-INF/views/");
												resolver.setSuffix(".jsp");
												resolver.setExposeContextBeansAsAttributes(true);
												return resolver;
											}
											
											@Override
											public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
												configurer.enable();
											}
										}
										
										WebConfig class extends WebMvcConfigurerAdapter and overrides its configureDefaultServletHandling() method. By calling enable() on the given
										DefaultServletHandlerConfigurer, you’re asking DispatcherServlet to forward requests for static resources to the servlet container’s default servlet and not to try to
										handle them itself.
										
										@Component ===== @Controller
										
										@Controller
										public class HomeController {
											@RequestMapping(value="/", method=GET)
											public String home() {
												return "home";
											}
										}
										
										TEST SPRING MVC CONTROLLERS
											public class HomeControllerTest {
												@Test
												public void testHomePage() throws Exception {
													HomeController controller = new HomeController();
													MockMvc mockMvc = standaloneSetup(controller).build();
													mockMvc.perform(get("/")).andExpect(view().name("home"));
												}
											}
											
											@Test
											public void shouldShowRecentSpittles() throws Exception {
												List<Spittle> expectedSpittles = createSpittleList(20);
												SpittleRepository mockRepository = mock(SpittleRepository.class);
												when(mockRepository.findSpittles(Long.MAX_VALUE, 20)).thenReturn(expectedSpittles);
												SpittleController controller = new SpittleController(mockRepository);
												SpittleController controller = new SpittleController(mockRepository);
												MockMvc mockMvc = standaloneSetup(controller).setSingleView(new InternalResourceView("/WEB-INF/views/spittles.jsp")).build();
												mockMvc.perform(get("/spittles")).andExpect(view().name("spittles")).andExpect(model().attributeExists("spittleList")).andExpect(model().attribute("spittleList",hasItems(expectedSpittles.toArray())));
											}
											
											@Controller
											@RequestMapping("/spittles")
											public class SpittleController {
												private SpittleRepository spittleRepository;
												@Autowired
												public SpittleController(SpittleRepository spittleRepository) {
													this.spittleRepository = spittleRepository;
												}
												
												@RequestMapping(method=RequestMethod.GET)
												public String spittles(Model model) {
													model.addAttribute(spittleRepository.findSpittles(Long.MAX_VALUE, 20));
													return "spittles";
												}
											}
											
											The Model is essentially a map (that is, a collection of key-value pairs) that will be handed off to the view so that the data can be rendered to the client. 
											When add-Attribute() is called without specifying a key, the key is inferred from the type of object being set as the value. In this case, because it’s a List<Spittle>, 
											the key will be inferred as spittleList.
											LIKEWISE, IF YOU’D PREFER TO WORK WITH A NON-SPRING TYPE, YOU CAN ASK FOR A JAVA .UTIL.MAP INSTEAD OF MODEL!!!
											
											Here’s another way to write the spittles() method:
											@RequestMapping(method=RequestMethod.GET)
											public List<Spittle> spittles() {
												return spittleRepository.findSpittles(Long.MAX_VALUE, 20));
											}
											
											When a handler method returns an object or a collection like this, the value returned is put into the model, and the model key is inferred from its type.
											As for the logical view name, it’s inferred from the request path. Because this method handles GET requests for /spittles, the view name is spittles (chopping off the leading slash).
											Now that there’s data in the model, how does the JSP access it? As it turns out, when the view is a JSP, the model data is copied into the request as request attributes.
											Therefore, the spittles.jsp file can use JavaServer Pages Standard Tag Library’s (JSTL).
											
											Spring MVC provides several ways that a client can pass data into a controller’s handler method. These include
												Query parameters
													@RequestMapping(method=RequestMethod.GET)
													public List<Spittle> spittles(@RequestParam(value="max",defaultValue=MAX_LONG_AS_STRING) long max,@RequestParam(value="count", defaultValue="20") int count) {
														return spittleRepository.findSpittles(max, count);
													}
												Form parameters
													<form method="POST">
														First Name: <input type="text" name="firstName" /><br/>
													...
													
													Notice that the <form> tag doesn’t have an action parameter set. Because of that, when this form is submitted, it will be posted back to the same 
													URL path that displayed it.
													
													@RequestMapping(value="/register", method=POST)
													public String processRegistration(Spitter spitter) {
														spitterRepository.save(spitter);
														return "redirect:/spitter/" + spitter.getUsername();
													}
													
														When InternalResourceViewResolver sees the redirect: prefix on the view specification, it knows to interpret it as a redirect specification instead of as a view name. 
														In this case, it will redirect to the path for a user’s profile page. For example, if the Spitter.username property is jbauer, then the view will redirect 
														to /spitter/jbauer.
														It’s worth noting that in addition to redirect:, InternalResourceViewResolver also recognizes the forward: prefix. When it sees a view specification prefixed with
														forward:, the request is forwarded to the given URL path instead of redirected.
														
														SPRING MVC supports JAVA Validation API
														
														@NotNull
														@Size(min=5, max=16 , message="{username.size}")
														private String username;
														
														public String processRegistration(@Valid Spitter spitter,Errors errors) {
															if (errors.hasErrors()) {
															return "registerForm";
														}
													
													
												Path variables
													Resource-oriented controllers
													The resource being identified (the Spittle) would be identified by the URL path, not by query parameters.
													A GET request for /spittles/12345 is better than one for /spittles/show?spittle_id=12345.
													To accommodate these path variables, Spring MVC allows for placeholders in an @RequestMapping path.
																										
													@RequestMapping(value="/{spittleId}", method=RequestMethod.GET)
													public String spittle(@PathVariable("spittleId") long spittleId,Model model) {
														model.addAttribute(spittleRepository.findOne(spittleId)); ---> MODEL KEY WILL BE "spittle" inferred by the type passed in to addAttribute();
														return "spittle";
													}
													
													The data in the Spittle object can then be rendered in the view by referring to the request attribute whose key is spittle (the same as the model key).
														<div class="spittleMessage"><c:out value="${spittle.message}" /></div>
													
													Because the method parameter name happens to be the same as the placeholder name, you can optionally omit the value parameter on @PathVariable.
													
											VIEW RESOLUTION
												
												public interface ViewResolver {
													View resolveViewName(String viewName, Locale locale)
												throws Exception;
												}

												public interface View {
													String getContentType();
													void render(Map<String, ?> model,HttpServletRequest request,HttpServletResponse response) throws Exception;
												}
												
												Views Implementations
													BeanNameViewResolver
													ContentNegotiatingViewResolver
													FreeMarkerViewResolver
													InternalResourceViewResolver
													JasperReportsViewResolver
													ResourceBundleViewResolver
													TilesViewResolver
													UrlBasedViewResolver
													VelocityLayoutViewResolver
													VelocityViewResolver
													XmlViewResolver
													XsltViewResolver
													
												But if those JSP files are using JSTL tags for formatting or messages, then you may want to configure InternalResourceViewResolver to resolve a JstlView instead.
												JSTL’s formatting tags need a Locale to properly format locale-specific values such as dates and money. And its message tags can use a Spring message source and a
												Locale to properly choose messages to render in HTML. By resolving JstlView, the JSTL tags will be given the Locale and any message source configured in Spring.	
													
												@Bean
												public ViewResolver viewResolver() {
													InternalResourceViewResolver resolver = new InternalResourceViewResolver();
													resolver.setPrefix("/WEB-INF/views/");
													resolver.setSuffix(".jsp");
													resolver.setViewClass(org.springframework.web.servlet.view.JstlView.class);
													return resolver;
												}
												
												<%@ taglib uri="http://www.springframework.org/tags/form" prefix="sf" %>
												<sf:form method="POST" commandName="spitter"> ---->  commandName attribute -> There must be an object in the model whose key is "spitter".
													First Name: <sf:input path="firstName" /><br/>
													Last Name: <sf:input path="lastName" /><br/>
													Email: <sf:input path="email" /><br/>
													Username: <sf:input path="username" /><br/>
													Password: <sf:password path="password" /><br/>
													<input type="submit" value="Register" />
												</sf:form>
												
												Displaying errors
													<sf:form method="POST" commandName="spitter">
														First Name: <sf:input path="firstName" />
														<sf:errors path="firstName" /><br/>
														
														
														<sf:errors path="*" element="div" cssClass="errors" />
														<sf:label path="firstName" cssErrorClass="error">First Name</sf:label>:
														<sf:input path="firstName" cssErrorClass="error" /><br/>
												
											Message Properties
												@Bean
												public MessageSource messageSource() {
													ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
													messageSource.setBasename("messages");
													return messageSource;
												}

												@Bean
												public MessageSource messageSource() {
													ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource();
													messageSource.setBasename("file:///etc/spittr/messages");
													messageSource.setCacheSeconds(10);
													return messageSource;
												}

												The
												basename property can be set to look for messages in the classpath (with a classpath: prefix), in the filesystem (with a file: prefix), or at the root of the web application
												(with no prefix). Here, it’s configured to look for messages in properties files in the /etc/spittr directory of the server’s filesystem and with a base filename of “messages”.

												create the default properties
												file named messages.properties.

												If, for example, you wanted to show the welcome message in Spanish for anyone whose language settings are set to Spanish, you’d need to create another properties
												file named messages_es.properties
												
												In its simplest form, <s:url> takes a servlet-context-relative URL and renders it with the servlet context path prepended. For example, consider this basic use of
												<s:url>:
												
													<a href="<s:url href="/spitter/register" />">Register</a>

												If the application’s servlet context is named spittr, then the following HTML will be rendered in the response:
													<a href="/spittr/spitter/register">Register</a>
												This enables you to create URLs without worrying about what the servlet context path will be.
												
											<s:url href="/spitter/{username}" var="spitterUrl">
												<s:param name="username" value="jbauer" />
											</s:url>
												When the href value is a placeholder that matches a parameter specified by <s:param>, the parameter is inserted into the placeholder’s spot. 
												If the <s:param> parameter doesn’t match any placeholders in href, then the parameter is used as a query parameter.
												
										APACHE TILES
											Layout engine such as Apache Tiles to define a common page layout that will be applied to all pages.
											In order to use Tiles with Spring, you’ll have to configure a couple of beans. You need a TilesConfigurer bean whose job is to locate and load tile definitions and generally
											coordinate Tiles. In addition, you need a TilesViewResolver bean to resolve logical view names to tile definitions.
											
											@Bean
											public TilesConfigurer tilesConfigurer() {
												TilesConfigurer tiles = new TilesConfigurer();
												tiles.setDefinitions(new String[] {"/WEB-INF/layout/tiles.xml"});
												tiles.setCheckRefresh(true);
												return tiles;
											}
											
											@Bean
											public ViewResolver viewResolver() {
												return new TilesViewResolver();
											}
											
											<tiles-definitions>
												<definition name="base" template="/WEB-INF/layout/page.jsp">
													<put-attribute name="header" value="/WEB-INF/layout/header.jsp" />
													<put-attribute name="footer" value="/WEB-INF/layout/footer.jsp" />
												</definition>

												<definition name="home" extends="base">
													<put-attribute name="body" value="/WEB-INF/views/home.jsp" />
												</definition>
												
												<definition name="registerForm" extends="base">
													<put-attribute name="body" value="/WEB-INF/views/registerForm.jsp" />
												</definition>
												
											<html>
												<head>
													<title>Spittr</title>
													<link rel="stylesheet" type="text/css" href="<s:url value="/resources/style.css" />" >
												</head>
												<body>
												<div id="header">
													<t:insertAttribute name="header" />
												</div>
												<div id="content">
													<t:insertAttribute name="body" />
												</div>
												<div id="footer">
													<t:insertAttribute name="footer" />
												</div>

										THYMELEAF
										
										@Bean
										public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {
											ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();
											viewResolver.setTemplateEngine(templateEngine);
											return viewResolver;
										}
										
										@Bean
										public TemplateEngine templateEngine(TemplateResolver templateResolver) {
											SpringTemplateEngine templateEngine = new SpringTemplateEngine();
											templateEngine.setTemplateResolver(templateResolver);
											return templateEngine;
										}
										
										@Bean
										public TemplateResolver templateResolver() {
											TemplateResolver templateResolver = new ServletContextTemplateResolver();
											templateResolver.setPrefix("/WEB-INF/templates/");
											templateResolver.setSuffix(".html");
											templateResolver.setTemplateMode("HTML5");
											return templateResolver;
										}
										
										<label th:class="${#fields.hasErrors('firstName')}? 'error'">First Name</label>:
										<input type="text" th:field="*{firstName}" th:class="${#fields.hasErrors('firstName')}? 'error'" /><br/>
										
										<form method="POST" th:object="${spitter}">
											<div class="errors" th:if="${#fields.hasErrors('*')}">
												<ul>
													<li th:each="err : ${#fields.errors('*')}" th:text="${err}">Input is incorrect</li>
												</ul>
											</div>
											<label th:class="${#fields.hasErrors('firstName')}? 'error'">
												First Name</label>:
												<input type="text" th:field="*{firstName}" th:class="${#fields.hasErrors('firstName')}? 'error'" /><br/>
												
										But what if you want to register additional servlets, filters, or listeners?
											Therefore, if you need to register any additional components into the web container, you need only create a new initializer class. 
											The easiest way to do this is by implementing Spring's WebApplicationInitializer interface.
											
												public class MyServletInitializer implements WebApplicationInitializer {
													@Override
													public void onStartup(ServletContext servletContext) throws ServletException {
														Dynamic myServlet = servletContext.addServlet("myServlet", MyServlet.class);
														myServlet.addMapping("/custom/**");
													}
												}
												
										XML
											web.xml
											
											<context-param>
												<param-name>contextConfigLocation</param-name>
												<param-value>/WEB-INF/spring/root-context.xml</param-value>
											</context-param>
											<listener>
											<listener-class>
												org.springframework.web.context.ContextLoaderListener
											</listener-class>
											</listener>
											<servlet>
												<servlet-name>appServlet</servlet-name>
												<servlet-class>org.springframework.web.servlet.DispatcherServlet
											</servlet-class>
											<load-on-startup>1</load-on-startup>
											</servlet>
											<servlet-mapping>
												<servlet-name>appServlet</servlet-name>
												<url-pattern>/</url-pattern>
											</servlet-mapping>
											
												ContextLoaderListener and DispatcherServlet each load a Spring application context. The contextConfigLocation context parameter
												specifies the location of the XML file that defines the root application context loaded by ContextLoaderListener. 
												The root context is loaded with bean definitions in /WEB-INF/spring/root-context.xml.
												DispatcherServlet loads its application context with beans defined in a file whose name is based on the servlet name. 
												The servlet is named appServlet. Therefore, DispatcherServlet loads its application context from an XML file at /WEB-INF/appServlet-context.xml.
												
										JAVA CONFIGURATION
										
											<context-param>
												<param-name>contextClass</param-name>
											<param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
											</context-param>
											<context-param>
												<param-name>contextConfigLocation</param-name>
												<param-value>com.habuma.spitter.config.RootConfig</param-value>
											</context-param>
											<listener>
												<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
											</listener>
											<servlet>
												<servlet-name>appServlet</servlet-name>
												<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
													<init-param>
													<param-name>contextClass</param-name>
													<param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
												</init-param>
												<init-param>
													<param-name>contextConfigLocation</param-name>
													<param-value>com.habuma.spitter.config.WebConfigConfig</param-value>
												</init-param>
												<load-on-startup>1</load-on-startup>
											</servlet>
											<servlet-mapping>
												<servlet-name>appServlet</servlet-name>
												<url-pattern>/</url-pattern>
											</servlet-mapping>
											
											MultiPart Form Data
												DispatcherServlet doesn’t implement any logic for parsing the data in a multipart request. Instead, it delegates to an implementation of Spring’s MultipartResolver
												strategy interface to resolve the content in a multipart request.
												
												AUTOMATIC
													@Bean
													public MultipartResolver multipartResolver() throws IOException {
														return new StandardServletMultipartResolver();
													}
													
													If you’re configuring DispatcherServlet in a servlet initializer class that implements WebApplicationInitializer
												
													DispatcherServlet ds = new DispatcherServlet();
													Dynamic registration = context.addServlet("appServlet", ds);
													registration.addMapping("/");
													registration.setMultipartConfig(new MultipartConfigElement("/tmp/spittr/uploads"));
													
													If you’ve configured DispatcherServlet in a servlet initializer class that extends AbstractAnnotationConfigDispatcherServletInitializer or 
													AbstractDispatcherServletInitializer, you don’t create the instance of DispatcherServlet or register it with the servlet context directly.
													
													@Override
													protected void customizeRegistration(Dynamic registration) {
														registration.setMultipartConfig(new MultipartConfigElement("/tmp/spittr/uploads"));
													}
													
													XML
														<servlet>
															<servlet-name>appServlet</servlet-name>
															<servlet-class>
																	org.springframework.web.servlet.DispatcherServlet
															</servlet-class>
															<load-on-startup>1</load-on-startup>
															<multipart-config>
																<location>/tmp/spittr/uploads</location>
																<max-file-size>2097152</max-file-size>
																<max-request-size>4194304</max-request-size>
															</multipart-config>
														</servlet>
														
													Handling MultiPart Request
														@RequestMapping(value="/register", method=POST)
														public String processRegistration(@RequestPart("profilePicture") byte[] profilePicture,@Valid Spitter spitter,Errors errors) {
															...
														}
														
														WORKING WITH THE UPLOADED FILE’S RAW BYTES IS SIMPLE BUT LIMITING. THEREFORE, SPRING ALSO OFFERS MULTIPARTFILE AS A WAY TO GET A RICHER OBJECT!!!
														
													Exceptions
													
														@ResponseStatus(value=HttpStatus.NOT_FOUND,reason="Spittle Not Found")
														public class SpittleNotFoundException extends RuntimeException {
														}
														
														@ExceptionHandler(DuplicateSpittleException.class)
														public String handleDuplicateSpittle() {
															return "error/duplicate";
														}
														
														What’s especially interesting about @ExceptionHandler methods is that they handle their exceptions from any handler method in the same controller.
														
														@ControllerAdvice
														public class AppWideExceptionHandler {
															@ExceptionHandler(DuplicateSpittleException.class)
															public String duplicateSpittleHandler() {
																return "error/duplicate";
															}
														}
														
														Now, if a DuplicateSpittleException is thrown from any controller method, no matter which controller it’s in, this duplicateSpittleHandler() method will be called to
														handle the exception.
														
														CARRYING DATA ACROSS REDIRECT REQUESTS
														
																When a controller method returns a String whose value starts with redirect:, that String isn’t used to look up a view, but is instead 
																used as a path to redirect the browser to.
																
																	Passing data as path variables and/or query parameters using URL templates
																		@RequestMapping(value="/register", method=POST)
																		public String processRegistration(Spitter spitter, Model model) {
																			spitterRepository.save(spitter);
																			model.addAttribute("username", spitter.getUsername());
																			model.addAttribute("spitterId", spitter.getId());
																			return "redirect:/spitter/{username}";
																		}
																		
																		Because the spitterId attribute from the model doesn’t map to any URL placeholders in the redirect, it’s tacked on to the redirect automatically as a query parameter.
																		If the username attribute is habuma and the spitterId attribute is 42, then the resulting redirect path will be /spitter/habuma?spitterId=42.
																	
																	Sending data in flash attributes
																		Spring offers a way to set flash attributes via RedirectAttributes, a sub-interface of Model
																		@RequestMapping(value="/register", method=POST)
																		public String processRegistration(Spitter spitter, RedirectAttributes model) {
																			spitterRepository.save(spitter);
																			model.addAttribute("username", spitter.getUsername());
																			model.addFlashAttribute("spitter", spitter);
																			return "redirect:/spitter/{username}";
																		}
																		
																		Before the redirect takes place, all flash attributes are copied into the session. After the redirect, the flash attributes stored 
																		in the session are moved out of the session and into the model. The method that handles the redirect request can then access the
																		Spitter from the model, just like any other model object.
																	
																		@RequestMapping(value="/{username}", method=GET)
																		public String showSpitterProfile(@PathVariable String username, Model model) {
																			if (!model.containsAttribute("spitter")) {
																				model.addAttribute(spitterRepository.findByUsername(username));
																			}
																			return "profile";
																		}
																		
																		
											SECURITY
												Spring Security employs several servlet filters to provide various aspects of security.
												DelegatingFilterProxy is a special servlet filter that, by itself, doesn’t do much.
												Instead, it delegates to an implementation of javax.servlet.Filter that’s registered as a <bean> in the Spring application context		
													
												JAVA
													If you'd rather configure DelegatingFilterProxy in Java with a WebApplication-
													Initializer, then all you need to do is create a new class that extends AbstractSecurityWebApplicationInitializer:

													public class SecurityWebInitializer extends AbstractSecurityWebApplicationInitializer {}
													
													AbstractSecurityWebApplicationInitializer implements WebApplicationInitializer, so it will be discovered by Spring and be used to register 
													DelegatingFilterProxy with the web container.
													
													WHETHER YOU CONFIGURE DELEGATINGFILTERPROXY IN WEB.XML OR BY SUBCLASSING ABSTRACTSECURITYWEBAPPLICATIONINITIALIZER, IT WILL INTERCEPT REQUESTS COMING
													INTO THE APPLICATION AND DELEGATE THEM TO A BEAN WHOSE ID IS SPRINGSECURITYFILTERCHAIN.
													
													@Configuration
													@EnableWebSecurity
													public class SecurityConfig extends WebSecurityConfigurerAdapter {
													}
													
													Spring Security must be configured in a bean that implements WebSecurityConfigurer or (for convenience) extends WebSecurityConfigurerAdapter. 
													Any bean in the Spring application context that implements WebSecurityConfigurer can contribute to Spring Security configuration, but it’s often most
													convenient for the configuration class to extend WebSecurityConfigurerAdapter.
													
													We should consider using @EnableWebMvcSecurity
													
													@Configuration
													@EnableWebMvcSecurity
													public class SecurityConfig extends WebSecurityConfigurerAdapter {
													}
													
													Among other things, the @EnableWebMvcSecurity annotation configures a Spring MVC argument resolver so that handler methods can receive the authenticated user’s
													principal (or username) via @AuthenticationPrincipal-annotated parameters. It also configures a bean that automatically adds a hidden cross-site request forgery
													(CSRF) token field on forms using Spring’s form-binding tag library.
													
													You can configure web security by overriding WebSecurityConfigurerAdapter’s three configure() methods.
													
													configure(WebSecurity) Override to configure Spring Security’s filter chain.
													configure(HttpSecurity) Override to configure how requests are secured by interceptors.
													configure(AuthenticationManagerBuilder)
													
													
													Database Users
													
													@Autowired
													DataSource dataSource;
													
													@Override
													protected void configure(AuthenticationManagerBuilder auth)throws Exception {
														auth.jdbcAuthentication().dataSource(dataSource).usersByUsernameQuery("select username, password, true from Spitter where username=?").
														authoritiesByUsernameQuery("select username, 'ROLE_USER' from Spitter where username=?");
													}
													
													LDAP Users
													
													@Override
													protected void configure(AuthenticationManagerBuilder auth) throws Exception {
														auth.ldapAuthentication().userSearchFilter("(uid={0})").groupSearchFilter("member={0}");
													}
													
													The key to fine-tuning security for each request is to override the configure (HttpSecurity) method
													@Override
													protected void configure(HttpSecurity http) throws Exception {
														http.authorizeRequests().antMatchers("/spitters/me").authenticated().antMatchers(HttpMethod.POST, "/spittles").authenticated().anyRequest().permitAll();
													}
													
													Securing with Spring Expressions
														What if you wanted to restrict access to certain roles only on Tuesday?
														Using the access() method, you can also use SpEL as a means for declaring access requirements
														
													Preventing cross-site request forgery
														If you’re using Thymeleaf for your page template, you’ll get the hidden _csrf field automatically, as long as the <form> tag’s
														action attribute is prefixed to come from the Thymeleaf namespace:
						
														<form method="POST" th:action="@{/spittles}">
															...
														</form>
														
														If you’re using JSP for page templates, you can do something very similar:
														
														<input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}" />
														
														Even better, if you’re using Spring’s form-binding tag library, the <sf:form> tag will automatically add the hidden CSRF token tag for you.
														
												
												
												Form-based authentication is ideal for human users of an application. Later we’ll see how to turn some of your web application’s pages into a RESTful API.
												When the user of the application is another application, prompting for login with a form just won’t do.
												HTTP Basic authentication is one way to authenticate a user to an application directly in the HTTP request itself. You may have seen HTTP Basic authentication before.
												
													protected void configure(HttpSecurity http) throws Exception {
															http.formLogin().loginPage("/login")
															.and()
															.httpBasic().realmName("Spittr")
															.and()...
															
											SPRING BACKEND

												All Spring JDBC exceptions are rooted with DataAccessException and what makes this Exception special is that it is an UNCHECKED EXCEPTION!!!!
												
												Templating data access 
													Spring use the Template Method Pattern
													
												JNDI datasources
													XML
														<jee:jndi-lookup id="dataSource" jndi-name="/jdbc/SpitterDS" resource-ref="true" />
													Java Config
														 @Bean
														public JndiObjectFactoryBean dataSource() {
															JndiObjectFactoryBean jndiObjectFB = new JndiObjectFactoryBean();
															jndiObjectFB.setJndiName("jdbc/SpittrDS");
															jndiObjectFB.setResourceRef(true);
															jndiObjectFB.setProxyInterface(javax.sql.DataSource.class);
															return jndiObjectFB;
														}
														
												Pooled DataSource
													XML
														<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" p:driverClassName="org.h2.Driver"
															p:url="jdbc:h2:tcp://localhost/~/spitter" p:username="sa" p:password="" p:initialSize="5" p:maxActive="10" />
													Java Config
														@Bean
														public BasicDataSource dataSource() {
															BasicDataSource ds = new BasicDataSource();
															ds.setDriverClassName("org.h2.Driver");
															ds.setUrl("jdbc:h2:tcp://localhost/~/spitter");
															ds.setUsername("sa");
															ds.setPassword("");
															ds.setInitialSize(5);
															ds.setMaxActive(10);
															return ds;
														}
														
												JDBC Driver-Based 		
													Spring offers three such data-source classes to choose from :
														 DriverManagerDataSource—Returns a new connection every time a connection is requested. Unlike DBCP’s BasicDataSource, the connections provided by DriverManagerDataSource aren’t pooled.
														 SimpleDriverDataSource—Works much the same as DriverManagerDataSource except that it works with the JDBC driver directly to overcome class loading issues that may arise in certain environments, such as in an OSGi container.
														 SingleConnectionDataSource—Returns the same connection every time a connection is requested. Although SingleConnectionDataSource isn’t exactly a pooled data source, you can think of it as a data source with a pool of exactly one connection.	
												
												
												
													
													
												JDBC TEMPLATE
													@Bean
													public JdbcTemplate jdbcTemplate(DataSource dataSource) {
														return new JdbcTemplate(dataSource);
													}
													
													@Repository
													public class JdbcSpitterRepository implements SpitterRepository {
														private JdbcOperations jdbcOperations;
														
														@Inject
														public JdbcSpitterRepository(JdbcOperations jdbcOperations) {
															this.jdbcOperations = jdbcOperations;
														}
														...
													}

													@Bean
													public SpitterRepository spitterRepository(JdbcTemplate jdbcTemplate) {
														return new JdbcSpitterRepository(jdbcTemplate);
													}
													
													SELECT STATEMENT
													
														public Spitter findOne(long id) {
															return jdbcOperations.queryForObject(SELECT_SPITTER_BY_ID, new SpitterRowMapper(),id);
														}
														
														private static final class SpitterRowMapper implements RowMapper<Spitter> {
															public Spitter mapRow(ResultSet rs, int rowNum) throws SQLException {
																return new Spitter(
																	rs.getLong("id"),
																	rs.getString("username"),
																	rs.getString("password"),
																	rs.getString("fullName"),
																	rs.getString("email"),
																	rs.getBoolean("updateByEmail"));
															}
														}
														
														Because the RowMapper interface only declares the addRow() method, it fits the bill for a functional interface. This means that if you’re developing your application using
														Java 8, you can express the RowMapper implementation with a lambda instead of with a concrete class implementation.
														
														public Spitter findOne(long id) {
															return jdbcOperations.queryForObject(SELECT_SPITTER_BY_ID,
															(rs, rowNum) -> {
																return new Spitter(
																rs.getLong("id"),
																rs.getString("username"),
																rs.getString("password"),
																rs.getString("fullName"),
																rs.getString("email"),
																rs.getBoolean("updateByEmail"));
															},
															id);
														}
														
														Alternatively, you can use Java 8 method references to define the mapping in a separate method:
														public Spitter findOne(long id) {
															return jdbcOperations.queryForObject(SELECT_SPITTER_BY_ID, this::mapSpitter, id);
															}
															
														private Spitter mapSpitter(ResultSet rs, int row) throws SQLException {
															return new Spitter(
															rs.getLong("id"),
															rs.getString("username"),
															rs.getString("password"),
															rs.getString("fullName"),
															rs.getString("email"),
															rs.getBoolean("updateByEmail"));
														}
														
													HIBERNATE
													
														@Bean
														public LocalSessionFactoryBean sessionFactory(DataSource dataSource) {
															LocalSessionFactoryBean sfb = new LocalSessionFactoryBean();
															sfb.setDataSource(dataSource);
															sfb.setPackagesToScan(new String[] { "com.habuma.spittr.domain" });
															Properties props = new Properties();
															props.setProperty("dialect", "org.hibernate.dialect.H2Dialect");
															sfb.setHibernateProperties(props);
															return sfb;
														}
														
														public HibernateSpitterRepository(SessionFactory sessionFactory) {
															this.sessionFactory = sessionFactory;
														}
														private Session currentSession() {
															return sessionFactory.getCurrentSession();
														}
														public long count() {
															return findAll().size();
														}
														public Spitter save(Spitter spitter) {
															Serializable id = currentSession().save(spitter);
															return new Spitter((Long) id,
															spitter.getUsername(),
															spitter.getPassword(),
															spitter.getFullName(),
															spitter.getEmail(),
															spitter.isUpdateByEmail());
														}
														
														Also note that you annotate the class with @Repository. This accomplishes two things. First, @Repository is another one of Spring’s stereotype annotations that,
														among other things, are scanned by Spring component-scanning.
														Recall that one of the jobs of a template class is to catch platformspecific exceptions and rethrow them as one of Spring’s unified unchecked exceptions.
														But if you’re using Hibernate contextual sessions and not a Hibernate template, how can the exception translation take place?
														To add exception translation to a template-less Hibernate repository, you just need to add a PersistenceExceptionTranslationPostProcessor bean 
														to the Spring application context:
																
																@Bean
																public BeanPostProcessor persistenceTranslation() {
																	return new PersistenceExceptionTranslationPostProcessor();
																}
																
														PersistenceExceptionTranslationPostProcessor is a bean post-processor that adds an adviser to any bean that’s annotated with @Repository so that any platform-specific
														exceptions are caught and then rethrown as one of Spring’s unchecked data-access exceptions.
														
													JPA
														JPA-based applications use an implementation of EntityManagerFactory to get an instance of an EntityManager. The JPA specification defines two kinds of entity managers:
															Application-managed
															Container-managed
																Instead of configuring data-source details in persistence.xml, you can configure this information in the Spring application context. 
																For example, the following <bean> declaration shows how to configure container-managed JPA in Spring using LocalContainerEntityManagerFactoryBean:
																
																@Bean
																public LocalContainerEntityManagerFactoryBean entityManagerFactory(
																	DataSource dataSource, JpaVendorAdapter jpaVendorAdapter) {
																	LocalContainerEntityManagerFactoryBean emfb = new LocalContainerEntityManagerFactoryBean();
																	emfb.setDataSource(dataSource);
																	emfb.setJpaVendorAdapter(jpaVendorAdapter);
																	emfb.setPackagesToScan("com.habuma.spittr.domain");
																	return emfb;
																}
																
																@Bean
																public JpaVendorAdapter jpaVendorAdapter() {
																	HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter();
																	adapter.setDatabase("HSQL");
																	adapter.setShowSql(true);
																	adapter.setGenerateDdl(false);
																	adapter.setDatabasePlatform("org.hibernate.dialect.HSQLDialect");
																	return adapter;
																}
																
																JNDI
																You can also configure the EntityManagerFactory bean with Java configuration by using
																
																@Bean
																public JndiObjectFactoryBean entityManagerFactory() {}
																JndiObjectFactoryBean jndiObjectFB = new JndiObjectFactoryBean();
																jndiObjectFB.setJndiName("jdbc/SpittrDS");
																return jndiObjectFB;
																}
																
																Just like all of Spring’s other persistence integration options, Spring-JPA integration comes in template form with JpaTemplate. 
																Nevertheless, template-based JPA has been set aside in favor of a pure JPA approach. This is analogous to the Hibernate contextual sessions we used.
																Because pure JPA is favored over template-based JPA, this section focuses on building Spring-free JPA repositories.
																
																@Repository
																@Transactional
																public class JpaSpitterRepository implements SpitterRepository {
																	@PersistenceUnit
																	private EntityManagerFactory emf;
																	public void addSpitter(Spitter spitter) {
																	emf.createEntityManager().persist(spitter);
																	}
																	public Spitter getSpitterById(long id) {
																	return emf.createEntityManager().find(Spitter.class, id);
																	}
																	public void saveSpitter(Spitter spitter) {
																	emf.createEntityManager().merge(spitter);
																	}
																	...
																}
																
																The only gotcha with JpaSpitterRepository as it stands is that each method ends up calling createEntityManager(). Aside from presenting a troubling codeduplication
																situation, it also means a new EntityManager is created every time one of the repository methods is called. 
																This complicates matters concerning transactions.
																Wouldn’t it be handy if you just had the EntityManager up front?
																THE PROBLEM IS THAT AN ENTITYMANAGER ISN’T THREAD-SAFE AND GENERALLY SHOULDN’T BE INJECTED INTO A SHARED SINGLETON BEAN LIKE YOUR REPOSITORY.
																
																@Repository
																@Transactional
																public class JpaSpitterRepository implements SpitterRepository {
																	
																	@PersistenceContext
																	private EntityManager em;
																	
																	public void addSpitter(Spitter spitter) {
																		em.persist(spitter);
																	}
																	
																	public Spitter getSpitterById(long id) {
																		return em.find(Spitter.class, id);
																	}
																	
																	public void saveSpitter(Spitter spitter) {
																		em.merge(spitter);
																	}
																	...
																}

									This new version of JpaSpitterRepository is now given an EntityManager directly; there’s no need for it to create one from an EntityManagerFactory in each of its methods. 
									Although this is much more convenient, you’re probably wondering about the thread-safety issues of working with an injected EntityManager.
									The truth is that @PersistenceContext doesn’t inject an EntityManager—at least, not exactly. Instead of giving the repository a real EntityManager, it gives a proxy to a
									real EntityManager. That real EntityManager either is one associated with the current transaction or, if one doesn’t exist, creates a new one. 
									Thus, you know that you’re always working with an entity manager in a thread-safe way.
									It’s important to understand that @PersistenceUnit and @PersistenceContext aren’t Spring annotations; they’re provided by the JPA specification. In order for Spring to understand them and inject an EntityManagerFactory 
									or EntityManager, Spring’s PersistenceAnnotationBeanPostProcessor must be configured. If you’re already using <context:annotation-config> or <context:component-scan>, then
									you’re good to go because those configuration elements automatically register a PersistenceAnnotationBeanPostProcessor bean. Otherwise, you’ll need to register that bean explicitly:
									
												@Bean
												public PersistenceAnnotationBeanPostProcessor paPostProcessor() {
													return new PersistenceAnnotationBeanPostProcessor();
												}
												
									@Repository serves the same purpose here as it did when you developed the Hibernate contextual session version of the repository. Without a template to handle exception
									translation, you need to annotate your repository with @Repository so PersistenceExceptionTranslationPostProcessor knows that this is a bean for which
									exceptions should be translated into one of Spring’s unified data-access exceptions.
									Speaking of PersistenceExceptionTranslationPostProcessor, you need to remember to wire it up as a bean in Spring just as you did for the Hibernate example:
									
												@Bean
												public BeanPostProcessor persistenceTranslation() {
													return new PersistenceExceptionTranslationPostProcessor();
												}

									Why keep writing the same persistence methods over and over again, just because you’re dealing with different domain types? Spring Data JPA brings an end to this boilerplate madness.

									public interface SpitterRepository extends JpaRepository<Spitter, Long> {
									}

									In doing so, JpaRepository is parameterized such that it knows this is a repository for persisting Spitter objects and that Spitters have an ID of type Long. 
									It also inherits 18 methods for performing common persistence operations, such as saving a Spitter, deleting a Spitter, and finding a Spitter by its ID.
									To ask Spring Data to create an implementation of SpitterRepository, you need to add a single element to your Spring configuration.

												XML
												<jpa:repositories base-package="com.habuma.spittr.db" />

									The <jpa:repositories> element holds all the magic of Spring Data JPA. Much like the <context:component-scan> element, <jpa:repositories> is given a basepackage
									to scan. But where <context:component-scan> scans a package (and its subpackages) for classes that are annotated with @Component, 
									<jpa:repositories> scans its base package for any interfaces that extend Spring Data JPA’s Repository interface.

												JAVA
												@Configuration
												@EnableJpaRepositories(basePackages="com.habuma.spittr.db")
												public class JpaConfiguration {
												...
												}

									Getting back to the SpitterRepository interface, it extends JpaRepository.
									JpaRepository extends the marker Repository interface (albeit indirectly). Therefore, SpitterRepository transitively extends the Repository interface that 
									repository-scanning is looking for. When Spring Data finds it, it creates an implementation of SpitterRepository, including an implementation of all 18 methods inherited
									from JpaRepository, PagingAndSortingRepository, and CrudRepository.

											public interface SpitterRepository extends JpaRepository<Spitter, Long> {
												Spitter findByUsername(String username);
											}

									How do you get Spring Data JPA to incorporate an implementation of that method?

									Actually, nothing else needs to be done to implement findByUsername(). The method signature tells Spring Data JPA everything it needs to know in order to create an implementation for the method.
									In essence, Spring Data defines a sort of miniature domain-specific language (DSL) where persistence details are expressed in repository method signatures.

									In situations where the desired data can’t be adequately expressed in the method name, you can use the @Query annotation to provide Spring Data with the query that should be performed.
											
											@Query("select s from Spitter s where s.email like '%gmail.com'")
											List<Spitter> findAllGmailSpitters();
											
									When Spring Data JPA generates the implementation for a repository interface, it also looks for a class whose name is the same as the interface’s name postfixed with Impl.
									If the class exists, Spring Data JPA merges its methods with those generated by Spring Data JPA.

							CACHE

									Although Spring doesn’t implement a cache solution, it offers declarative support for caching that integrates with several popular caching implementations. 
									Spring’s cache abstraction comes in two forms:
										Annotation-driven caching
										XML-declared caching
	
											@Configuration
											@EnableCaching
											public class CachingConfig {
											
											@Bean
											public CacheManager cacheManager() {
												return new ConcurrentMapCacheManager();
											}
											}

											<cache:annotation-driven />
											<bean id="cacheManager" class="org.springframework.cache.concurrent.ConcurrentMapCacheManager" />

									Under the covers, @EnableCaching and <cache:annotation-driven> work the same way. They create an aspect with pointcuts that trigger off of Spring’s caching annotations.

										cache manager
										SimpleCacheManager
										NoOpCacheManager
										ConcurrentMapCacheManager
										CompositeCacheManager
										EhCacheCacheManager

									Spring 3.2 introduced another cache manager for working with JCache
									RedisCacheManager (from Spring Data Redis)
									GemfireCacheManager (from Spring Data GemFire)

											@Configuration
											@EnableCaching
											public class CachingConfig {
											
											@Bean
											public EhCacheCacheManager cacheManager(CacheManager cm) {
												return new EhCacheCacheManager(cm);
											}
											
											@Bean
											public EhCacheManagerFactoryBean ehcache() {
												EhCacheManagerFactoryBean ehCacheFactoryBean = new EhCacheManagerFactoryBean();
												ehCacheFactoryBean.setConfigLocation(new ClassPathResource("com/habuma/spittr/cache/ehcache.xml"));
												return ehCacheFactoryBean;
											}

									Annotating methods for caching
									@Cacheable
									@CachePut
									@CacheEvict
									@Caching

											@Cacheable("spittleCache")
											public Spittle findOne(long id) {
											
												try {
													return jdbcTemplate.queryForObject(SELECT_SPITTLE_BY_ID,new SpittleRowMapper(),id);
												} catch (EmptyResultDataAccessException e) {
													return null;
												}
											}

									When you annotate the interface method, the @Cacheable annotation will be inherited by all implementations of SpittleRepository, and the same caching rules will be applied.

											@CachePut(value="spittleCache", key="#result.id")
											Spittle save(Spittle spittle);

									Suppose you don’t want to cache any Spittle objects whose message property contains the text “NoCache”. 
									To prevent such Spittles from being cached, you can set the unless attribute like this:

											@Cacheable(value="spittleCache"
											unless="#result.message.contains('NoCache')")
											Spittle findOne(long id);

							Securing methods with annotations

										@Configuration
										@EnableGlobalMethodSecurity(securedEnabled=true)
										public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
										}

										@Secured("ROLE_SPITTER")
										public void addSpittle(Spittle spittle) {
										// ...
										}
										
									The @Secured annotation takes an array of String as an argument. Each String value is an authorization, one of which is required to invoke the method. 
									By passing in ROLE_SPITTER, you tell Spring Security to not allow the addSpittle() method to be invoked unless the authenticated user has ROLE_SPITTER as one of their granted authorities.

									One drawback of the @Secured annotation is that it’s a Spring-specific annotation.
									If you’re more comfortable using annotations defined in Java standards, then perhaps you should consider using @RolesAllowed instead.

										@PreAuthorize Restricts access to a method before invocation based on the result of evaluating an expression
										@PostAuthorize Allows a method to be invoked, but throws a security exception if the expression evaluates to false
										@PostFilter Allows a method to be invoked, but filters the results of that method based on an expression
										@PreFilter Allows a method to be invoked, but filters input prior to entering the method

								We’ll look at specific examples of each of these in a moment. But first, you’ll need to enable them by setting @EnableGlobalMethodSecurity’s prePostEnabled attribute to true:
										
										@Configuration
										public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
										}

									But there’s a lot more to @PreAuthorize than is apparent in this simple example.
									The String argument to @PreAuthorize is a SpEL expression. With SpEL expressions guiding access decisions, far more advanced security constraints can be written. 

									For example, suppose that the average Spittr user can only write spittles of 140 characters or less, but premium users are allowed unlimited spittle lengths.
									The @Secured and @RolesAllowed annotations would be of no help here, but
									@PreAuthorize is on the case:
									@PreAuthorize("(hasRole('ROLE_SPITTER') and #spittle.text.length() <= 140)"+"or hasRole('ROLE_PREMIUM')")
									public void addSpittle(Spittle spittle) {
									// ...
									}

								@PreFilter("hasPermission(targetObject, 'delete')")
								public void deleteSpittles(List<Spittle> spittles) { ... }

								public class SpittlePermissionEvaluator implements PermissionEvaluator {

									private static final GrantedAuthority ADMIN_AUTHORITY = new GrantedAuthorityImpl("ROLE_ADMIN");

									public boolean hasPermission(Authentication authentication, Object target, Object permission) {
										if (target instanceof Spittle) {
											Spittle spittle = (Spittle) target;
											String username = spittle.getSpitter().getUsername();
											if ("delete".equals(permission)) {
											return isAdmin(authentication) || username.equals(authentication.getName());
											}
										}
									...

								Exporting an RMI service
								If you’ve ever created an RMI service, you know that it involves the following steps:
								1 Write the service implementation class with methods that throw java.rmi
								.RemoteException.
								2 Create the service interface to extend java.rmi.Remote.
								3 Run the RMI compiler (rmic) to produce client stub and server skeleton classes.
								4 Start an RMI registry to host the services.
								5 Register the service in the RMI registry.

									@Bean
									public RmiServiceExporter rmiExporter(SpitterService spitterService) {
										RmiServiceExporter rmiExporter = new RmiServiceExporter();
										rmiExporter.setService(spitterService);
										rmiExporter.setServiceName("SpitterService");
										rmiExporter.setServiceInterface(SpitterService.class);
										rmiExporter.setRegistryHost("rmi.spitter.com");
										rmiExporter.setRegistryPort(1199);
										return rmiExporter;
									}

									@Bean
									public RmiProxyFactoryBean spitterService() {
										RmiProxyFactoryBean rmiProxy = new RmiProxyFactoryBean();
										rmiProxy.setServiceUrl("rmi://localhost/SpitterService");
										rmiProxy.setServiceInterface(SpitterService.class);
										return rmiProxy;
									}

							RMI is an excellent way to communicate with remote services, but it has some limitations.
							First, RMI has difficulty working across firewalls. That’s because RMI uses arbitrary ports for communication—something that firewalls typically don’t allow. 
							In an intranet environment, this usually isn’t a concern. But if you’re working on the internet, you’ll probably run into trouble with RMI. 
							Even through RMI has support for tunneling over HTTP (which is usually allowed by firewalls), setting up RMI tunneling can be tricky.
							Another thing to consider is that RMI is Java-based. That means both the client and the service must be written in Java. And because RMI uses Java serialization, the types
							of the objects being sent across the network must have the exact same version of the Java runtime on both sides of the call.
							Hessian, like RMI, uses binary messages to communicate between client and service.
							But unlike other binary remoting technologies (such as RMI), the binary message is portable to languages other than Java, including PHP, Python, C++, and C#.
							Burlap is an XML-based remoting technology, which automatically makes it portable to any language that can parse XML. 
							And because it’s XML, it’s more easily humanreadable than Hessian’s binary format. Unlike other XML-based remoting technologies (such as SOAP and XML-RPC), Burlap’s message structure 
							is as simple as possible and doesn’t require an external definition language (such as WSDL or IDL).

								HessianServiceExporter is a Spring MVC controller  that receives Hessian requests and translates them into method calls on the exported POJO.

							@Bean
							public HessianServiceExporter hessianExportedSpitterService(SpitterService service) {
								HessianServiceExporter exporter = new HessianServiceExporter();
								exporter.setService(service);
								exporter.setServiceInterface(SpitterService.class);
								return exporter;
							}

						Unlike RmiServiceExporter, you don’t need to get a serviceName property. With RMI, the serviceName property is used to register a service in the RMI registry. 
						Hessian doesn’t have a registry, and, therefore, there’s no need to name a Hessian service.

							Another major difference between RmiServiceExporter and HessianServiceExporter is that because Hessian is HTTP-based, HessianServiceExporter is implemented as a Spring MVC controller. 
							This means that in order to use exported Hessian services, you’ll need to perform two additional configuration steps:
								Configure a Spring DispatcherServlet in web.xml, and deploy your application as a web application.
								Configure a URL handler in your Spring configuration to dispatch Hessian service URLs to the appropriate Hessian service bean.

								@Bean
								public HandlerMapping hessianMapping() {
									SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
									Properties mappings = new Properties();
									mappings.setProperty("/spitter.service","hessianExportedSpitterService");
									mapping.setMappings(mappings);
									return mapping;
								}

							There is, however, a best-of-both-worlds solution. Let’s look at Spring’s HTTP invoker, which offers RPC over HTTP (like Hessian/Burlap) while at the same time
							using Java serialization of objects (like RMI).
							The Spring team recognized a void between RMI services and HTTP-based services such as Hessian and Burlap. On the one side, RMI uses Java’s standard object serialization
							but is difficult to use across firewalls. On the other side, Hessian and Burlap work well across firewalls but use a proprietary object-serialization mechanism.

								JAX-WS

								@WebService(serviceName="SpitterService")
								public class SpitterServiceEndpoint extends SpringBeanAutowiringSupport {
								
									@Autowired
									SpitterService spitterService;
									@WebMethod
									public void addSpittle(Spittle spittle) {
									spitterService.saveSpittle(spittle);
								}

								SpringBeanAutowiringSupport is useful when the object whose properties are being injected doesn’t have its lifecycle managed by Spring. 
								But under the right circumstances, it’s possible to export a Spring-managed bean as a JAX-WS endpoint.

									@Bean
									public SimpleJaxWsServiceExporter jaxWsExporter() {
									return new SimpleJaxWsServiceExporter();
									}

								As you can see, SimpleJaxWsServiceExporter needs nothing else to do its job. When it gets started, it digs through the Spring application context looking for beans that
								are annotated with @WebService. When it finds one, it publishes the bean as a JAX-WS endpoint with a base address of http://localhost:8080/.

						Client

								@Bean
								public JaxWsPortProxyFactoryBean spitterService() {
									JaxWsPortProxyFactoryBean proxy = new JaxWsPortProxyFactoryBean();
									proxy.setWsdlDocument("http://localhost:8080/services/SpitterService?wsdl");
									proxy.setServiceName("spitterService");
									proxy.setPortName("spitterServiceHttpPort");
									proxy.setServiceInterface(SpitterService.class);
									proxy.setNamespaceUri("http://spitter.com");
									return proxy;
								}

						
						REST
							Spring offers two options to transform a resource’s Java representation into the representation that’s shipped to the client:
							Content negotiation—A view is selected that can render the model into a representation to be served to the client.
							Message conversion—A message converter transforms an object returned from the controller into a representation to be served to the client.

							When it comes to resolving view names into views that can produce resource representations, there’s an additional dimension to consider. Not only does the view need
							to match the view name, but the view also needs to be chosen to suit the client. If the client wants JSON data, then an HTML-rendering view won’t do—even if the view name matches.
							Spring’s ContentNegotiatingViewResolver is a special view resolver that takes the content type that the client wants into consideration.

							Working with HTTP message converters Message conversion is a more direct way to transform data produced by a controller into a representation that’s served to a client.
							When using message conversion, DispatcherServlet doesn’t bother with ferrying model data to a view. In fact, there is no model, and there is no view. 
							There is only data produced by the controller and a resource representation produced when a message converter transforms that data.

							Normally, when a handler method returns a Java object (anything other than String or an implementation of View), that object ends up in the model for rendering in the view. 
							But if you’re going to employ message conversion, you need to tell Spring to skip the normal model/view flow and use a message converter instead. 
							There are a handful of ways to do this, but the simplest is to annotate the controller method with @ResponseBody.

										@RequestMapping(method=RequestMethod.GET,
										produces="application/json")
										public @ResponseBody List<Spittle> spittles(@RequestParam(value="max",defaultValue=MAX_LONG_AS_STRING) long max,
										@RequestParam(value="count", defaultValue="20") int count) {
											return spittleRepository.findSpittles(max, count);
										}
										
						 The @ResponseBody annotation tells Spring that you want to send the returned object as a resource to the client, converted into some representational form that the client can accept.
						 More specifically, DispatcherServlet considers the request’s Accept header and looks for a message converter that can give the client the representation it wants.

						RECEIVING RESOURCE STATE IN THE REQUEST BODY
						So far, we’ve been focused on REST endpoints that serve resources to the client. But REST isn’t read-only. A REST API can also receive resource representations from the client. 
						It’d be inconvenient if your controller had to convert a JSON or XML representation sent from a client into an object it can use. 
						Spring’s message converters were able to convert objects into representations on the way out of your controllers can they do the same in reverse for representations coming in?
						Just as @ResponseBody tells Spring to employ a message converter when sending data to a client, the @RequestBody tells Spring to find a message converter to convert a resource 
						representation coming from a client into an object. 
						For example, suppose that you need a way for a client to submit a new Spittle to be saved. You can write the controller method to handle such a request like this:

										@RequestMapping(method=RequestMethod.POSTconsumes="application/json")
										public @ResponseBody Spittle saveSpittle(@RequestBody Spittle spittle) {
											return spittleRepository.save(spittle);
										}

						The @ResponseBody and @RequestBody annotations are succinct yet powerful ways to engage Spring’s message converters when handling requests. 
						But if you’re writing a controller that has several methods, all of which should use message conversion, then those annotations get somewhat repetitive.
						Spring 4.0 introduced the @RestController annotation to help with that. If you annotate your controller class with @RestController instead of @Controller, Spring applies message conversion to 
						all handler methods in the controller. You don’t need to annotate each method with @ResponseBody. SpittleController, as defined thus far, can look like the next listing.

						ASYNCHRONOUS COMMUNICATION

							There are two main actors in asynchronous messaging: message brokers and destinations.
							When an application sends a message, it hands it off to a message broker. A message broker is analogous to the post office. 
							The message broker ensures that the message is delivered to the specified destination, leaving the sender free to go about other business.
							Although different messaging systems may offer a variety of message-routing schemes, there are two common types of destinations: queues and topics. 
							Each of these is associated with a specific messaging model: either point-to-point (for queues) or publish/subscribe (for topics).

							POINT-TO-POINT MESSAGING
							In the point-to-point model, each message has exactly one sender and one receiver. When the message broker is given a message, it places the message in a queue. 
							When a receiver comes along and asks for the next message in the queue, the message is pulled from the queue and delivered to the receiver.
							Because the message is removed from the queue as it’s delivered, it’s guaranteed that the message will be delivered to only one receiver.
							Although each message in a message queue is delivered to only one receiver, this doesn’t imply that only one receiver is pulling messages from the queue. 
							It’s likely that several receivers are processing messages from the queue. But they’ll each be given their own messages to process.

						In the publish/subscribe messaging model, messages are sent to a topic.
						As with queues, many receivers may be listening to a topic. But unlike with queues, where a message is delivered to exactly one receiver, all subscribers to a topic receive a copy of
						the message

				JMS
						we'll need a JMS connection factory to be able to send messages through the message broker. 
						Because you’re using ActiveMQ as your message broker, we'll have to configure the JMS connection factory so that it knows how to connect to ActiveMQ. 
						ActiveMQConnectionFactory is the JMS connection factory that comes with ActiveMQ. You can configure it in Spring like this:
						
								<bean id="connectionFactory"class="org.apache.activemq.spring.ActiveMQConnectionFactory" />

						Optionally, because you know you’re dealing with ActiveMQ, you can use ActiveMQ’s own Spring configuration namespace

								<amq:connectionFactory id="connectionFactory" brokerURL="tcp://localhost:61616"/>

								<bean id="queue" class="org.apache.activemq.command.ActiveMQQueue" c:_="spitter.queue" />

						Optionnally

								<amq:queue id="spittleQueue" physicalName="spittle.alert.queue" />

						To use JmsTemplate, you’ll need to declare it as a bean in the Spring configuration file. 
						The following XML should do the trick:
								
								<bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate" c:_-ref="connectionFactory" />

								public class AlertServiceImpl implements AlertService {
								
								private JmsOperations jmsOperations;
								
								@Autowired
								public AlertServiceImpl(JmsOperations jmsOperatons) {
									this.jmsOperations = jmsOperations;
								}
								
								public void sendSpittleAlert(final Spittle spittle) {
										jmsOperations.send("spittle.alert.queue", new MessageCreator() {
																				public Message createMessage(Session session) throws JMSException {
																					return session.createObjectMessage(spittle);
																				}
																			}
														);
										}
								}

						CONVERTING MESSAGES WHEN SENDING

								public void sendSpittleAlert(Spittle spittle) {
									jmsOperations.convertAndSend(spittle);
								}

								public interface MessageConverter {
									Message toMessage(Object object, Session session) throws JMSException, MessageConversionException;
									Object fromMessage(Message message) throws JMSException, MessageConversionException;
								}


								<bean id="messageConverter" class="org.springframework.jms.support.converter.MappingJacksonMessageConverter" />

								Then you can wire it into JmsTemplate like this:
								<bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate" c:_-ref="connectionFactory" p:defaultDestinationName="spittle.alert.queue" p:messageConverter-ref="messageConverter" />

						CONSUMING MESSAGES

								public Spittle receiveSpittleAlert() {
									try {
										ObjectMessage receivedMessage = (ObjectMessage) jmsOperations.receive();
										return (Spittle) receivedMessage.getObject();
									} catch (JMSException jmsException) {
										throw JmsUtils.convertJmsAccessException(jmsException);
									}
								}

									take advantage of a message converter. You’ve seen how message converters can convert objects to Messages in convertAndSend(). 
									But they can also be used on the receiving end with JmsTemplate’s receiveAndConvert():

								public Spittle retrieveSpittleAlert() {
									return (Spittle) jmsOperations.receiveAndConvert();
								}

								The big downside of consuming messages with JmsTemplate is that both the receive() and receiveAndConvert() methods are synchronous. 
								This means the receiver must wait patiently for the message to arrive, because those methods will block until a message is available (or until a timeout condition occurs). 
								Doesn’t it seem odd to synchronously consume a message that was asynchronously sent?
								That’s where message-driven POJOs come in handy. Let’s see how to receive messages asynchronously using components that react to messages rather than wait on them.

								Spring 2.0 addresses the need for asynchronous consumption of messages by providing its own form of message-driven bean that’s similar to EJB 3’s MDBs. 
								In this section, you’ll learn how Spring supports asynchronous message consumption using message-driven POJOs (we’ll call them MDPs, for short).



							How to make remote calls that use JMS as a transport.

							To support message-based RPC, Spring offers JmsInvokerServiceExporter for exporting beans as message-based services and JmsInvokerProxyFactoryBean for clients to consume those services.
							If HttpInvokerServiceExporter exports services that communicate over HTTP, then JmsInvokerServiceExporter must export services that converse over JMS.

									@Component("alertService")
									public class AlertServiceImpl implements AlertService {
										private JavaMailSender mailSender;
										private String alertEmailAddress;
									
										public AlertServiceImpl(JavaMailSender mailSender,String alertEmailAddress) {
											this.mailSender = mailSender;
											this.alertEmailAddress = alertEmailAddress;
										}
									
										public void sendSpittleAlert(final Spittle spittle) {
											SimpleMailMessage message = new SimpleMailMessage();
											String spitterName = spittle.getSpitter().getFullName();
											message.setFrom("noreply@spitter.com");
											message.setTo(alertEmailAddress);
											message.setSubject("New spittle from " + spitterName);
											message.setText(spitterName + " says: " + spittle.getText());
											mailSender.send(message);
										}
									}

								Don’t concern yourself too much with the inner details of the sendSpittleAlert() method at this point. We’ll talk more about how to send emails with Spring later, in chapter 20. 
								The important thing to notice is that AlertServiceImpl is a simple POJO and has nothing that indicates it will be used to handle JMS messages.

								As you can see, AlertServiceImpl is annotated with @Component so that it will be automatically discovered and registered as a bean in the Spring application context with an ID of alertService. 
								You’ll refer to this bean as you configure a JmsInvokerServiceExporter:

								<bean id="alertServiceExporter" class="org.springframework.jms.remoting.JmsInvokerServiceExporter" p:service-ref="alertService" 
								p:serviceInterface="com.habuma.spittr.alerts.AlertService" />

							The exporter’s properties don’t describe the specifics of how the service will be carried over JMS.
							But the good news is that JmsInvokerServiceExporter qualifies as a JMS listener. 
							Therefore, you can configure it as such in a <jms:listener-container>
							element:
							
							<jms:listener-container connection-factory="connectionFactory">
								<jms:listener destination="spitter.alert.queue" ref="alertServiceExporter" />
							</jms:listener-container>

							To consume the alert service, you can wire the JmsInvokerProxyFactoryBean like this:
							<bean id="alertService" class="org.springframework.jms.remoting.JmsInvokerProxyFactoryBean" p:connectionFactory-ref="connectionFactory" 
							p:queueName="spittle.alert.queue" propp:serviceInterface="com.habuma.spittr.alerts.AlertService" />

					Messaging with AMQP
								You may be wondering why you need another messaging specification. Isn’t JMS good enough? What does AMQP bring to the table that is missing from JMS?
								As it turns out, AMQP offers several advantages over JMS. First, AMQP defines a wire-level protocol for messaging, whereas JMS defines an API specification. 
								JMS’s API specification ensures that all JMS implementations can be used through a common API but doesn’t mandate that messages sent by one JMS implementation can be consumed
								by a different JMS implementation. AMQP’s wire-level protocol, on the other hand, specifies the format that messages will take when en route between the producer and consumer. 
								Consequently, AMQP is more interoperable than JMS—not only across different AMQP implementations, but also across languages and platforms.
								Another significant advantage of AMQP over JMS is that AMQP has a much more flexible and transparent messaging model. 
								With JMS, there are only two messaging models to choose from: point-to-point and publish/subscribe. 
								Both of those models are certainly possible with AMQP, but AMQP enables you to route messages in a number of ways, and it does this by decoupling the message producer 
								from the queue(s) in which the messages will be placed.
								To understand the AMQP messaging model, it may help to briefly recall the JMS messaging model.
								In JMS, there are just three primary participants: the message producer, the message consumer(s), and a channel (either a queue or a topic) to carry the message between producers and consumers.
								In JMS, the channel helps to decouple the producer from the consumer, but both are still coupled to the channel. 
								A producer publishes messages to a specific queue or topic, and the consumer receives those message from a specific queue or topic. 
								The channel has the double duty of relaying messages and determining how those messages will be routed; queues route using a point-to-point algorithm, 
								and topics route in publish/subscribe fashion.
								In contrast, AMQP producers don’t publish directly to a queue. 
								Instead, AMQP introduces a new level of indirection between the producer and any queues that will carry the message:  the exchange.
								The exchange isn’t a pass-through mechanism to a queue. 
								AMQP defines four different types of exchanges, each with a different routing algorithm that decides whether to place a message in a queue. 
								Depending on an exchange’s algorithm, it may consider the message’s routing key and/or arguments and compare those with the routing key and arguments of the binding between the
								exchange and a queue. (A routing key can be loosely thought of as the To address in an email, specifying the intended recipient.) 
								If the algorithm is satisfied with the comparison, the message will be routed to the queue. If not, then it won’t be routed to the queue.

							The four standard types of AMQP exchanges are as follows:
								Direct—A message will be routed to a queue if its routing key is a direct match for the routing key of the binding.
								Topic—A message will be routed to a queue if its routing key is a wildcard match for the routing key of the binding.
								Headers—A message will be routed to a queue if the headers and values in its table of arguments match those in the binding’s table of arguments. 
										A special header named x-match can specify whether all values must match or if any can match.
								Fanout—A message will be routed to all queues that are bound to the exchange, regardless of the routing key or headers/values in the table of arguments.

With these four types of exchanges, it’s easy to imagine how you can define any number
of routing schemes that go beyond simple point-to-point or publish/subscribe.2
Fortunately, when it comes to sending and receiving messages, the routing algorithm(
s) in play have little impact on how you develop the message producers and
consumers. Put simply, producers publish to an exchange with a routing key; consumers
retrieve from a queue.

<connection-factory id="connectionFactory"
host="${rabbitmq.host}"
port="${rabbitmq.port}"
username="${rabbitmq.username}"
password="${rabbitmq.password}" />

Unlike JMS, where the routing behavior of queues and topics is established by the
specification, AMQP routing is richer and more flexible and thus depends on you to
define the queues and exchanges and how they’re bound to each other. One way of
declaring queues, exchanges, and bindings is via a variety of methods on the
RabbitMQ Channel interface. But working with RabbitMQ’s Channel directly is
involved. Can Spring AMQP help you declare your message-routing components?
Fortunately, the rabbit namespace includes several elements to help declare
queues, exchanges, and the bindings that tie them together.

The simplest configuration for RabbitTemplate can be done using the <template>
element from the rabbit configuration namespace as follows:
<template id="rabbitTemplate"
connection-factory="connectionFactory" />
Now all you need to do to send a message is inject the template bean into Alert-
ServiceImpl and use it to send a Spittle. The following listing shows a new version
of AlertServiceImpl that uses RabbitTemplate instead of JmsTemplate to send a
Spittle alert.

As you’ll recall, Spring’s JMS support offers two ways to fetch a message from a queue:
synchronously via JmsTemplate and asynchronously with message-driven POJOs.
Spring AMQP offers similar options for retrieving messages sent over AMQP. Because
you already have a RabbitTemplate handy.

Finally, you need to declare a listener container and a listener to call on Spittle-
AlertHandler when a message arrives. You did this for JMS-based MDPs, but there is a
slight difference in the configuration for AMQP-based MDPs:
<listener-container connection-factory="connectionFactory">
<listener ref="spittleListener"
method="handleSpittleAlert"
queue-names="spittle.alert.queue" />
</listener-container>
Do you see the difference? I’ll agree that it’s not obvious. The <listener-container>
and <listener> elements appear to be similar to their JMS counterparts. These elements,
however, come from the rabbit namespace instead of the JMS namespace.

WEBSOCKETS AND STOMP

WebSocket is a protocol providing full-duplex communication across a single
socket. It enables, among other things, asynchronous messaging between a web
browser and a server. Being full-duplex means that the server can send messages to
the browser as well as the browser sending messages to the server.

To handle
messages in Spring with low-level WebSocket support, you must write a class that implements WebSocketHandler:

public interface WebSocketHandler {
	void afterConnectionEstablished(WebSocketSession session) throws Exception;
	void handleMessage(WebSocketSession session, WebSocketMessage<?> message) throws Exception;
	void handleTransportError(WebSocketSession session, Throwable exception) throws Exception;
	void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception;
	boolean supportsPartialMessages();
}

public class MarcoHandler extends AbstractWebSocketHandler {
	private static final Logger logger = LoggerFactory.getLogger(MarcoHandler.class);
	
	protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
		logger.info("Received message: " + message.getPayload());
		Thread.sleep(2000);
	session.sendMessage(new TextMessage("Polo!"));
	}
}

public class MarcoHandler extends AbstractWebSocketHandler {
private static final Logger logger =
LoggerFactory.getLogger(MarcoHandler.class);
protected void handleTextMessage(
WebSocketSession session, TextMessage message) throws Exception {
logger.info("Received message: " + message.getPayload());
Thread.sleep(2000);
session.sendMessage(new TextMessage("Polo!"));
}
}

Alternatively, you could extend TextWebSocketHandler instead of AbstractWebSocketHandler:

public class MarcoHandler extends TextWebSocketHandler {
...

}

TextWebSocketHandler is a subclass of AbstractWebSocketHandler that refuses to handle binary messages. It overrides handleBinaryMessage() to close the WebSocket
connection if a binary connection is received. In a similar way, Spring also offers BinaryWebSocketHandler, a subclass of AbstractWebSocketHandler that overrides
handleTextMessage() to close the connection if a text message is received.

public void afterConnectionEstablished(WebSocketSession session) throws Exception {
	logger.info("Connection established");
}
@Override
public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
	logger.info("Connection closed. Status: " + status);
}

Now that you have a message handler class, you must configure it so that Spring will
dispatch messages to it. In Spring’s Java configuration, this involves annotating a configuration
class with @EnableWebSocket and implementing the WebSocketConfigurer
interface

@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
@Override
public void registerWebSocketHandlers(
WebSocketHandlerRegistry registry) {
registry.addHandler(marcoHandler(), "/marco");
}
@Bean
public MarcoHandler marcoHandler() {
return new MarcoHandler();
}
}

WebSocket fallback is the specialty of SockJS. SockJS is a WebSocket
emulator that mirrors the WebSocket API as closely as possible on the surface, but
under the covers is clever enough to choose another form of communication when
WebSocket isn’t available. SockJS will always favor WebSocket first, but if WebSocket
isn’t an option, it will determine the best available option from the following:
 XHR streaming
 XDR streaming
 iFrame event source
 iFrame HTML file
XHR polling
 XDR polling
 iFrame XHR polling
 JSONP polling

to enable SockJS communication on the server side, you can simply
ask for it in the Spring configuration. Revisiting the registerWebSocketHandlers()
method from listing 18.2, you can enable WebSocket with a small addition:
@Override
public void registerWebSocketHandlers(
WebSocketHandlerRegistry registry) {
registry.addHandler(marcoHandler(), "/marco").withSockJS();
}
By simply calling withSockJS() on the WebSocketHandlerRegistration returned
from the call to addHandler(), you’re saying that you want SockJS to be enabled, and
for its fallbacks to go into effect if WebSocket can’t be used.

to enable SockJS communication on the server side, you can simply
ask for it in the Spring configuration. Revisiting the registerWebSocketHandlers()
method from listing 18.2, you can enable WebSocket with a small addition:
@Override
public void registerWebSocketHandlers(
WebSocketHandlerRegistry registry) {
registry.addHandler(marcoHandler(), "/marco").withSockJS();
}
By simply calling withSockJS() on the WebSocketHandlerRegistration returned
from the call to addHandler(), you’re saying that you want SockJS to be enabled, and
for its fallbacks to go into effect if WebSocket can’t be used.

Enabling STOMP messaging
In a moment, you’ll see how to annotate controller methods with @MessageMapping to
handle STOMP messages within Spring MVC in a way very similar to how @Request-
Mapping-annotated methods handle HTTP requests. Unlike @RequestMapping, however,
@MessageMapping isn’t enabled by the @EnableWebMvc annotation. Spring’s web
messaging is built around a message broker, so there’s more to configure than just telling
Spring that you’d like to handle messages. You must also configure a message broker and some basic destination details.

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketStompConfig
extends AbstractWebSocketMessageBrokerConfigurer {
@Override
public void registerStompEndpoints(StompEndpointRegistry registry) {
registry.addEndpoint("/marcopolo").withSockJS();
}
@Override
public void configureMessageBroker(MessageBrokerRegistry registry) {
registry.enableSimpleBroker("/queue", "/topic");
registry.setApplicationDestinationPrefixes("/app");
}
}

WebSocketStompConfig also configures a simple message broker by overriding the
configureMessageBroker() method. This method is optional. If you don’t override
it, you’ll get a simple in-memory message broker configured to handle messages prefixed
with /topic.

The simple broker is great for getting started, but it has a few limitations. Although it
mimics a STOMP message broker, it only supports a subset of STOMP commands. And
because it’s memory-based, it’s not suitable for clusters where each node would be
managing its own broker and set of messages.
For a production application, you’ll probably want to back your WebSocket messaging
with a real STOMP-enabled broker, such as RabbitMQ or ActiveMQ. Such brokers
will offer more scalable and robust messaging, not to mention the complete set of
STOMP commands. You’ll need to be sure to set up your broker for STOMP according
to their documentation. Once the broker is ready, you can replace the default inmemory
broker with a STOMP broker relay by overriding the configureMessage-
Broker() method

SPRING BOOT


															
														
											
										